<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta http-equiv="Permissions-Policy" content="autoplay=*, encrypted-media=*, picture-in-picture=*, accelerometer=*, gyroscope=*, clipboard-write=*, web-share=*">
  <title>VeeMusic DJ - Professional DJ Mixing Experience</title>
  <meta name="copyright" content="¬© 2025 VIPUL RULES. All rights reserved.">
  <meta name="author" content="VIPUL RULES">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      position: relative;
      transition: background 0.5s ease;
      -webkit-overflow-scrolling: touch;
      /* Prevent zoom on mobile */
      touch-action: pan-x pan-y;
      -ms-touch-action: pan-x pan-y;
    }
    
    /* Prevent zoom on mobile - disable pinch zoom */
    @media (max-width: 768px) {
      * {
        touch-action: pan-x pan-y;
        -ms-touch-action: pan-x pan-y;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }
      
      input, textarea, select {
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
      }
    }

    .background-videos {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      overflow: hidden;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%);
    }

    /* Hide background videos on mobile - just show black background */
    @media (max-width: 768px) {
      .background-videos {
        display: none !important;
      }
      .background-video {
        display: none !important;
      }
      .background-overlay {
        background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%) !important;
      }
      body {
        background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 50%, #16213e 100%) !important;
      }
    }

    .background-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      display: block;
    }

    .background-video.active {
      opacity: 1;
      z-index: 1;
    }

    .background-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: -1;
      pointer-events: none;
      transition: background 0.3s ease;
    }

    .background-overlay.search-active {
      background: rgba(0, 0, 0, 0.85);
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      padding: 20px;
      overflow: visible;
      position: relative;
      z-index: 10;
      min-height: 100vh;
    }

    body.copilot-active {
      animation: clubLights 3s ease infinite;
    }

    @keyframes clubLights {
      0% {
        background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
      }
      25% {
        background: linear-gradient(135deg, #fb5607 0%, #ff006e 50%, #8338ec 100%);
      }
      50% {
        background: linear-gradient(135deg, #ffbe0b 0%, #fb5607 50%, #ff006e 100%);
      }
      75% {
        background: linear-gradient(135deg, #06ffa5 0%, #ffbe0b 50%, #fb5607 100%);
      }
      100% {
        background: linear-gradient(135deg, #3a86ff 0%, #06ffa5 50%, #ffbe0b 100%);
      }
    }


    header {
      flex-shrink: 0;
      margin-bottom: 24px;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 2px;
      letter-spacing: -0.3px;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      font-weight: 400;
      margin-bottom: 4px;
    }

    .instruction-text {
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      font-weight: 400;
      line-height: 1.4;
      margin-top: 6px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .search-section {
      flex-shrink: 0;
      margin-bottom: 20px;
    }

    #searchForm {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #searchQuery {
      flex: 1;
      padding: 10px 14px;
      font-size: 15px;
      font-weight: 400;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #ffffff;
      outline: none;
      transition: all 0.2s ease;
    }

    #searchQuery::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #searchQuery:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    #searchButton {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.95);
      border: none;
      border-radius: 6px;
      color: #000000;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #searchButton:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    .copilot-section {
      flex-shrink: 0;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #copilotButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #copilotButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #copilotButton.active {
      background: #ffffff;
      color: #000000;
      border-color: #ffffff;
    }

    #beatDropButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #beatDropButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #beatDropButton.active {
      background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
      color: #ffffff;
      border-color: transparent;
      animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 0, 110, 0.7);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 20px 5px rgba(255, 0, 110, 0.4);
      }
    }

    #lockButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #lockButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #lockButton.unlocked {
      background: linear-gradient(135deg, #06ffa5 0%, #3a86ff 100%);
      border-color: transparent;
      animation: pulse 2s ease infinite;
    }

    #lockButton.unlocked #lockText::after {
      content: " - JAM with DJ VEEX20";
    }

    #spacebarButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #spacebarButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #spacebarButton.active {
      background: linear-gradient(135deg, #ff006e 0%, #8338ec 100%);
      border-color: transparent;
      animation: pulse 1s ease infinite;
    }

    #peopleModeButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #peopleModeButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #peopleModeButton.active {
      background: linear-gradient(135deg, #06ffa5 0%, #3a86ff 100%);
      border-color: transparent;
      animation: pulse 2s ease infinite;
    }

    #energyLevel {
      font-size: 11px;
      opacity: 0.7;
      transition: opacity 0.3s ease;
    }

    #voiceButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #voiceButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #voiceButton.recording {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.5);
      animation: pulse 1s ease infinite;
    }

    #voiceButton.playing {
      background: rgba(0, 255, 0, 0.2);
      border-color: rgba(0, 255, 0, 0.4);
    }

    #voiceIcon {
      width: 18px;
      height: 18px;
      display: inline-block;
    }

    #voiceIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    #lockIcon {
      width: 18px;
      height: 18px;
      display: inline-block;
    }

    #lockIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .add-more-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tts-section {
      margin-top: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .tts-prefill {
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tts-prefill:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    #ttsIcon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }

    #ttsIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    #ttsInput::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #ttsInput:focus {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.05);
    }

    #addMoreQuery::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #addMoreQuery:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    #results {
      flex: 1;
      display: flex;
      gap: 16px;
      overflow: hidden;
      padding: 0;
      min-height: 0;
    }

    .tracks-panel {
      width: 300px;
      flex-shrink: 0;
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-right: 8px;
    }

    .tracks-panel::-webkit-scrollbar {
      width: 6px;
    }

    .tracks-panel::-webkit-scrollbar-track {
      background: transparent;
    }

    .tracks-panel::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .primary-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .primary-video-card {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      min-height: 0;
    }

    .primary-video-wrapper {
      flex: 1;
      min-height: 400px;
      height: 100%;
      position: relative;
      background: #000;
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .primary-video-wrapper iframe {
      width: 100%;
      height: 100%;
      min-height: 400px;
      border: none;
      position: absolute;
      top: 0;
      left: 0;
    }

    .track-card-small {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .track-card-small:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.15);
    }

    .track-card-small.active {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .track-thumbnail {
      width: 160px;
      height: 90px;
      border-radius: 4px;
      overflow: hidden;
      flex-shrink: 0;
      background: #000;
      position: relative;
      min-width: 160px;
      min-height: 90px;
    }

    .track-thumbnail iframe {
      width: 100%;
      height: 100%;
      border: none;
      pointer-events: none;
      display: block;
    }

    .track-info-small {
      flex: 1;
      min-width: 0;
    }

    .track-title-small {
      font-size: 12px;
      color: #ffffff;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }

    .track-channel-small {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .move-to-primary-btn {
      padding: 4px 8px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      flex-shrink: 0;
    }

    .move-to-primary-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    #results::-webkit-scrollbar {
      width: 6px;
    }

    #results::-webkit-scrollbar-track {
      background: transparent;
    }

    #results::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    #results::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .video-card {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.02);
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateY(20px);
      animation: fadeInUp 0.6s ease forwards;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      position: relative;
      width: fit-content;
      max-width: 100%;
    }

    .close-button {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: all 0.2s ease;
      padding: 0;
      opacity: 0.7;
    }

    .close-button svg {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .close-button:hover {
      background: rgba(255, 0, 0, 0.8);
      color: #ffffff;
      transform: scale(1.1);
      opacity: 1;
    }


    .eq-controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }

    .eq-control {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .eq-label {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 600;
      text-transform: uppercase;
      cursor: help;
    }

    .cue-buttons-group {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      justify-content: center;
    }

    .cue-number-btn {
      width: 32px;
      height: 32px;
      padding: 0;
      font-size: 12px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cue-number-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .cue-number-btn.active {
      background: #3a86ff;
      border-color: #3a86ff;
      transform: scale(1.1);
    }

    .eq-slider {
      width: 100%;
      height: 60px;
      writing-mode: vertical-lr;
      direction: rtl;
      writing-mode: bt-lr;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      outline: none;
      cursor: pointer;
    }

    .cue-point-button {
      padding: 4px 8px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cue-point-button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .cue-point-button.active {
      background: #3a86ff;
      border-color: #3a86ff;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .video-card:nth-child(1) {
      animation-delay: 0.1s;
    }

    .video-card:nth-child(2) {
      animation-delay: 0.2s;
    }

    .video-card:nth-child(3) {
      animation-delay: 0.3s;
    }

    .video-card:nth-child(4) {
      animation-delay: 0.4s;
    }

    .video-card.disabled {
      opacity: 0.6;
      pointer-events: none;
    }

    .video-card.disabled .play-button,
    .video-card.disabled .slider {
      cursor: not-allowed;
      opacity: 0.5;
    }

    .video-card:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.1);
    }

    .video-card.playing {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.06);
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%;
      background: #0a0a0a;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .video-wrapper video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 20px;
    }

    .video-wrapper > div {
      border-radius: 20px;
      overflow: hidden;
    }

    .video-wrapper > div {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .video-wrapper iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .video-info {
      margin-bottom: 10px;
      flex-shrink: 0;
    }

    .video-title {
      font-size: 12px;
      font-weight: 500;
      color: #ffffff;
      margin-bottom: 2px;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-channel {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      font-weight: 400;
    }

    .video-genre {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.5);
      font-weight: 500;
      margin-top: 3px;
      padding: 2px 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
      display: inline-block;
      letter-spacing: 0.3px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-shrink: 0;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
    }

    .control-icon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .control-value {
      font-size: 11px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.8);
      min-width: 40px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .slider-container {
      flex: 1;
      position: relative;
    }

    .slider {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .slider:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      transition: all 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: none;
    }

    .play-button {
      width: 100%;
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .play-button svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: currentColor;
      stroke-width: 0;
    }

    .play-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .play-button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .play-button.playing {
      background: rgba(6, 255, 165, 0.2);
      border-color: rgba(6, 255, 165, 0.4);
      color: #06ffa5;
    }

    .reverse-button {
      transition: all 0.2s ease;
    }

    .reverse-button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .reverse-button.active {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.5);
      color: #ff6b6b;
      animation: pulse 1s ease infinite;
    }

    .reverse-button svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: currentColor;
      stroke-width: 0;
    }

    .loading {
      text-align: center;
      padding: 40px 20px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 14px;
      font-weight: 400;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: rgba(255, 255, 255, 0.6);
    }

    .empty-state p {
      font-size: 14px;
      margin-top: 12px;
    }

    @media (max-width: 768px) {
      body {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .container {
        padding: 12px;
        min-height: auto;
      }

      #results {
        grid-template-columns: 1fr;
        gap: 12px;
        padding-bottom: 40px;
      }

      #searchForm {
        flex-direction: column;
        gap: 8px;
      }

      #searchButton {
        width: 100%;
        padding: 12px;
      }

      #searchQuery {
        width: 100%;
        padding: 12px;
        font-size: 16px; /* Prevents zoom on iOS */
      }

      h1 {
        font-size: 24px;
        margin-bottom: 8px;
      }

      .subtitle {
        font-size: 12px;
      }

      .instruction-text {
        font-size: 11px;
        padding: 10px;
        margin-top: 8px;
      }

      .video-card {
        padding: 12px;
        border-radius: 16px;
      }

      .video-wrapper {
        border-radius: 16px;
        margin-bottom: 10px;
      }

      .video-title {
        font-size: 12px;
      }

      .video-channel {
        font-size: 11px;
      }

      .video-genre {
        font-size: 9px;
        padding: 2px 5px;
      }

      .controls {
        gap: 8px;
      }

      .control-group {
        gap: 6px;
      }

      .control-icon {
        font-size: 12px;
        width: 20px;
      }

      .control-value {
        font-size: 10px;
        min-width: 35px;
      }

      .slider {
        height: 6px;
      }

      .slider::-webkit-slider-thumb {
        width: 16px;
        height: 16px;
      }

      .play-button {
        padding: 10px;
        font-size: 14px;
      }

      header {
        margin-bottom: 16px;
      }

      .search-section {
        margin-bottom: 16px;
      }

      .copilot-section {
        margin-bottom: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      #copilotButton {
        width: 100%;
        padding: 12px;
      }

      #beatDropButton {
        width: 100%;
        padding: 12px;
        margin-left: 0 !important;
      }

      #lockButton {
        width: 100%;
        padding: 12px;
        margin-left: 0 !important;
      }

      .add-more-section {
        margin-top: 16px;
        padding-top: 16px;
      }

      #addMoreForm {
        flex-direction: column;
        gap: 8px;
      }

      #addMoreButton {
        width: 100%;
      }

      .close-button {
        width: 32px;
        height: 32px;
        font-size: 22px;
        top: 8px;
        right: 8px;
      }

      .eq-controls {
        flex-direction: row;
        gap: 4px;
        padding: 6px;
      }

      .eq-slider {
        height: 50px;
      }

      .cue-point-button {
        font-size: 9px;
        padding: 3px 6px;
      }

      footer {
        margin-top: 30px;
        padding: 16px;
      }

      .tts-section {
        margin-top: 12px;
        padding: 10px;
      }

      .tts-prefill {
        font-size: 10px;
        padding: 5px 10px;
      }

      #ttsInput {
        font-size: 12px;
        padding: 8px 10px;
      }

      #ttsButton {
        font-size: 12px;
        padding: 8px 12px;
      }
      
      #ttsStopButton {
        font-size: 12px;
        padding: 6px 12px;
      }
    }
    
    /* Ensure stop button is always clickable */
    #ttsStopButton {
      pointer-events: auto !important;
      opacity: 1 !important;
      cursor: pointer !important;
    }
    
    #ttsStopButton:disabled {
      opacity: 0.6 !important;
      cursor: not-allowed !important;
    }
    
    #ttsStopButton:active {
      transform: scale(0.95);
      background: rgba(255, 0, 0, 0.4) !important;
    }
    
    #ttsStopButton:hover:not(:disabled) {
      background: rgba(255, 0, 0, 0.3) !important;
      border-color: rgba(255, 0, 0, 0.6) !important;
    }

    @media (max-width: 480px) {
      .container {
        padding: 10px;
      }

      h1 {
        font-size: 20px;
      }

      .video-card {
        padding: 10px;
      }

      .control-group label {
        font-size: 11px;
      }

      .control-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
      }
    }

    video {
      display: none;
    }

    #overlay {
      display: none;
    }
  </style>
</head>
<body>
  <video id="webcam" autoplay playsinline></video>
  <div id="overlay"></div>

  <div class="background-videos" id="backgroundVideos"></div>
  <div class="background-overlay"></div>

  <div class="container">
    <header>
  <h1>VeeMusic DJ</h1>
      <p class="subtitle">Professional DJ Mixing Experience</p>
      <p class="instruction-text">Search video, enter and press the DJ VEEX20 take care and use the controls to feel the dj already</p>
      <p class="eq-explanation" style="font-size: 10px; color: rgba(255, 255, 255, 0.4); margin-top: 6px; padding: 6px; background: rgba(255, 255, 255, 0.02); border-radius: 4px; text-align: center;">
        <strong>EQ Controls:</strong> Low (Bass) ‚Ä¢ Mid (Vocals) ‚Ä¢ High (Treble) - Adjust frequency ranges for better mixing
      </p>
      <p class="copyright-notice" style="font-size: 9px; color: rgba(255, 255, 255, 0.3); margin-top: 4px; text-align: center;">¬© 2025 VIPUL RULES. All rights reserved.</p>
    </header>

    <div class="search-section">
  <form id="searchForm">
        <input 
          type="text" 
          id="searchQuery" 
          placeholder="Search music..."
          autocomplete="off"
        >
    <button type="submit" id="searchButton">‚ñ∂</button>
  </form>
    </div>

    <div class="copilot-section">
      <button id="copilotButton">Auto Mix</button>
    </div>

    <div class="tts-section" id="ttsSection" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.02); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.05);">
      <div style="display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
        <button class="tts-prefill" data-text="Let's go!">Let's go!</button>
        <button class="tts-prefill" data-text="Drop the beat!">Drop the beat!</button>
        <button class="tts-prefill" data-text="This is DJ VEEX20!">DJ VEEX20!</button>
        <button class="tts-prefill" data-text="Feel the music!">Feel the music!</button>
        <button class="tts-prefill" data-text="Energy rising!">Energy rising!</button>
        <button class="tts-prefill" data-text="Here we go!">Here we go!</button>
      </div>
      <div style="display: flex; gap: 8px; align-items: center;">
        <input 
          type="text" 
          id="ttsInput" 
          placeholder="Type text to speak..."
          style="flex: 1; padding: 8px 12px; font-size: 13px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(255, 255, 255, 0.03); color: #ffffff; outline: none;"
        >
        <button id="ttsButton" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #ffffff; cursor: pointer; min-height: 36px;">
          <span id="ttsIcon"></span>
          <span style="margin-left: 5px;">Speak</span>
        </button>
        <button id="ttsStopButton" type="button" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.4); border-radius: 6px; color: #ff6b6b; cursor: pointer; min-height: 36px; transition: all 0.2s ease;">
          <span>‚èπ</span>
          <span style="margin-left: 5px;">Stop</span>
        </button>
      </div>
    </div>

    <div class="sound-effects-section" id="soundEffectsSection" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.02); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.05);">
      <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
        <span style="font-size: 13px; color: rgba(255, 255, 255, 0.7); margin-right: 8px;">Sound Effects:</span>
        <button id="truckSoundBtn" class="sound-effect-btn" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #ffffff; cursor: pointer;">üöö Truck</button>
        <button id="fireStationSoundBtn" class="sound-effect-btn" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #ffffff; cursor: pointer;">üö® Fire Station</button>
        <button id="bowBowBowBtn" class="sound-effect-btn" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #ffffff; cursor: pointer;">üîä BOW BOW BOW</button>
      </div>
    </div>

  <div id="results" class="main-content">
    <div class="tracks-panel" id="tracksPanel"></div>
    <div class="primary-panel" id="primaryPanel">
      <div class="primary-video-card" id="primaryVideoCard" style="display: none;">
        <div class="primary-video-wrapper" id="primaryVideoWrapper"></div>
        <div class="video-info" id="primaryVideoInfo" style="margin-top: 12px;"></div>
        <div class="controls" id="primaryControls" style="margin-top: 12px;"></div>
      </div>
      <div id="emptyState" style="flex: 1; display: flex; align-items: center; justify-content: center; color: rgba(255, 255, 255, 0.4); font-size: 14px;">
        Click a track on the left to make it primary
      </div>
    </div>
  </div>

  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <!-- Note: True pitch shifting without speed change requires direct audio access -->
  <!-- YouTube iframes block this due to CORS, so we use playbackRate as a workaround -->
  <script>
    // SVG Icon Functions - Minimalistic Design
    function getSVGIcon(type) {
      const icons = {
        volume: '<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>',
        speed: '<svg viewBox="0 0 24 24"><path d="M13 3L4 14h7v7l9-11h-7V3z"/></svg>',
        pitch: '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>',
        loop: '<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>',
        close: '<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>',
        lock: '<svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>',
        unlock: '<svg viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H8.9V6z"/></svg>',
        mic: '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>',
        speaker: '<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>',
        cue: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
        tts: '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>',
        play: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
        pause: '<svg viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>',
        spacebar: '<svg viewBox="0 0 24 24"><path d="M4 9h16v2H4V9zm0 4h16v2H4v-2z"/></svg>',
        reverse: '<svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>'
      };
      return icons[type] || '';
    }

    let players = [];
    let voiceRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let voiceAudio = null;
    let voiceStream = null;
    let ttsVoices = [];
    let selectedVoice = null;
    let audioContext = null;
    let pitchShifters = {}; // Store pitch shifters for each track
    
    // Initialize AudioContext for sound effects
    function initAudioContext() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error('Error initializing AudioContext:', e);
        }
      }
      return audioContext;
    }
    
    // Create a pitch shifter using Web Audio API
    function createPitchShifter(audioContext, semitones) {
      // Calculate pitch ratio (2^(semitones/12))
      const pitchRatio = Math.pow(2, semitones / 12);
      
      // Create nodes for pitch shifting
      const source = audioContext.createBufferSource();
      const gainNode = audioContext.createGain();
      
      // Use playbackRate to change pitch (but this also changes speed)
      // For true pitch shifting without speed change, we'd need SoundTouchJS
      // But since YouTube iframes have CORS, we'll use a workaround
      
      return {
        source: source,
        gainNode: gainNode,
        pitchRatio: pitchRatio,
        setPitch: function(newSemitones) {
          this.pitchRatio = Math.pow(2, newSemitones / 12);
          if (this.source) {
            this.source.playbackRate.value = this.pitchRatio;
          }
        },
        connect: function(destination) {
          this.source.connect(this.gainNode);
          this.gainNode.connect(destination);
        }
      };
    }
    
    // Apply pitch shift using Web Audio API workaround
    // Note: True pitch shifting without speed change requires audio buffer access
    // YouTube iframes prevent this, so we use playbackRate as a compromise
    function applyPitchShift(index, semitones) {
      // For YouTube videos, we can only use playbackRate
      // True pitch shifting requires direct audio access which YouTube blocks
      // This is a limitation of YouTube's iframe API
      
      const player = players[index];
      if (!player) return;
      
      // Calculate pitch multiplier
      const pitchMultiplier = Math.pow(2, semitones / 12);
      
      // Get current speed
      const speedSlider = document.getElementById(`speed${index}`);
      const currentSpeed = parseFloat(speedSlider.value) || 1.0;
      
      // Apply pitch by adjusting playback rate
      // This changes both pitch AND speed (YouTube API limitation)
      const newRate = currentSpeed * pitchMultiplier;
      const clampedRate = Math.max(0.25, Math.min(2.0, newRate));
      
      try {
        player.setPlaybackRate(clampedRate);
      } catch (e) {
        console.error('Error applying pitch:', e);
      }
    }
    
    // Sound effect functions
    function playTruckSound() {
      const ctx = initAudioContext();
      if (!ctx) return;
      
      const oscillator = ctx.createOscillator();
      const gainNode = ctx.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(ctx.destination);
      
      // Truck horn sound - low frequency with modulation
      oscillator.type = 'sawtooth';
      oscillator.frequency.setValueAtTime(80, ctx.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(60, ctx.currentTime + 0.3);
      oscillator.frequency.exponentialRampToValueAtTime(80, ctx.currentTime + 0.6);
      
      gainNode.gain.setValueAtTime(0, ctx.currentTime);
      gainNode.gain.linearRampToValueAtTime(0.5, ctx.currentTime + 0.1);
      gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
      
      oscillator.start(ctx.currentTime);
      oscillator.stop(ctx.currentTime + 0.7);
    }
    
    function playFireStationSound() {
      const ctx = initAudioContext();
      if (!ctx) return;
      
      // Fire station siren - alternating high/low tones
      for (let i = 0; i < 4; i++) {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        const startTime = ctx.currentTime + (i * 0.3);
        const freq = i % 2 === 0 ? 800 : 1200;
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(freq, startTime);
        
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.6, startTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, startTime + 0.25);
        
        oscillator.start(startTime);
        oscillator.stop(startTime + 0.3);
      }
    }
    
    function playBowBowBow() {
      const ctx = initAudioContext();
      if (!ctx) return;
      
      // BOW BOW BOW - deep bass hits
      for (let i = 0; i < 3; i++) {
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        const filter = ctx.createBiquadFilter();
        
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        const startTime = ctx.currentTime + (i * 0.2);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(40, startTime);
        oscillator.frequency.exponentialRampToValueAtTime(30, startTime + 0.15);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, startTime);
        
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(1.0, startTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.15);
        
        oscillator.start(startTime);
        oscillator.stop(startTime + 0.2);
      }
    }
    let ttsQueue = [];
    let isTTSPlaying = false;
    let videoData = [];
    let ytApiReady = false;
    let copilotActive = false;
    let copilotInterval = null;
    let beatDropActive = false;
    let beatDropInterval = null;
    let djVeeLocked = true; // Lock state for DJ VEEX20 (locked = no manual mixing, unlocked = allow manual mixing)
    let currentPlayingIndex = -1;
    let currentFocusedIndex = 0; // Track focused for spacebar control
    let trackHistory = [];
    let trackPlayCount = {};
    let spacebarFadeInterval = null;
    let lastMixTime = 0;
    let mixIntensity = 0.5; // 0 = calm, 1 = intense
    let autoPlayActive = true;
    let autoPlayInterval = null;
    let peopleModeActive = false; // People Mode: adjust rhythm based on energy
    let energyLevel = 0.5; // 0 = Low, 0.5 = Medium, 1 = High
    let energyHistory = []; // Track energy over time
    let readyPlayers = [];
    let userInteracted = false;
    let localVideos = ['bg.mp4', 'bg2.mp4', 'bg3.mp4'];
    let localVideoElements = [];
    let backgroundVideoStarted = false;
    
    // Detect mobile device
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
             (window.innerWidth <= 768);
    }
    let trackLoops = {}; // Track loop state for each player
    let loopIntervals = {}; // Store loop interval IDs
    let loopStartTimes = {}; // Store loop start times
    let trackReverse = {}; // Track reverse state for each player
    let reverseIntervals = {}; // Store reverse interval IDs
    let loopEndTimes = {}; // Store loop end times
    let loopPatterns = {}; // Store loop patterns for each player (e.g., "x xx xxx")
    let loopPatternIndex = {}; // Current position in pattern
    let loopSegmentLooped = {}; // Track if current segment has looped back
    let trackPitch = {}; // Track pitch offset for each player (in semitones)
    let trackGenres = {}; // Track genre for each player
    let genreProfiles = {}; // Genre-specific mixing profiles
    let trackEQ = {}; // Track EQ settings: {low: -12 to 12, mid: -12 to 12, high: -12 to 12}
    let cuePoints = {}; // Cue points for each track: {[index]: {1: time, 2: time, 3: time, 4: time, 5: time}}
    let trackBPM = {}; // Estimated BPM for each track

    // Check if running via file:// protocol (YouTube requires HTTP/HTTPS)
    if (window.location.protocol === 'file:') {
      console.warn('‚ö†Ô∏è File opened via file:// protocol. YouTube API works best over HTTP/HTTPS.');
      console.warn('üí° To fix: Use a local server like "python -m http.server" or "npx serve"');
      
      // Show user-friendly warning
      setTimeout(() => {
        const warning = document.createElement('div');
        warning.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ff6b6b; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
        warning.innerHTML = `
          <strong>‚ö†Ô∏è Protocol Warning</strong><br>
          <small>For best results, serve this file over HTTP/HTTPS.<br>
          Use: <code>python -m http.server</code> or <code>npx serve</code></small>
          <button onclick="this.parentElement.remove()" style="margin-top: 8px; padding: 4px 8px; background: white; color: #ff6b6b; border: none; border-radius: 4px; cursor: pointer;">Dismiss</button>
        `;
        document.body.appendChild(warning);
      }, 1000);
    }

    window.onYouTubeIframeAPIReady = function() {
      ytApiReady = true;
    }

    // Genre detection based on title, description, and keywords
    function detectGenre(item) {
      const title = (item.snippet.title || '').toLowerCase();
      const description = (item.snippet.description || '').toLowerCase();
      const channel = (item.snippet.channelTitle || '').toLowerCase();
      const text = title + ' ' + description + ' ' + channel;
      
      // Genre keywords with weights
      const genreKeywords = {
        'house': ['house', 'deep house', 'tech house', 'progressive house', 'future house', 'bass house'],
        'techno': ['techno', 'hard techno', 'minimal techno', 'acid techno', 'industrial techno'],
        'trance': ['trance', 'uplifting trance', 'progressive trance', 'psytrance', 'vocal trance'],
        'dubstep': ['dubstep', 'riddim', 'brostep', 'future bass', 'trap'],
        'drumandbass': ['drum and bass', 'dnb', 'jungle', 'liquid dnb', 'neurofunk'],
        'hiphop': ['hip hop', 'hiphop', 'rap', 'trap', 'drill', 'grime'],
        'edm': ['edm', 'electronic', 'big room', 'festival', 'drop', 'bass boosted', 'bass boost', 'remix', 'remixes', 'tomorrowland', 'ultra', 'david guetta', 'martin garrix', 'tiesto', 'avicii', 'axwell', 'meduza', 'gigi d\'agostino', 'dj mix', 'music mix'],
        'pop': ['pop', 'top 40', 'mainstream', 'radio'],
        'rock': ['rock', 'metal', 'punk', 'alternative', 'indie rock'],
        'reggae': ['reggae', 'dancehall', 'dub', 'ska'],
        'jazz': ['jazz', 'smooth jazz', 'bebop', 'fusion'],
        'classical': ['classical', 'orchestral', 'symphony', 'concerto'],
        'ambient': ['ambient', 'chill', 'lounge', 'downtempo'],
        'country': ['country', 'bluegrass', 'folk'],
        'r&b': ['r&b', 'rnb', 'soul', 'neo soul']
      };
      
      let genreScores = {};
      
      // Score each genre
      Object.keys(genreKeywords).forEach(genre => {
        genreScores[genre] = 0;
        genreKeywords[genre].forEach(keyword => {
          const regex = new RegExp(keyword, 'gi');
          const matches = text.match(regex);
          if (matches) {
            genreScores[genre] += matches.length;
          }
        });
      });
      
      // Find highest scoring genre
      let maxScore = 0;
      let detectedGenre = 'electronic'; // default
      
      Object.keys(genreScores).forEach(genre => {
        if (genreScores[genre] > maxScore) {
          maxScore = genreScores[genre];
          detectedGenre = genre;
        }
      });
      
      // If no strong match, use default
      if (maxScore === 0) {
        detectedGenre = 'electronic';
      }
      
      return detectedGenre;
    }

    // Genre-specific mixing profiles
    function initializeGenreProfiles() {
      genreProfiles = {
        'house': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.5,
          crossfadeDuration: 3000,
          mixingStyle: 'smooth',
          variations: ['longCrossfade', 'beatMatch', 'harmonicMix']
        },
        'techno': {
          tempo: { min: 0.98, max: 1.02, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 50, max: 80, preferred: 65 },
          loopChance: 0.7,
          crossfadeDuration: 4000,
          mixingStyle: 'seamless',
          variations: ['longCrossfade', 'beatMatch', 'layerBuild', 'minimalVariation']
        },
        'trance': {
          tempo: { min: 0.97, max: 1.03, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 40, max: 85, preferred: 70 },
          loopChance: 0.4,
          crossfadeDuration: 5000,
          mixingStyle: 'epic',
          variations: ['buildUp', 'drop', 'longCrossfade', 'pitchShift']
        },
        'dubstep': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -4, max: 4, preferred: 0 },
          volume: { min: 55, max: 90, preferred: 75 },
          loopChance: 0.3,
          crossfadeDuration: 2000,
          mixingStyle: 'aggressive',
          variations: ['quickCut', 'drop', 'pitchShift', 'volumeSpike']
        },
        'drumandbass': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 50, max: 80, preferred: 70 },
          loopChance: 0.6,
          crossfadeDuration: 2500,
          mixingStyle: 'energetic',
          variations: ['quickCut', 'beatMatch', 'layerBuild', 'tempoMatch']
        },
        'hiphop': {
          tempo: { min: 0.85, max: 1.15, preferred: 1.0 },
          pitch: { min: -6, max: 6, preferred: 0 },
          volume: { min: 45, max: 85, preferred: 65 },
          loopChance: 0.8,
          crossfadeDuration: 1500,
          mixingStyle: 'creative',
          variations: ['scratch', 'quickCut', 'pitchShift', 'loopMash']
        },
        'edm': {
          tempo: { min: 0.92, max: 1.08, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 50, max: 90, preferred: 75 },
          loopChance: 0.4,
          crossfadeDuration: 3000,
          mixingStyle: 'festival',
          variations: ['buildUp', 'drop', 'longCrossfade', 'volumeSpike']
        },
        'pop': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 40, max: 80, preferred: 60 },
          loopChance: 0.2,
          crossfadeDuration: 2000,
          mixingStyle: 'smooth',
          variations: ['smoothCrossfade', 'fadeOut', 'simpleTransition']
        },
        'rock': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 55, max: 90, preferred: 75 },
          loopChance: 0.1,
          crossfadeDuration: 2000,
          mixingStyle: 'powerful',
          variations: ['hardCut', 'volumeSpike', 'fadeOut']
        },
        'reggae': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 45, max: 70, preferred: 55 },
          loopChance: 0.6,
          crossfadeDuration: 4000,
          mixingStyle: 'laidback',
          variations: ['longCrossfade', 'smoothTransition', 'beatMatch']
        },
        'jazz': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 40, max: 70, preferred: 55 },
          loopChance: 0.3,
          crossfadeDuration: 5000,
          mixingStyle: 'smooth',
          variations: ['longCrossfade', 'harmonicMix', 'smoothTransition']
        },
        'classical': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 35, max: 65, preferred: 50 },
          loopChance: 0.1,
          crossfadeDuration: 6000,
          mixingStyle: 'elegant',
          variations: ['longCrossfade', 'fadeOut', 'smoothTransition']
        },
        'ambient': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 30, max: 60, preferred: 45 },
          loopChance: 0.9,
          crossfadeDuration: 8000,
          mixingStyle: 'atmospheric',
          variations: ['longCrossfade', 'layerBuild', 'smoothTransition']
        },
        'country': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.2,
          crossfadeDuration: 2500,
          mixingStyle: 'natural',
          variations: ['smoothCrossfade', 'fadeOut', 'simpleTransition']
        },
        'r&b': {
          tempo: { min: 0.92, max: 1.08, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.5,
          crossfadeDuration: 3000,
          mixingStyle: 'smooth',
          variations: ['smoothCrossfade', 'harmonicMix', 'beatMatch']
        },
        'electronic': { // Default fallback
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.4,
          crossfadeDuration: 3000,
          mixingStyle: 'balanced',
          variations: ['smoothCrossfade', 'beatMatch', 'harmonicMix']
        }
      };
    }

    // Initialize genre profiles on load
    initializeGenreProfiles();

    let primaryVideoIndex = -1; // Track which video is in the primary panel

    function displayResults(data) {
      const tracksPanel = document.getElementById('tracksPanel');
      const primaryPanel = document.getElementById('primaryPanel');
      const primaryVideoCard = document.getElementById('primaryVideoCard');
      const emptyState = document.getElementById('emptyState');
      
      if (!tracksPanel) {
        // Fallback if new structure doesn't exist
        const tracksPanel = document.getElementById('tracksPanel');
        if (tracksPanel) tracksPanel.innerHTML = '';
        return;
      }
      
      if (tracksPanel) tracksPanel.innerHTML = '';
      if (primaryVideoCard) primaryVideoCard.style.display = 'none';
      if (emptyState) emptyState.style.display = 'flex';
      primaryVideoIndex = -1;

      // Ensure background videos are stopped when showing search results
      stopBackgroundVideos();

      if (!data.items || data.items.length === 0) {
        if (tracksPanel) {
          tracksPanel.innerHTML = '<div class="empty-state"><p>No results found. Try a different search term.</p></div>';
        }
        const copilotBtn = document.getElementById('copilotButton');
        if (copilotBtn) copilotBtn.style.display = 'none';
        return;
      }

      const limitedItems = data.items.slice(0, 4);
      videoData = limitedItems;
      
      // Clean up all loops before resetting players
      Object.keys(loopIntervals).forEach(index => {
        stopLoop(parseInt(index));
      });
      
      players = [];
      trackLoops = {};
      loopIntervals = {};
      loopStartTimes = {};
      loopEndTimes = {};
      loopPatterns = {};
      loopPatternIndex = {};
      loopSegmentLooped = {};
      trackPitch = {};
      trackGenres = {};
      
      // Detect genres for all tracks
      limitedItems.forEach((item, index) => {
        trackGenres[index] = detectGenre(item);
      });

      if (!ytApiReady && typeof YT === 'undefined') {
        if (tracksPanel) tracksPanel.innerHTML = '<div class="loading">Loading...</div>';
        setTimeout(() => displayResults(data), 500);
        return;
      }

      limitedItems.forEach((item, index) => {
        // Create small track card for left panel
        const trackCard = document.createElement('div');
        trackCard.className = 'track-card-small';
        trackCard.id = `trackCard${index}`;
        trackCard.dataset.index = index;
        
        // Thumbnail
        const thumbnail = document.createElement('div');
        thumbnail.className = 'track-thumbnail';
        const thumbDiv = document.createElement('div');
        thumbDiv.id = `thumb${index}`;
        thumbnail.appendChild(thumbDiv);
        
        // Track info
        const trackInfo = document.createElement('div');
        trackInfo.className = 'track-info-small';
        const detectedGenre = trackGenres[index] || 'electronic';
        trackInfo.innerHTML = `
          <div class="track-title-small">${item.snippet.title}</div>
          <div class="track-channel-small">${item.snippet.channelTitle}</div>
        `;
        
        // Move to primary button
        const moveBtn = document.createElement('button');
        moveBtn.className = 'move-to-primary-btn';
        moveBtn.textContent = '‚Üí';
        moveBtn.title = 'Make primary';
        moveBtn.onclick = (e) => {
          e.stopPropagation();
          makePrimary(index);
        };
        
        trackCard.appendChild(thumbnail);
        trackCard.appendChild(trackInfo);
        trackCard.appendChild(moveBtn);
        
        // Click to make primary
        trackCard.onclick = () => makePrimary(index);
        
        tracksPanel.appendChild(trackCard);
        
        // Initialize track state
        trackEQ[index] = { low: 0, mid: 0, high: 0 };
        cuePoints[index] = {};
        trackBPM[index] = 120;
        
        // Create player div - don't hide it, YouTube needs it visible to create iframe
        const videoDiv = document.createElement('div');
        videoDiv.id = `player${index}`;
        videoDiv.style.position = 'absolute';
        videoDiv.style.left = '-9999px';
        videoDiv.style.width = '160px';
        videoDiv.style.height = '90px';
        document.body.appendChild(videoDiv);
          
          // Verify videoId exists
          const videoId = item.id?.videoId || item.id;
          if (!videoId) {
            console.error('No video ID found for item:', item);
            return;
          }
          
        // Function to create player (for thumbnail)
          const createPlayer = () => {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
              setTimeout(createPlayer, 200);
              return;
            }
            
            try {
            // Create small thumbnail player - use larger size for better visibility
              players[index] = new YT.Player(videoDiv.id, {
              height: '90',
              width: '160',
                videoId: videoId,
                playerVars: {
                  modestbranding: 1,
                  rel: 0,
                  showinfo: 0,
                  playsinline: 1,
                  enablejsapi: 1,
                  controls: 0,
                  autoplay: 0
                },
                events: {
                  'onReady': function(event) {
                    event.target.setVolume(50);
                    readyPlayers.push(index);
                    
                    // Move iframe to thumbnail - YouTube creates iframe asynchronously, so we need to wait
                    // Try multiple times with increasing delays
                    const moveIframeToThumbnail = (attempt = 0) => {
                      const iframe = videoDiv.querySelector('iframe');
                      if (iframe) {
                        const thumbDiv = document.getElementById(`thumb${index}`);
                        if (thumbDiv) {
                          // Clear any existing content
                          thumbDiv.innerHTML = '';
                          thumbDiv.appendChild(iframe);
                          iframe.style.width = '100%';
                          iframe.style.height = '100%';
                          iframe.style.border = 'none';
                          iframe.style.display = 'block';
                          return true;
                        } else {
                          console.warn(`Thumbnail div thumb${index} not found`);
                        }
                      } else if (attempt < 10) {
                        // Retry up to 10 times with increasing delays
                        setTimeout(() => moveIframeToThumbnail(attempt + 1), 100 * (attempt + 1));
                      } else {
                        console.warn(`Iframe not found for player${index} after ${attempt} attempts`);
                      }
                      return false;
                    };
                    
                    // Start trying to move iframe
                    setTimeout(() => moveIframeToThumbnail(0), 100);
                    
                    // If this is the primary video, move iframe to primary panel
                    if (primaryVideoIndex === index) {
                      setTimeout(() => {
                        const primaryVideoWrapper = document.getElementById('primaryVideoWrapper');
                        const iframe = document.querySelector(`#thumb${index} iframe`) || document.querySelector(`#player${index} iframe`);
                        if (iframe && primaryVideoWrapper) {
                          primaryVideoWrapper.innerHTML = '';
                          primaryVideoWrapper.appendChild(iframe);
                          iframe.style.width = '100%';
                          iframe.style.height = '100%';
                          iframe.style.minHeight = '400px';
                          iframe.style.border = 'none';
                          iframe.style.display = 'block';
                          iframe.style.position = 'absolute';
                          iframe.style.top = '0';
                          iframe.style.left = '0';
                          if (!primaryVideoWrapper.style.height || primaryVideoWrapper.style.height === '0px') {
                            primaryVideoWrapper.style.height = '500px';
                          }
                          // Resize player for larger display
                          try {
                            if (event.target && event.target.setSize) {
                              event.target.setSize(window.innerWidth * 0.6, 500);
                            }
                          } catch (e) {
                            console.warn('Could not resize player:', e);
                          }
                        }
                        setupPrimaryControls(index);
                      }, 200);
                    }
                  },
                  'onStateChange': function(event) {
                    updatePlayButton(index, event.data);
                    
                    // Start loop if enabled and track is playing
                    if (event.data === YT.PlayerState.PLAYING) {
                      if (trackLoops[index]) {
                        // Small delay to ensure video is ready
                        setTimeout(() => startLoop(index), 500);
                      }
                    } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                      stopLoop(index);
                    }
                    
                    // Auto-advance to next video when current ends
                    if (autoPlayActive && !userInteracted && event.data === YT.PlayerState.ENDED) {
                      autoAdvanceToNext(index);
                    }
                  },
                  'onError': function(event) {
                    const errorCode = event.data;
                    console.error('YouTube player error:', errorCode);
                    
                    // YouTube error codes:
                    // 2 = Invalid parameter value
                    // 5 = HTML5 player error
                    // 100 = Video not found
                    // 101 = Not allowed to play in embedded players
                    // 150 = Not allowed to play in embedded players
                    // 153 = Not allowed to play in embedded players (specific format)
                    
                    let errorMessage = 'Video unavailable';
                    if (errorCode === 100 || errorCode === 101 || errorCode === 150 || errorCode === 153) {
                      errorMessage = 'Video cannot be embedded';
                    } else if (errorCode === 2) {
                      errorMessage = 'Invalid video';
                    } else if (errorCode === 5) {
                      errorMessage = 'Playback error';
                    }
                    
                    // Show error message on card
                    const videoInfo = videoCard.querySelector('.video-info');
                    if (videoInfo) {
                      const errorDiv = document.createElement('div');
                      errorDiv.style.cssText = 'color: #ff6b6b; font-size: 11px; margin-top: 4px; padding: 4px; background: rgba(255, 107, 107, 0.1); border-radius: 4px;';
                      errorDiv.textContent = errorMessage;
                      videoInfo.appendChild(errorDiv);
                    }
                    
                    videoCard.style.opacity = '0.6';
                    videoCard.style.pointerEvents = 'none';
                    
                    // Disable controls
                    const playButton = document.getElementById(`playBtn${index}`);
                    if (playButton) playButton.disabled = true;
                    const volumeSlider = document.getElementById(`volume${index}`);
                    if (volumeSlider) volumeSlider.disabled = true;
                    const speedSlider = document.getElementById(`speed${index}`);
                    if (speedSlider) speedSlider.disabled = true;
                    const pitchSlider = document.getElementById(`pitch${index}`);
                    if (pitchSlider) pitchSlider.disabled = true;
                    const loopCheckbox = document.getElementById(`loop${index}`);
                    if (loopCheckbox) loopCheckbox.disabled = true;
                    const loopPatternInput = document.getElementById(`loopPattern${index}`);
                    if (loopPatternInput) loopPatternInput.disabled = true;
                  }
                }
              });
            } catch (error) {
              console.error('Error creating YouTube player:', error);
            }
          };
          
          // Start creating player
          createPlayer();
      });

      if (limitedItems.length > 0) {
        const copilotBtn = document.getElementById('copilotButton');
        if (copilotBtn) copilotBtn.style.display = 'block';
        const playAllBtn = document.getElementById('playAllButton');
        if (playAllBtn) playAllBtn.style.display = 'block';
        const shiftBtn = document.getElementById('shiftButton');
        if (shiftBtn) shiftBtn.style.display = 'block';
        const beatDropBtn = document.getElementById('beatDropButton');
        if (beatDropBtn) beatDropBtn.style.display = 'block';
        const voiceButton = document.getElementById('voiceButton');
        if (voiceButton) voiceButton.style.display = 'block';
        const addMoreSection = document.getElementById('addMoreSection');
        if (addMoreSection) addMoreSection.style.display = 'block';
        const ttsSection = document.getElementById('ttsSection');
        if (ttsSection) ttsSection.style.display = 'block';
        const soundEffectsSection = document.getElementById('soundEffectsSection');
        if (soundEffectsSection) soundEffectsSection.style.display = 'block';
      }
      
      // Reset auto-play state
      readyPlayers = [];
      userInteracted = false;
      autoPlayActive = true;
    }

    function startAutoPlaySequence() {
      if (!autoPlayActive || userInteracted || readyPlayers.length === 0) return;
      
      // Wait for fade-in animation to complete, then start playing
      const animationDelay = readyPlayers.length * 100 + 300; // Wait for all cards to fade in
      setTimeout(() => {
        if (autoPlayActive && !userInteracted) {
          const firstIndex = readyPlayers[0];
          // Check if using local videos or YouTube
          if (localVideoElements.length > 0) {
            playLocalVideoAuto(firstIndex);
      } else {
            playVideoAuto(firstIndex);
          }
        }
      }, animationDelay);
    }

    function playVideoAuto(index) {
      if (!autoPlayActive || userInteracted) return;
      
      const player = players[index];
      if (!player) return;
      
      // Allow multiple videos to play together - don't stop other videos
      // Fade in volume for smooth start
      player.setVolume(0);
      player.playVideo();
      
      // Fade in volume over 1 second
      let volumeStep = 0;
      const fadeInterval = setInterval(() => {
        volumeStep += 2;
        if (volumeStep <= 50) {
          player.setVolume(volumeStep);
        } else {
          clearInterval(fadeInterval);
          player.setVolume(50);
        }
      }, 40);
      
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      
      if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
      }
      if (videoCard) {
        videoCard.classList.add('playing');
      }
      
      currentPlayingIndex = index;
    }

    function autoAdvanceToNext(currentIndex) {
      if (!autoPlayActive || userInteracted) return;
      
      // Find next video in sequence
      const currentPos = readyPlayers.indexOf(currentIndex);
      const nextPos = (currentPos + 1) % readyPlayers.length;
      const nextIndex = readyPlayers[nextPos];
      
      // Small delay before next video starts
      setTimeout(() => {
        if (autoPlayActive && !userInteracted) {
          // Check if using local videos or YouTube
          if (localVideoElements.length > 0) {
            playLocalVideoAuto(nextIndex);
          } else {
            playVideoAuto(nextIndex);
          }
        }
      }, 1000);
    }

    function setupControls(index) {
      const player = players[index];
      if (!player) return;

      // Initialize loop state
      trackLoops[index] = false;
      trackPitch[index] = 0;
      trackReverse[index] = false;
      loopPatterns[index] = ''; // Default: no pattern (use default loop)
      loopPatternIndex[index] = 0;
      loopSegmentLooped[index] = false;

      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      
      volumeSlider.addEventListener('input', function() {
        if (!this.disabled) {
          // User interaction - stop auto-play
          if (autoPlayActive && !userInteracted) {
            userInteracted = true;
            autoPlayActive = false;
          }
          
          const volume = parseInt(this.value);
          player.setVolume(volume);
          volumeValue.textContent = volume + '%';
        }
      });

      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      speedSlider.addEventListener('input', function() {
        if (!this.disabled) {
          // User interaction - stop auto-play
          if (autoPlayActive && !userInteracted) {
            userInteracted = true;
            autoPlayActive = false;
          }
          
          const speed = parseFloat(this.value);
          // Apply pitch adjustment if any
          const pitchMultiplier = Math.pow(2, trackPitch[index] / 12);
          player.setPlaybackRate(speed * pitchMultiplier);
          speedValue.textContent = speed.toFixed(2) + 'x';
        }
      });

      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      
      if (pitchSlider && pitchValue) {
        pitchSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            const pitchSemitones = parseInt(this.value);
            const oldPitch = trackPitch[index] || 0;
            
            // Update stored pitch value
            trackPitch[index] = pitchSemitones;
            
            // Get current speed from slider (user's desired speed)
            let userSpeed = parseFloat(speedSlider.value) || 1.0;
            
            // IMPORTANT LIMITATION: YouTube iframe API does NOT support independent pitch control
            // The setPlaybackRate() method changes BOTH speed AND pitch together
            // True pitch-only shifting requires:
            // 1. Direct audio stream access (blocked by YouTube CORS)
            // 2. Web Audio API with audio buffer (not available from iframes)
            // 3. Libraries like SoundTouchJS (require audio buffer access)
            
            // WORKAROUND: We compensate speed to minimize tempo change when pitch changes
            // This is the best we can do with YouTube's API limitations
            
            // Calculate pitch multiplier (2^(semitones/12))
            const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
            
            // Smart compensation: When pitch changes, adjust speed inversely to maintain tempo
            // Formula: compensatedSpeed = userSpeed / pitchMultiplier
            // This keeps the perceived tempo closer to the original
            const compensatedSpeed = userSpeed / pitchMultiplier;
            
            // Clamp compensated speed to reasonable range (0.6x to 1.4x)
            const clampedCompensatedSpeed = Math.max(0.6, Math.min(1.4, compensatedSpeed));
            
            // Calculate final playback rate (compensated speed * pitch multiplier)
            // This should result in approximately: userSpeed (maintaining tempo)
            let finalPlaybackRate = clampedCompensatedSpeed * pitchMultiplier;
            
            // Final safety check - keep in YouTube's supported range
            if (finalPlaybackRate < 0.5) {
              finalPlaybackRate = 0.5;
              const adjustedSpeed = 0.5 / pitchMultiplier;
              speedSlider.value = Math.max(0.6, Math.min(1.4, adjustedSpeed));
              speedValue.textContent = speedSlider.value.toFixed(2) + 'x';
            } else if (finalPlaybackRate > 1.5) {
              finalPlaybackRate = 1.5;
              const adjustedSpeed = 1.5 / pitchMultiplier;
              speedSlider.value = Math.max(0.6, Math.min(1.4, adjustedSpeed));
              speedValue.textContent = speedSlider.value.toFixed(2) + 'x';
            }
            
            // Clamp to YouTube's supported range (0.25 to 2.0)
            const clampedRate = Math.max(0.25, Math.min(2.0, finalPlaybackRate));
            
            // Apply the new playback rate to the player
            // NOTE: YouTube API limitation - this changes both pitch AND speed
            // We've compensated speed to minimize tempo change
            try {
              if (player && typeof player.setPlaybackRate === 'function') {
                player.setPlaybackRate(clampedRate);
                console.log(`Pitch: ${pitchSemitones} semitones | Speed: ${clampedCompensatedSpeed.toFixed(2)}x | Rate: ${clampedRate.toFixed(2)}x`);
              }
            } catch (e) {
              console.error('Error setting playback rate for pitch:', e);
            }
            
            // Display pitch
            if (pitchSemitones === 0) {
              pitchValue.textContent = '0';
            } else if (pitchSemitones > 0) {
              pitchValue.textContent = '+' + pitchSemitones;
            } else {
              pitchValue.textContent = pitchSemitones.toString();
            }
            
            // Trigger algorithm to react IMMEDIATELY to the change
            if (copilotActive) {
              lastMixTime = Date.now() - 15000; // Make algorithm think it's been a while
              mixIntensity = Math.min(1, mixIntensity + 0.3); // Increase intensity significantly
              // Force immediate algorithm run
              setTimeout(() => {
                if (copilotActive) {
                  djAlgorithm();
                }
              }, 100);
            }
          }
        });
      }

      const loopCheckbox = document.getElementById(`loop${index}`);
      if (loopCheckbox) {
        loopCheckbox.addEventListener('change', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            trackLoops[index] = this.checked;
            if (this.checked) {
              // Only start loop if video is currently playing
              const player = players[index];
              if (player) {
                try {
                  const state = player.getPlayerState();
                  if (state === YT.PlayerState.PLAYING) {
              startLoop(index);
                  }
                  // If not playing, loop will start automatically when video plays (handled in onStateChange)
                } catch (e) {
                  console.error('Error checking player state:', e);
                }
              }
            } else {
              stopLoop(index);
            }
          }
        });
      }

      const loopPatternInput = document.getElementById(`loopPattern${index}`);
      if (loopPatternInput) {
        loopPatternInput.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            const pattern = this.value.trim();
            loopPatterns[index] = pattern;
            loopPatternIndex[index] = 0; // Reset pattern position
            loopSegmentLooped[index] = false; // Reset loop tracking
            
            // If loop is active, restart with new pattern
            if (trackLoops[index]) {
              stopLoop(index);
              setTimeout(() => startLoop(index), 100);
            }
          }
        });
      }

      // Setup EQ controls
      const eqLow = document.getElementById(`eqLow${index}`);
      const eqMid = document.getElementById(`eqMid${index}`);
      const eqHigh = document.getElementById(`eqHigh${index}`);
      const eqLowValue = document.getElementById(`eqLowValue${index}`);
      const eqMidValue = document.getElementById(`eqMidValue${index}`);
      const eqHighValue = document.getElementById(`eqHighValue${index}`);

      if (eqLow && eqLowValue) {
        eqLow.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            if (!trackEQ[index]) {
              trackEQ[index] = { low: 0, mid: 0, high: 0 };
            }
            trackEQ[index].low = value;
            eqLowValue.textContent = value > 0 ? '+' + value : value;
            // Note: YouTube API doesn't support real-time EQ, but values are stored for reference
            // EQ controls help you visualize frequency adjustments for professional mixing
          }
        });
      }

      if (eqMid && eqMidValue) {
        eqMid.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            if (!trackEQ[index]) {
              trackEQ[index] = { low: 0, mid: 0, high: 0 };
            }
            trackEQ[index].mid = value;
            eqMidValue.textContent = value > 0 ? '+' + value : value;
          }
        });
      }

      if (eqHigh && eqHighValue) {
        eqHigh.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            if (!trackEQ[index]) {
              trackEQ[index] = { low: 0, mid: 0, high: 0 };
            }
            trackEQ[index].high = value;
            eqHighValue.textContent = value > 0 ? '+' + value : value;
          }
        });
      }
    }

    function togglePlay(index) {
      // Allow manual play when DJ VEEX20 is active but unlocked (JAM mode)
      if (copilotActive && djVeeLocked) return; // Don't allow manual play when copilot is active and locked
      
      // User has interacted - stop auto-play
      if (autoPlayActive && !userInteracted) {
        userInteracted = true;
        autoPlayActive = false;
      }
      
      const player = players[index];
      if (!player) {
        console.warn(`Player ${index} not found. Players available:`, Object.keys(players));
        return;
      }

      // Check if player is ready
      try {
        if (typeof player.getPlayerState !== 'function') {
          console.warn(`Player ${index} not ready yet`);
          return;
        }
      } catch (e) {
        console.warn(`Player ${index} error:`, e);
        return;
      }

      // Allow multiple tracks to play together - don't stop other tracks
      let state;
      try {
        state = player.getPlayerState();
      } catch (e) {
        console.error(`Error getting player state for ${index}:`, e);
        return;
      }
      // Check both primary and regular play buttons
      const playButton = document.getElementById(`primaryPlayBtn${index}`) || document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      const trackCard = document.getElementById(`trackCard${index}`);
      
      if (state === YT.PlayerState.PLAYING) {
        try {
        player.pauseVideo();
        } catch (e) {
          console.error(`Error pausing video ${index}:`, e);
          return;
        }
        stopLoop(index);
        stopReverse(index);
        if (playButton) {
        playButton.innerHTML = getSVGIcon('play');
        playButton.classList.remove('playing');
        }
        if (videoCard) videoCard.classList.remove('playing');
        if (trackCard) trackCard.classList.remove('playing');
        if (currentPlayingIndex === index) {
        currentPlayingIndex = -1;
        }
      } else {
        // Stop reverse if active
        if (trackReverse[index]) {
          stopReverse(index);
        }
        try {
        player.playVideo();
        } catch (e) {
          console.error(`Error playing video ${index}:`, e);
          return;
        }
        if (trackLoops[index]) {
          setTimeout(() => startLoop(index), 500);
        }
        if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
        }
        if (videoCard) videoCard.classList.add('playing');
        if (trackCard) trackCard.classList.add('playing');
        currentPlayingIndex = index;
      }
    }
    
    // Toggle reverse playback
    function toggleReverse(index) {
      const player = players[index];
      if (!player) return;
      
      // Stop normal playback if active
      const state = player.getPlayerState();
      if (state === YT.PlayerState.PLAYING && !trackReverse[index]) {
        player.pauseVideo();
        const playButton = document.getElementById(`playBtn${index}`);
        if (playButton) {
          playButton.innerHTML = getSVGIcon('play');
          playButton.classList.remove('playing');
        }
      }
      
      // Stop loop if active
      if (trackLoops[index]) {
        stopLoop(index);
      }
      
      if (trackReverse[index]) {
        // Stop reverse
        stopReverse(index);
      } else {
        // Start reverse
        startReverse(index);
      }
    }
    
    // Start reverse playback
    function startReverse(index) {
      const player = players[index];
      if (!player) return;
      
      // Stop any existing reverse
      if (reverseIntervals[index]) {
        clearInterval(reverseIntervals[index]);
      }
      
      trackReverse[index] = true;
      const reverseButton = document.getElementById(`reverseBtn${index}`);
      if (reverseButton) {
        reverseButton.classList.add('active');
        reverseButton.style.background = 'rgba(255, 0, 0, 0.3)';
      }
      
      // Set very slow playback rate for reverse effect
      player.setPlaybackRate(0.25); // Slowest possible
      player.playVideo();
      
      // Seek backwards continuously to simulate reverse
      const reverseInterval = setInterval(() => {
        if (!trackReverse[index] || !player) {
          clearInterval(reverseInterval);
          return;
        }
        
        try {
          const currentTime = player.getCurrentTime();
          if (currentTime > 0.1) {
            // Seek backwards by 0.1 seconds
            player.seekTo(Math.max(0, currentTime - 0.1), true);
          } else {
            // Reached beginning, stop reverse
            stopReverse(index);
          }
        } catch (e) {
          console.error('Error in reverse playback:', e);
          stopReverse(index);
        }
      }, 100); // Update every 100ms for smooth reverse
      
      reverseIntervals[index] = reverseInterval;
      
      // Update UI
      const videoCard = document.getElementById(`card${index}`);
      if (videoCard) {
        videoCard.classList.add('playing');
      }
    }
    
    // Stop reverse playback
    function stopReverse(index) {
      trackReverse[index] = false;
      
      if (reverseIntervals[index]) {
        clearInterval(reverseIntervals[index]);
        reverseIntervals[index] = null;
      }
      
      const player = players[index];
      if (player) {
        player.pauseVideo();
        // Reset playback rate
        const speedSlider = document.getElementById(`speed${index}`);
        if (speedSlider) {
          const speed = parseFloat(speedSlider.value) || 1.0;
          const pitchMultiplier = Math.pow(2, (trackPitch[index] || 0) / 12);
          player.setPlaybackRate(speed * pitchMultiplier);
        }
      }
      
      const reverseButton = document.getElementById(`reverseBtn${index}`);
      if (reverseButton) {
        reverseButton.classList.remove('active');
        reverseButton.style.background = 'rgba(255, 255, 255, 0.1)';
      }
      
      const playButton = document.getElementById(`playBtn${index}`);
      if (playButton) {
        playButton.innerHTML = getSVGIcon('play');
        playButton.classList.remove('playing');
      }
      
      const videoCard = document.getElementById(`card${index}`);
      if (videoCard) {
        videoCard.classList.remove('playing');
      }
    }
    
    // Play all tracks together
    function playAllTracks() {
      players.forEach((player, index) => {
        if (player) {
          const state = player.getPlayerState();
          if (state !== YT.PlayerState.PLAYING) {
            player.playVideo();
            const playButton = document.getElementById(`playBtn${index}`);
            const videoCard = document.getElementById(`card${index}`);
            if (playButton) {
              playButton.innerHTML = getSVGIcon('pause');
              playButton.classList.add('playing');
            }
            if (videoCard) {
              videoCard.classList.add('playing');
            }
            if (trackLoops[index]) {
              setTimeout(() => startLoop(index), 500);
            }
          }
        }
      });
    }
    
    // Shift to next track (fade out current, fade in next)
    function shiftToNext() {
      const playingTracks = [];
      players.forEach((player, index) => {
        if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
          playingTracks.push(index);
        }
      });
      
      if (playingTracks.length === 0) {
        // No tracks playing, start first one
        if (players.length > 0) {
          togglePlay(0);
        }
        return;
      }
      
      // Find next track to play
      const currentIndex = playingTracks[0];
      let nextIndex = (currentIndex + 1) % players.length;
      
      // Fade out current track
      const currentPlayer = players[currentIndex];
      if (currentPlayer) {
        let volume = currentPlayer.getVolume();
        const fadeOut = setInterval(() => {
          volume = Math.max(0, volume - 5);
          currentPlayer.setVolume(volume);
          if (volume <= 0) {
            clearInterval(fadeOut);
            currentPlayer.pauseVideo();
            const playButton = document.getElementById(`playBtn${currentIndex}`);
            const videoCard = document.getElementById(`card${currentIndex}`);
            if (playButton) {
              playButton.innerHTML = getSVGIcon('play');
              playButton.classList.remove('playing');
            }
            if (videoCard) {
              videoCard.classList.remove('playing');
            }
            
            // Fade in next track
            const nextPlayer = players[nextIndex];
            if (nextPlayer) {
              nextPlayer.setVolume(0);
              nextPlayer.playVideo();
              let nextVolume = 0;
              const fadeIn = setInterval(() => {
                nextVolume = Math.min(50, nextVolume + 5);
                nextPlayer.setVolume(nextVolume);
                if (nextVolume >= 50) {
                  clearInterval(fadeIn);
                  const nextPlayButton = document.getElementById(`playBtn${nextIndex}`);
                  const nextVideoCard = document.getElementById(`card${nextIndex}`);
                  if (nextPlayButton) {
                    nextPlayButton.innerHTML = getSVGIcon('pause');
                    nextPlayButton.classList.add('playing');
                  }
                  if (nextVideoCard) {
                    nextVideoCard.classList.add('playing');
                  }
                  currentPlayingIndex = nextIndex;
                }
              }, 50);
            }
          }
        }, 50);
      }
    }

    function updatePlayButton(index, state) {
      const playButton = document.getElementById(`playBtn${index}`);
      const primaryPlayButton = document.getElementById(`primaryPlayBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      const trackCard = document.getElementById(`trackCard${index}`);

      if (state === YT.PlayerState.PLAYING) {
        if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
        }
        if (primaryPlayButton) {
          primaryPlayButton.innerHTML = getSVGIcon('pause');
          primaryPlayButton.classList.add('playing');
        }
        if (videoCard) videoCard.classList.add('playing');
        if (trackCard) trackCard.classList.add('playing');
        currentPlayingIndex = index;
      } else {
        if (playButton) {
        playButton.innerHTML = getSVGIcon('play');
        playButton.classList.remove('playing');
        }
        if (primaryPlayButton) {
          primaryPlayButton.innerHTML = getSVGIcon('play');
          primaryPlayButton.classList.remove('playing');
        }
        if (currentPlayingIndex === index) {
          if (videoCard) videoCard.classList.remove('playing');
          if (trackCard) trackCard.classList.remove('playing');
          currentPlayingIndex = -1;
        }
      }
    }

    // Calculate energy level based on current tracks
    function calculateEnergyLevel() {
      if (!peopleModeActive) return 0.5; // Default medium if not active
      
      let totalEnergy = 0;
      let trackCount = 0;
      
      players.forEach((player, index) => {
        if (player) {
          const state = player.getPlayerState();
          if (state === YT.PlayerState.PLAYING) {
            const volume = player.getVolume() / 100; // 0-1
            const speed = player.getPlaybackRate(); // 0.25-2.0
            const genre = trackGenres[index] || 'electronic';
            
            // Energy factors:
            // 1. Volume (higher = more energy)
            // 2. Speed (faster = more energy)
            // 3. Genre (some genres are more energetic)
            const genreEnergy = {
              'dubstep': 0.9, 'drumandbass': 0.9, 'edm': 0.8,
              'house': 0.7, 'techno': 0.7, 'trance': 0.7,
              'hiphop': 0.6, 'pop': 0.6, 'rock': 0.7,
              'metal': 0.8, 'reggae': 0.5, 'jazz': 0.4,
              'ambient': 0.3, 'classical': 0.3
            }[genre] || 0.5;
            
            const trackEnergy = (volume * 0.4) + ((speed - 0.25) / 1.75 * 0.3) + (genreEnergy * 0.3);
            totalEnergy += trackEnergy;
            trackCount++;
          }
        }
      });
      
      if (trackCount === 0) return 0.5;
      
      const avgEnergy = totalEnergy / trackCount;
      
      // Smooth energy transitions (prevent sudden jumps)
      energyHistory.push(avgEnergy);
      if (energyHistory.length > 10) {
        energyHistory.shift(); // Keep last 10 readings
      }
      
      // Average over history for smoother transitions
      const smoothedEnergy = energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length;
      
      return Math.max(0, Math.min(1, smoothedEnergy));
    }
    
    // Update energy level display
    function updateEnergyDisplay() {
      const energyLevelElement = document.getElementById('energyLevel');
      if (!energyLevelElement) return;
      
      if (!peopleModeActive) {
        energyLevelElement.textContent = '‚ö° Off';
        energyLevelElement.style.opacity = '0.5';
        return;
      }
      
      let levelText = '';
      let emoji = '‚ö°';
      
      if (energyLevel < 0.33) {
        levelText = 'Low';
        emoji = 'üò¥';
      } else if (energyLevel < 0.67) {
        levelText = 'Medium';
        emoji = '‚ö°';
      } else {
        levelText = 'High';
        emoji = 'üî•';
      }
      
      energyLevelElement.textContent = `${emoji} ${levelText}`;
      energyLevelElement.style.opacity = '1';
    }

    function djAlgorithm() {
      if (players.length < 2) return;

      const now = Date.now();
      const timeSinceLastMix = now - lastMixTime;
      
      // Calculate energy level if People Mode is active
      if (peopleModeActive) {
        energyLevel = calculateEnergyLevel();
        updateEnergyDisplay();
        
        // Adjust mix intensity based on energy level
        // High energy = faster, more aggressive mixing
        // Low energy = slower, smoother mixing
        const energyBasedIntensity = energyLevel * 0.7 + 0.3; // Range: 0.3 to 1.0
        mixIntensity = energyBasedIntensity;
      } else {
        // Normal intensity adjustment
        if (timeSinceLastMix > 8000) {
          mixIntensity = Math.min(1, mixIntensity + 0.15); // Faster increase
        } else if (timeSinceLastMix < 3000) {
          mixIntensity = Math.max(0.3, mixIntensity - 0.15); // Faster decrease
        }
      }

      const playingTracks = [];
      const trackStates = [];
      
      // Check YouTube players
      players.forEach((player, index) => {
        if (player) {
          try {
          const state = player.getPlayerState();
          if (state === YT.PlayerState.PLAYING) {
            playingTracks.push(index);
            trackStates.push({
              index: index,
              volume: player.getVolume(),
              speed: player.getPlaybackRate(),
                playTime: now,
                type: 'youtube'
            });
            }
          } catch (e) {
            // Player might not be ready
            }
          }
        });

      // Check local video players
      Object.keys(localVideoPlayers).forEach(index => {
        const video = localVideoPlayers[index];
        if (video && !video.paused && !video.ended) {
          playingTracks.push(parseInt(index));
          trackStates.push({
            index: parseInt(index),
            volume: video.volume * 100,
            speed: video.playbackRate,
            playTime: now,
            type: 'local'
          });
        }
      });

      // Improved decision making for reliable mixing
      const trackCount = playingTracks.length;
      
      if (trackCount === 0) {
        // No tracks playing - start next track
        const nextIndex = selectNextTrack();
        if (nextIndex >= 0 && players[nextIndex]) {
        startTrackWithDJMix(nextIndex);
        }
      } else if (trackCount === 1) {
        const currentIndex = playingTracks[0];
        const currentGenre = trackGenres[currentIndex] || 'electronic';
        const player = players[currentIndex];
        
        if (player) {
          try {
            const currentTime = player.getCurrentTime();
            const duration = player.getDuration();
            
            // Only mix if track has been playing for a reasonable time
            // and we haven't mixed recently
            if (timeSinceLastMix > 10000 && currentTime > 10 && duration > 0) {
              // Check if we're past 60% of the track or 30 seconds, whichever is less
              const shouldMix = currentTime > Math.min(30, duration * 0.6);
              
              if (shouldMix) {
          const nextIndex = selectNextTrack([currentIndex], currentGenre);
                if (nextIndex >= 0 && players[nextIndex]) {
          crossfadeTracks(currentIndex, nextIndex, mixIntensity);
                }
        } else {
                // Just balance the current track
                adjustMixAdvanced(trackStates);
              }
          } else {
              // Not time to mix yet, just balance
              adjustMixAdvanced(trackStates);
            }
          } catch (e) {
            // If we can't get current time, wait longer before mixing
            if (timeSinceLastMix > 15000) {
              const nextIndex = selectNextTrack([currentIndex], currentGenre);
              if (nextIndex >= 0 && players[nextIndex]) {
                crossfadeTracks(currentIndex, nextIndex, mixIntensity);
              }
            }
          }
        }
      } else if (trackCount === 2) {
        // Two tracks playing - balance them
          adjustMixAdvanced(trackStates);
        } else {
        // Multiple tracks - remove one and balance
          const toRemove = selectTrackToRemove(trackStates);
        if (toRemove >= 0) {
          fadeOutTrack(toRemove);
        }
      }
      
      lastMixTime = now;
    }

    function selectNextTrack(excludeIndices = [], currentGenre = null) {
      // Smart track selection - avoid recently played, consider genre compatibility
      const available = players.map((_, i) => i).filter(i => !excludeIndices.includes(i));
      
      // Genre compatibility groups
      const compatibleGenres = [
        ['house', 'techno', 'trance', 'edm'],
        ['dubstep', 'drumandbass', 'edm'],
        ['hiphop', 'r&b', 'pop'],
        ['rock', 'metal'],
        ['jazz', 'ambient', 'classical'],
        ['reggae', 'dancehall'],
        ['country', 'folk']
      ];
      
      // Prefer tracks that haven't been played recently and are genre-compatible
      const scored = available.map(index => {
        const playCount = trackPlayCount[index] || 0;
        const lastPlayed = trackHistory.filter(h => h.index === index);
        const timeSincePlay = lastPlayed.length > 0 ? Date.now() - lastPlayed[lastPlayed.length - 1].time : Infinity;
        
        const trackGenre = trackGenres[index] || 'electronic';
        
        // Genre compatibility bonus
        let genreBonus = 0;
        if (currentGenre) {
          const isSameGenre = trackGenre === currentGenre;
          const isCompatible = compatibleGenres.some(group => 
            group.includes(currentGenre) && group.includes(trackGenre)
          );
          
          if (isSameGenre) {
            genreBonus = -5; // Prefer same genre
          } else if (isCompatible) {
            genreBonus = -2; // Prefer compatible genres
          } else {
            genreBonus = 3; // Slight penalty for incompatible genres (but still allow variety)
          }
        }
        
        // Lower score = better (less played, longer ago, genre-compatible)
        const score = playCount * 10 - (timeSincePlay / 1000) + genreBonus;
        return { index, score, genre: trackGenre };
      });
      
      // Sort by score and pick from top 3 (adds more randomness while maintaining quality)
      scored.sort((a, b) => a.score - b.score);
      const topTracks = scored.slice(0, Math.min(3, scored.length));
      const selected = topTracks[Math.floor(Math.random() * topTracks.length)];
      
      return selected ? selected.index : available[Math.floor(Math.random() * available.length)];
    }

    function selectTrackToRemove(trackStates) {
      // Remove track with lowest volume or longest playing
      trackStates.sort((a, b) => {
        if (Math.abs(a.volume - b.volume) > 10) {
          return a.volume - b.volume; // Lower volume first
        }
        return b.playTime - a.playTime; // Longer playing first
      });
      return trackStates[0].index;
    }

    function startTrackWithDJMix(index) {
      const player = players[index];
      if (!player) return;

      // Get genre profile
      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      // Genre-based volume
      const volumeRange = profile.volume.max - profile.volume.min;
      const baseVolume = profile.volume.preferred + (mixIntensity - 0.5) * volumeRange * 0.5;
      const initialVolume = Math.max(profile.volume.min, Math.min(profile.volume.max, 
        baseVolume + (Math.random() - 0.5) * volumeRange * 0.3));
      
      // Genre-based speed/tempo
      const tempoRange = profile.tempo.max - profile.tempo.min;
      const initialSpeed = profile.tempo.preferred + (Math.random() - 0.5) * tempoRange;
      
      // Genre-based pitch
      const pitchRange = profile.pitch.max - profile.pitch.min;
      const initialPitch = profile.pitch.preferred + Math.floor((Math.random() - 0.5) * pitchRange);
      trackPitch[index] = initialPitch;
      
      // Apply pitch to speed
      const pitchMultiplier = Math.pow(2, initialPitch / 12);
      const finalSpeed = initialSpeed * pitchMultiplier;
      
      player.setVolume(0);
      player.setPlaybackRate(finalSpeed);
      
      // Update UI
      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      
      if (speedSlider) speedSlider.value = initialSpeed;
      if (speedValue) speedValue.textContent = initialSpeed.toFixed(2) + 'x';
      if (pitchSlider) pitchSlider.value = initialPitch;
      if (pitchValue) {
        if (initialPitch === 0) {
          pitchValue.textContent = '0';
        } else if (initialPitch > 0) {
          pitchValue.textContent = '+' + initialPitch;
        } else {
          pitchValue.textContent = initialPitch.toString();
        }
      }
      
      // Genre-appropriate fade in
      const fadeStyle = profile.mixingStyle === 'aggressive' ? 'quick' : 
                       profile.mixingStyle === 'atmospheric' ? 'slow' : 'normal';
      fadeInTrackAdvanced(index, initialVolume, fadeStyle);
      
      updateTrackUI(index, initialVolume, initialSpeed);
      
      player.playVideo();
      currentPlayingIndex = index;
      
      // Play TTS between tracks if queue has items, or auto-generate
      if (!isTTSPlaying) {
        let ttsText = null;
        if (ttsQueue.length > 0) {
          ttsText = ttsQueue.shift();
        } else if (Math.random() < 0.3) {
          // 30% chance to auto-generate TTS phrase
          ttsText = generateAutoTTSPhrase('trackStart');
        }
        
        if (ttsText) {
          // Play TTS after a short delay - LOUD and MELODIOUS
          setTimeout(() => {
            speakText(ttsText, { 
              volume: 1.0,  // MAXIMUM volume - LOUD
              rate: 0.85,   // Slower for heavier, more powerful effect
              pitch: 0.7    // LOWER pitch (0.7) for HEAVY, deep DJ voice
            });
          }, 2000);
        }
      }
      
      // Genre-based loop chance
      if (Math.random() < profile.loopChance) {
        trackLoops[index] = true;
        const loopCheckbox = document.getElementById(`loop${index}`);
        if (loopCheckbox) {
          loopCheckbox.checked = true;
        }
        // Set loop points after video starts
        setTimeout(() => {
          try {
            const duration = player.getDuration();
            const currentTime = player.getCurrentTime();
            const loopStart = Math.max(0, currentTime);
            // Genre-appropriate loop length
            const loopLength = genre === 'ambient' ? 60 + Math.random() * 40 :
                               genre === 'techno' ? 32 + Math.random() * 16 :
                               genre === 'hiphop' ? 16 + Math.random() * 16 :
                               30 + Math.random() * 20;
            const loopEnd = Math.min(duration, currentTime + loopLength);
            setLoopPoints(index, loopStart, loopEnd);
          } catch (e) {
            console.error('Error setting loop points:', e);
          }
        }, 2000);
      }
      
      // Track history
      trackHistory.push({ index, time: Date.now(), genre });
      trackPlayCount[index] = (trackPlayCount[index] || 0) + 1;
    }

    function crossfadeTracks(fromIndex, toIndex, intensity = 0.5) {
      const fromPlayer = players[fromIndex];
      const toPlayer = players[toIndex];
      if (!fromPlayer || !toPlayer) return;

      // Get genre profiles
      const fromGenre = trackGenres[fromIndex] || 'electronic';
      const toGenre = trackGenres[toIndex] || 'electronic';
      const fromProfile = genreProfiles[fromGenre] || genreProfiles['electronic'];
      const toProfile = genreProfiles[toGenre] || genreProfiles['electronic'];
      
      // Enhanced beat matching - calculate BPM difference and adjust
      const fromBPM = trackBPM[fromIndex] || 120;
      const toBPM = trackBPM[toIndex] || 120;
      const bpmRatio = fromBPM / toBPM;
      
      // Genre-aware fade duration with professional DJ curve
      // People Mode: High energy = faster transitions, Low energy = slower transitions
      let baseFadeDuration = (fromProfile.crossfadeDuration + toProfile.crossfadeDuration) / 2;
      
      if (peopleModeActive) {
        // Energy-based duration: High energy (1.0) = 50% faster, Low energy (0.0) = 50% slower
        const energyMultiplier = 0.5 + (energyLevel * 0.5); // Range: 0.5 to 1.0
        baseFadeDuration = baseFadeDuration * energyMultiplier;
      }
      
      const fadeDuration = baseFadeDuration + (1 - intensity) * (baseFadeDuration * 0.5);
      const steps = 50; // More steps for smoother transition
      const stepDuration = fadeDuration / steps;
      let step = 0;

      const fromVolume = fromPlayer.getVolume();
      
      // Genre-based target volume with professional mixing
      const toVolumeRange = toProfile.volume.max - toProfile.volume.min;
      const baseVolume = toProfile.volume.preferred + (intensity - 0.5) * toVolumeRange * 0.5;
      const targetVolume = Math.max(toProfile.volume.min, Math.min(toProfile.volume.max,
        baseVolume + (Math.random() - 0.5) * toVolumeRange * 0.3));
      
      // Enhanced beat matching with BPM synchronization
      const fromSpeed = fromPlayer.getPlaybackRate();
      const fromPitch = trackPitch[fromIndex] || 0;
      
      // Professional beat matching: adjust speed to match BPMs (harmonic mixing)
      const genresMatch = fromGenre === toGenre;
      let pitchVariation;
      if (genresMatch) {
        // Same genre: stay close to current pitch for smooth harmonic transition
        pitchVariation = fromPitch + Math.floor((Math.random() - 0.5) * 2);
      } else {
        // Different genres: can vary more but still consider compatibility
        const compatibleGenres = [
          ['house', 'techno', 'trance'],
          ['dubstep', 'drumandbass', 'edm'],
          ['hiphop', 'r&b', 'pop'],
          ['rock', 'metal'],
          ['jazz', 'ambient', 'classical']
        ];
        const isCompatible = compatibleGenres.some(group => 
          group.includes(fromGenre) && group.includes(toGenre)
        );
        if (isCompatible) {
          pitchVariation = fromPitch + Math.floor((Math.random() - 0.5) * 4);
        } else {
          pitchVariation = toProfile.pitch.preferred + Math.floor((Math.random() - 0.5) * toProfile.pitch.max - toProfile.pitch.min);
        }
      }
      
      const targetPitch = Math.max(toProfile.pitch.min, Math.min(toProfile.pitch.max, pitchVariation));
      trackPitch[toIndex] = targetPitch;
      
      // Professional beat matching: combine BPM ratio with genre-based tempo
      const toTempoRange = toProfile.tempo.max - toProfile.tempo.min;
      let baseTargetSpeed;
      if (genresMatch) {
        // Same genre: match tempo closely with BPM consideration
        baseTargetSpeed = fromSpeed * (0.7 + 0.3 * bpmRatio); // Blend current speed with BPM match
      } else {
        // Different genre: use genre's preferred tempo adjusted for BPM
        const preferredSpeed = toProfile.tempo.preferred + (Math.random() - 0.5) * toTempoRange;
        baseTargetSpeed = preferredSpeed * bpmRatio;
      }
      const clampedSpeed = Math.max(toProfile.tempo.min, Math.min(toProfile.tempo.max, baseTargetSpeed));
      const pitchMultiplier = Math.pow(2, targetPitch / 12);
      const finalSpeed = clampedSpeed * pitchMultiplier;
      
      toPlayer.setVolume(0);
      toPlayer.setPlaybackRate(finalSpeed);
      toPlayer.playVideo();
      
      // Update UI
      const speedSlider = document.getElementById(`speed${toIndex}`);
      const speedValue = document.getElementById(`speedValue${toIndex}`);
      const pitchSlider = document.getElementById(`pitch${toIndex}`);
      const pitchValue = document.getElementById(`pitchValue${toIndex}`);
      
      if (speedSlider) speedSlider.value = clampedSpeed;
      if (speedValue) speedValue.textContent = clampedSpeed.toFixed(2) + 'x';
      if (pitchSlider) pitchSlider.value = targetPitch;
      if (pitchValue) {
        if (targetPitch === 0) {
          pitchValue.textContent = '0';
        } else if (targetPitch > 0) {
          pitchValue.textContent = '+' + targetPitch;
        } else {
          pitchValue.textContent = targetPitch.toString();
        }
      }
      
      updateTrackUI(toIndex, targetVolume, clampedSpeed);
      
      // Genre-based loop chance
      if (Math.random() < toProfile.loopChance) {
        trackLoops[toIndex] = true;
        const loopCheckbox = document.getElementById(`loop${toIndex}`);
        if (loopCheckbox) {
          loopCheckbox.checked = true;
        }
        setTimeout(() => {
          try {
            const duration = toPlayer.getDuration();
            const currentTime = toPlayer.getCurrentTime();
            const loopStart = Math.max(0, currentTime);
            // Genre-appropriate loop length
            const loopLength = toGenre === 'ambient' ? 60 + Math.random() * 40 :
                               toGenre === 'techno' ? 32 + Math.random() * 16 :
                               toGenre === 'hiphop' ? 16 + Math.random() * 16 :
                               25 + Math.random() * 15;
            const loopEnd = Math.min(duration, currentTime + loopLength);
            setLoopPoints(toIndex, loopStart, loopEnd);
          } catch (e) {
            console.error('Error setting loop points:', e);
          }
        }, 2000);
      }

      // Professional DJ crossfade with S-curve (professional mixing curve)
      const fadeInterval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Professional S-curve easing for smooth DJ transitions
        // This creates a more natural fade that DJs use
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress * (3 - 2 * progress) // Smooth acceleration
          : 1 - 2 * (1 - progress) * (1 - progress) * (3 - 2 * (1 - progress)); // Smooth deceleration
        
        // Fade out old track
        const fromNewVolume = fromVolume * (1 - easeProgress);
        fromPlayer.setVolume(Math.max(0, fromNewVolume));
        
        // Fade in new track
        const toNewVolume = targetVolume * easeProgress;
        toPlayer.setVolume(toNewVolume);
        
        if (step >= steps) {
          clearInterval(fadeInterval);
          fromPlayer.pauseVideo();
          toPlayer.setVolume(targetVolume);
          currentPlayingIndex = toIndex;
          
          // Play TTS between tracks if queue has items, or auto-generate
          if (!isTTSPlaying) {
            let ttsText = null;
            if (ttsQueue.length > 0) {
              ttsText = ttsQueue.shift();
            } else if (Math.random() < 0.25) {
              // 25% chance to auto-generate TTS phrase during transition
              const fromGenre = trackGenres[fromIndex] || 'electronic';
              const toGenre = trackGenres[toIndex] || 'electronic';
              const context = fromGenre !== toGenre ? 'genreChange' : 'trackTransition';
              ttsText = generateAutoTTSPhrase(context);
            }
            
            if (ttsText) {
              // Play TTS during transition - LOUD and MELODIOUS
              setTimeout(() => {
                speakText(ttsText, { 
                  volume: 1.0,  // MAXIMUM volume - LOUD
                  rate: 0.92,   // Slower for more melodic, musical effect
                  pitch: 1.2    // Higher pitch (1.2) for energetic, melodious DJ voice
                });
              }, 1000);
            }
          }
          
          // Track history
          trackHistory.push({ index: toIndex, time: Date.now(), genre: toGenre });
          trackPlayCount[toIndex] = (trackPlayCount[toIndex] || 0) + 1;
        }
      }, stepDuration);
    }

    function enhanceTrackAdvanced(index, trackState) {
      const player = players[index];
      if (!player) return;

      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const currentVolume = trackState.volume;
      const currentSpeed = trackState.speed;
      const currentPitch = trackPitch[index] || 0;
      
      // Genre-aware volume adjustments
      const volumeRange = profile.volume.max - profile.volume.min;
      const volumeDirection = currentVolume < profile.volume.preferred ? 1 : 
                            (currentVolume > profile.volume.preferred ? -1 : (Math.random() > 0.5 ? 1 : -1));
      const volumeChange = (3 + mixIntensity * 8) * volumeDirection;
      const newVolume = Math.max(profile.volume.min, Math.min(profile.volume.max, currentVolume + volumeChange));
      
      // Genre-aware speed adjustments - pull towards genre preferred tempo
      const speedBias = profile.tempo.preferred - currentSpeed;
      const speedChange = speedBias * 0.03 + (Math.random() - 0.5) * (profile.tempo.max - profile.tempo.min) * 0.1;
      const newSpeed = Math.max(profile.tempo.min, Math.min(profile.tempo.max, currentSpeed + speedChange));
      
      // Genre-aware pitch adjustments
      const pitchChange = Math.random() < 0.3 ? Math.floor((Math.random() - 0.5) * (profile.pitch.max - profile.pitch.min) * 0.3) : 0;
      const newPitch = Math.max(profile.pitch.min, Math.min(profile.pitch.max, currentPitch + pitchChange));
      trackPitch[index] = newPitch;
      
      // Apply pitch to speed
      const pitchMultiplier = Math.pow(2, newPitch / 12);
      const finalSpeed = newSpeed * pitchMultiplier;
      
      // Genre-appropriate transition speed
      const transitionDuration = profile.mixingStyle === 'aggressive' ? 300 : 
                                profile.mixingStyle === 'atmospheric' ? 800 : 500;
      
      // Smooth transition
      animateVolumeChange(index, currentVolume, newVolume, transitionDuration);
      animateSpeedChangeWithPitch(index, currentSpeed, newSpeed, currentPitch, newPitch, transitionDuration);
      
      // Update pitch UI
      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      if (pitchSlider) pitchSlider.value = newPitch;
      if (pitchValue) {
        if (newPitch === 0) {
          pitchValue.textContent = '0';
        } else if (newPitch > 0) {
          pitchValue.textContent = '+' + newPitch;
        } else {
          pitchValue.textContent = newPitch.toString();
        }
      }
    }

    function createBuildUp(index) {
      const player = players[index];
      if (!player) return;

      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const currentVolume = player.getVolume();
      const currentSpeed = player.getPlaybackRate();
      
      // Genre-appropriate build-up intensity
      const buildIntensity = profile.mixingStyle === 'epic' ? 20 : 
                            profile.mixingStyle === 'aggressive' ? 25 : 15;
      const targetVolume = Math.min(profile.volume.max, currentVolume + buildIntensity);
      const targetSpeed = Math.min(profile.tempo.max, currentSpeed + 0.05);
      
      const buildDuration = profile.mixingStyle === 'epic' ? 3000 : 2000;
      animateVolumeChange(index, currentVolume, targetVolume, buildDuration);
      animateSpeedChange(index, currentSpeed, targetSpeed, buildDuration);
      
      // Then drop back down after a moment
      setTimeout(() => {
        animateVolumeChange(index, targetVolume, currentVolume, buildDuration * 0.75);
        animateSpeedChange(index, targetSpeed, currentSpeed, buildDuration * 0.75);
      }, buildDuration + 1000);
    }

    function applyGenreVariation(index, variationType) {
      const player = players[index];
      if (!player) return;
      
      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      switch(variationType) {
        case 'pitchShift':
          // Dramatic pitch shift
          const currentPitch = trackPitch[index] || 0;
          const pitchShift = Math.floor((Math.random() - 0.5) * 8); // -4 to +4
          const newPitch = Math.max(profile.pitch.min, Math.min(profile.pitch.max, currentPitch + pitchShift));
          trackPitch[index] = newPitch;
          
          const currentSpeed = parseFloat(document.getElementById(`speed${index}`).value);
          const pitchMultiplier = Math.pow(2, newPitch / 12);
          player.setPlaybackRate(currentSpeed * pitchMultiplier);
          
          const pitchSlider = document.getElementById(`pitch${index}`);
          const pitchValue = document.getElementById(`pitchValue${index}`);
          if (pitchSlider) pitchSlider.value = newPitch;
          if (pitchValue) {
            pitchValue.textContent = newPitch === 0 ? '0' : (newPitch > 0 ? '+' + newPitch : newPitch.toString());
          }
          break;
          
        case 'volumeSpike':
          // Quick volume spike
          const currentVol = player.getVolume();
          const spikeVol = Math.min(95, currentVol + 20);
          animateVolumeChange(index, currentVol, spikeVol, 300);
          setTimeout(() => {
            animateVolumeChange(index, spikeVol, currentVol, 500);
          }, 500);
          break;
          
        case 'tempoMatch':
          // Match tempo to genre standard
          const targetTempo = profile.tempo.preferred;
          const currentTempo = parseFloat(document.getElementById(`speed${index}`).value);
          animateSpeedChange(index, currentTempo, targetTempo, 1000);
          break;
          
        case 'minimalVariation':
          // Very subtle changes (for techno/minimal)
          const vol = player.getVolume();
          const newVol = vol + (Math.random() - 0.5) * 5;
          animateVolumeChange(index, vol, Math.max(profile.volume.min, Math.min(profile.volume.max, newVol)), 2000);
          break;
          
        case 'loopMash':
          // Quick loop activation
          if (!trackLoops[index]) {
            trackLoops[index] = true;
            const loopCheckbox = document.getElementById(`loop${index}`);
            if (loopCheckbox) loopCheckbox.checked = true;
            startLoop(index);
          }
          break;
          
        default:
          enhanceTrackAdvanced(index, {
            volume: player.getVolume(),
            speed: player.getPlaybackRate(),
            playTime: Date.now()
          });
      }
    }

    function quickCutToNext(currentIndex) {
      const currentGenre = trackGenres[currentIndex] || 'electronic';
      const nextIndex = selectNextTrack([currentIndex], currentGenre);
      const currentPlayer = players[currentIndex];
      const nextPlayer = players[nextIndex];
      
      if (!currentPlayer || !nextPlayer) return;
      
      // Instant cut - no fade
      currentPlayer.pauseVideo();
      stopLoop(currentIndex);
      
      const genre = trackGenres[nextIndex] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const targetVolume = profile.volume.preferred + (Math.random() - 0.5) * 10;
      const targetSpeed = profile.tempo.preferred + (Math.random() - 0.5) * (profile.tempo.max - profile.tempo.min) * 0.3;
      
      nextPlayer.setVolume(targetVolume);
      nextPlayer.setPlaybackRate(targetSpeed);
      nextPlayer.playVideo();
      
      updateTrackUI(nextIndex, targetVolume, targetSpeed);
      currentPlayingIndex = nextIndex;
      
      trackHistory.push({ index: nextIndex, time: Date.now(), genre });
      trackPlayCount[nextIndex] = (trackPlayCount[nextIndex] || 0) + 1;
    }

    function layerTracks(mainIndex, layerIndex) {
      const mainPlayer = players[mainIndex];
      const layerPlayer = players[layerIndex];
      if (!mainPlayer || !layerPlayer) return;

      // Layer: play both tracks with main louder
      const mainVolume = mainPlayer.getVolume();
      const layerVolume = Math.min(40, mainVolume * 0.5);
      
      layerPlayer.setVolume(0);
      layerPlayer.setPlaybackRate(mainPlayer.getPlaybackRate()); // Match tempo
      layerPlayer.playVideo();
      
      fadeInTrackAdvanced(layerIndex, layerVolume);
      updateTrackUI(layerIndex, layerVolume, mainPlayer.getPlaybackRate());
    }

    function perfectBalance(trackStates) {
      // Balance two tracks perfectly
      const avgVolume = trackStates.reduce((sum, t) => sum + t.volume, 0) / trackStates.length;
      const targetVolume = Math.min(70, Math.max(40, avgVolume));
      
      trackStates.forEach(state => {
        animateVolumeChange(state.index, state.volume, targetVolume, 1000);
      });
    }

    function adjustMixAdvanced(trackStates) {
      // Advanced mixing with better balance
      const totalVolume = trackStates.reduce((sum, t) => sum + t.volume, 0);
      const avgVolume = totalVolume / trackStates.length;
      const targetVolume = Math.min(75, Math.max(35, avgVolume));
      
      trackStates.forEach((state, i) => {
        // Vary volumes slightly but keep balanced
        const variation = (Math.random() - 0.5) * 10;
        const newVolume = Math.max(30, Math.min(80, targetVolume + variation));
        
        // Slight tempo adjustments
        const speedAdjust = (Math.random() - 0.5) * 0.06;
        const newSpeed = Math.max(0.85, Math.min(1.15, state.speed + speedAdjust));
        
        // Slight pitch adjustments for harmonic mixing
        const currentPitch = trackPitch[state.index] || 0;
        const pitchAdjust = Math.random() < 0.2 ? Math.floor((Math.random() - 0.5) * 3) : 0; // 20% chance
        const newPitch = Math.max(-12, Math.min(12, currentPitch + pitchAdjust));
        trackPitch[state.index] = newPitch;
        
        // Update pitch UI
        const pitchSlider = document.getElementById(`pitch${state.index}`);
        const pitchValue = document.getElementById(`pitchValue${state.index}`);
        if (pitchSlider) pitchSlider.value = newPitch;
        if (pitchValue) {
          if (newPitch === 0) {
            pitchValue.textContent = '0';
          } else if (newPitch > 0) {
            pitchValue.textContent = '+' + newPitch;
          } else {
            pitchValue.textContent = newPitch.toString();
          }
        }
        
        animateVolumeChange(state.index, state.volume, newVolume, 800);
        animateSpeedChange(state.index, state.speed, newSpeed, 800);
      });
    }

    function animateVolumeChange(index, from, to, duration) {
      const player = players[index];
      if (!player) return;

      const steps = 20;
      const stepSize = (to - from) / steps;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const currentVolume = from + (stepSize * step);
        player.setVolume(Math.max(0, Math.min(100, currentVolume)));
        
        if (step >= steps) {
          clearInterval(interval);
          player.setVolume(to);
          updateTrackUI(index, to, player.getPlaybackRate());
        }
      }, stepDuration);
    }

    function animateSpeedChange(index, from, to, duration) {
      const player = players[index];
      if (!player) return;

      const currentPitch = trackPitch[index] || 0;
      const pitchMultiplier = Math.pow(2, currentPitch / 12);

      const steps = 15;
      const stepSize = (to - from) / steps;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const currentSpeed = from + (stepSize * step);
        const finalSpeed = currentSpeed * pitchMultiplier;
        player.setPlaybackRate(Math.max(0.5, Math.min(2, finalSpeed)));
        
        if (step >= steps) {
          clearInterval(interval);
          player.setPlaybackRate(to * pitchMultiplier);
          updateTrackUI(index, player.getVolume(), to);
        }
      }, stepDuration);
    }

    function animateSpeedChangeWithPitch(index, fromSpeed, toSpeed, fromPitch, toPitch, duration) {
      const player = players[index];
      if (!player) return;

      const steps = 15;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Interpolate speed
        const currentSpeed = fromSpeed + (toSpeed - fromSpeed) * progress;
        
        // Interpolate pitch
        const currentPitch = fromPitch + (toPitch - fromPitch) * progress;
        trackPitch[index] = Math.round(currentPitch);
        
        // Apply pitch to speed
        const pitchMultiplier = Math.pow(2, currentPitch / 12);
        const finalSpeed = currentSpeed * pitchMultiplier;
        
        player.setPlaybackRate(Math.max(0.5, Math.min(2, finalSpeed)));
        
        if (step >= steps) {
          clearInterval(interval);
          const finalPitchMultiplier = Math.pow(2, toPitch / 12);
          player.setPlaybackRate(toSpeed * finalPitchMultiplier);
          trackPitch[index] = toPitch;
          updateTrackUI(index, player.getVolume(), toSpeed);
        }
      }, stepDuration);
    }

    function fadeInTrackAdvanced(index, targetVolume, style = 'normal') {
      const player = players[index];
      if (!player) return;

      let fadeSteps, stepDuration, easing;
      
      switch(style) {
        case 'quick':
          fadeSteps = 10;
          stepDuration = 50;
          easing = (p) => p; // Linear for quick
          break;
        case 'slow':
          fadeSteps = 40;
          stepDuration = 100;
          easing = (p) => 1 - Math.pow(1 - p, 4); // Very smooth
          break;
        default: // normal
          fadeSteps = 20;
          stepDuration = 80;
          easing = (p) => 1 - Math.pow(1 - p, 3); // Standard exponential
      }

      let step = 0;
      player.setVolume(0);
      player.playVideo();

      const fadeInterval = setInterval(() => {
        step++;
        const progress = step / fadeSteps;
        const easedProgress = easing(progress);
        player.setVolume(targetVolume * easedProgress);
        
        if (step >= fadeSteps) {
          clearInterval(fadeInterval);
          player.setVolume(targetVolume);
        }
      }, stepDuration);
    }

    function updateTrackUI(index, volume, speed) {
      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      if (volumeSlider) volumeSlider.value = volume;
      if (volumeValue) volumeValue.textContent = Math.round(volume) + '%';
      if (speedSlider) speedSlider.value = speed;
      if (speedValue) speedValue.textContent = speed.toFixed(2) + 'x';
    }

    // Parse loop pattern into segments (e.g., "x xx xxx" -> [1, 2, 3])
    function parseLoopPattern(pattern) {
      if (!pattern || !pattern.trim()) return null;
      
      const segments = pattern.trim().split(/\s+/).filter(s => s.length > 0);
      return segments.map(segment => {
        // Count 'x' characters (case insensitive, also count 'X')
        const xCount = (segment.match(/x/gi) || []).length;
        return xCount > 0 ? xCount : 1; // Default to 1 if no 'x' found
      });
    }

    function startLoop(index) {
      const player = players[index];
      if (!player || !trackLoops[index]) return;
      
      stopLoop(index); // Clear any existing loop
      
      // Wait for video to be ready before getting duration
      const initLoop = () => {
        try {
      const duration = player.getDuration();
          if (!duration || duration <= 0) {
            // Retry after a short delay if duration not available
            setTimeout(initLoop, 500);
            return;
          }
          
          const currentTime = player.getCurrentTime() || 0;
      
      // Check if pattern-based looping is enabled
      const pattern = loopPatterns[index] || '';
      const patternSegments = parseLoopPattern(pattern);
      
      if (patternSegments && patternSegments.length > 0) {
        // Pattern-based looping
            const segmentLengths = patternSegments;
        let currentSegmentIndex = loopPatternIndex[index] || 0;
        if (currentSegmentIndex >= segmentLengths.length) {
          currentSegmentIndex = 0;
          loopPatternIndex[index] = 0;
        }
        
        const segmentLength = segmentLengths[currentSegmentIndex];
        const startTime = Math.max(0, currentTime);
        const endTime = Math.min(duration, startTime + segmentLength);
        
        loopStartTimes[index] = startTime;
        loopEndTimes[index] = endTime;
            loopSegmentLooped[index] = false;
        
        const checkPatternLoop = () => {
          if (!trackLoops[index] || !player) return;
          
          try {
            const current = player.getCurrentTime();
            const currentStartTime = loopStartTimes[index];
            const currentEndTime = loopEndTimes[index];
            
            if (current >= currentEndTime - 0.3) {
              if (!loopSegmentLooped[index]) {
                player.seekTo(currentStartTime, true);
                loopSegmentLooped[index] = true;
              } else {
                let nextSegmentIndex = (currentSegmentIndex + 1) % segmentLengths.length;
                loopPatternIndex[index] = nextSegmentIndex;
                    loopSegmentLooped[index] = false;
                
                const newSegmentLength = segmentLengths[nextSegmentIndex];
                const newCurrentTime = player.getCurrentTime();
                const newStartTime = Math.max(0, newCurrentTime);
                const newEndTime = Math.min(duration, newStartTime + newSegmentLength);
                
                loopStartTimes[index] = newStartTime;
                loopEndTimes[index] = newEndTime;
              }
            }
          } catch (e) {
            console.error('Pattern loop check error:', e);
          }
        };
        
        loopIntervals[index] = setInterval(checkPatternLoop, 100);
      } else {
            // Default looping - loop entire track
      if (!loopStartTimes[index]) {
              loopStartTimes[index] = 0;
      }
      if (!loopEndTimes[index]) {
              loopEndTimes[index] = duration;
      }
      
      const startTime = loopStartTimes[index];
      const endTime = loopEndTimes[index];
      
      const checkLoop = () => {
        if (!trackLoops[index] || !player) return;
        
        try {
          const current = player.getCurrentTime();
            if (current >= endTime - 0.3 || current >= duration - 0.3) {
            player.seekTo(startTime, true);
          }
        } catch (e) {
          console.error('Loop check error:', e);
        }
      };
      
      loopIntervals[index] = setInterval(checkLoop, 100);
      }
        } catch (e) {
          console.error('Error initializing loop:', e);
          // Retry after delay
          setTimeout(initLoop, 500);
        }
      };
      
      initLoop();
    }

    function stopLoop(index) {
      if (loopIntervals[index]) {
        clearInterval(loopIntervals[index]);
        loopIntervals[index] = null;
      }
      loopStartTimes[index] = null;
      loopEndTimes[index] = null;
    }

    function setLoopPoints(index, startTime, endTime) {
      loopStartTimes[index] = startTime;
      loopEndTimes[index] = endTime;
      if (trackLoops[index]) {
        startLoop(index);
      }
    }

    function removeSong(index) {
      // Stop the player if playing
      if (players[index]) {
        try {
          players[index].pauseVideo();
          players[index].destroy();
        } catch (e) {
          console.error('Error destroying player:', e);
        }
      }
      
      // Stop any loops, reverse, and beat indicators
      stopLoop(index);
      stopReverse(index);
      
      // Remove the card from DOM with animation
      const card = document.getElementById(`card${index}`);
      if (card) {
        card.style.opacity = '0';
        card.style.transform = 'scale(0.8)';
        setTimeout(() => {
          card.remove();
        }, 300);
      }
      
      // Clean up arrays
      players[index] = null;
      if (videoData[index]) videoData[index] = null;
      trackLoops[index] = null;
      trackPitch[index] = null;
      trackReverse[index] = null;
      loopPatterns[index] = null;
      loopIntervals[index] = null;
      reverseIntervals[index] = null;
      loopStartTimes[index] = null;
      loopEndTimes[index] = null;
      trackGenres[index] = null;
      trackEQ[index] = null;
      cuePoints[index] = null;
      trackBPM[index] = null;
      
      // Update current playing index if needed
      if (currentPlayingIndex === index) {
        currentPlayingIndex = -1;
      }
    }

    function handleCueButton(index, cueNumber) {
      const player = players[index];
      if (!player) {
        console.log('No player for index:', index);
        alert('Player not ready. Please wait for the track to load.');
        return;
      }
      
      try {
        if (!cuePoints[index]) {
          cuePoints[index] = {};
        }
        
        // Check if cue point already exists
        if (cuePoints[index][cueNumber] !== undefined && cuePoints[index][cueNumber] !== null) {
          // Jump to existing cue point
          const cueTime = cuePoints[index][cueNumber];
          try {
            player.seekTo(cueTime, true);
            console.log(`Jumped to cue ${cueNumber} at ${cueTime.toFixed(2)}s`);
            
            // If player is paused, play it briefly to show the cue point
            const state = player.getPlayerState();
            if (state === YT.PlayerState.PAUSED || state === YT.PlayerState.UNSTARTED) {
              player.playVideo();
              setTimeout(() => {
                player.pauseVideo();
              }, 500);
            }
          } catch (seekError) {
            console.error('Error seeking to cue point:', seekError);
            alert('Could not jump to cue point. Please try again.');
          }
        } else {
          // Set new cue point at current position
          try {
            let currentTime = 0;
            try {
              currentTime = player.getCurrentTime();
              if (isNaN(currentTime) || currentTime < 0) {
                currentTime = 0;
              }
            } catch (timeError) {
              currentTime = 0;
            }
            
            cuePoints[index][cueNumber] = currentTime;
            console.log(`Cue ${cueNumber} set at ${currentTime.toFixed(2)}s for track ${index}`);
            
            // Update button to show it has a cue point
            const cueButton = document.getElementById(`cueBtn${index}_${cueNumber}`);
            if (cueButton) {
              cueButton.style.background = 'rgba(58, 134, 255, 0.3)';
              cueButton.style.borderColor = '#3a86ff';
              cueButton.title = `Jump to Cue ${cueNumber} (${currentTime.toFixed(1)}s)`;
            }
          } catch (setError) {
            console.error('Error setting cue point:', setError);
            alert('Could not set cue point. Please try again.');
          }
        }
        
        // Visual feedback
        const cueButton = document.getElementById(`cueBtn${index}_${cueNumber}`);
        if (cueButton) {
          cueButton.classList.add('active');
          setTimeout(() => {
            cueButton.classList.remove('active');
          }, 300);
        }
      } catch (e) {
        console.error('Error handling cue button:', e);
        alert('Error with cue button. Please try again.');
      }
    }

    function handleSpacebar() {
      // Find the current focused track or first available track
      let targetIndex = currentFocusedIndex;
      
      // If no focused track or track doesn't exist, find first available
      if (targetIndex < 0 || !players[targetIndex] || players.length === 0) {
        targetIndex = 0;
        if (players.length > 0 && currentPlayingIndex >= 0) {
          targetIndex = currentPlayingIndex;
        }
      }
      
      if (targetIndex < 0 || !players[targetIndex]) return;
      
      const player = players[targetIndex];
      const state = player.getPlayerState();
      const volumeSlider = document.getElementById(`volume${targetIndex}`);
      const playButton = document.getElementById(`playBtn${targetIndex}`);
      const videoCard = document.getElementById(`card${targetIndex}`);
      
      // Clear any existing fade
      if (spacebarFadeInterval) {
        clearInterval(spacebarFadeInterval);
        spacebarFadeInterval = null;
      }
      
      if (state === YT.PlayerState.PLAYING) {
        // Track is playing - fade volume down for mixing
        let currentVolume = parseInt(volumeSlider.value) || 50;
        const fadeDown = () => {
          if (currentVolume > 0) {
            currentVolume = Math.max(0, currentVolume - 5);
            volumeSlider.value = currentVolume;
            player.setVolume(currentVolume);
            const volumeValue = document.getElementById(`volumeValue${targetIndex}`);
            if (volumeValue) volumeValue.textContent = currentVolume;
          } else {
            clearInterval(spacebarFadeInterval);
            spacebarFadeInterval = null;
            player.pauseVideo();
            if (playButton) {
              playButton.innerHTML = getSVGIcon('play');
              playButton.classList.remove('playing');
            }
            if (videoCard) videoCard.classList.remove('playing');
            if (currentPlayingIndex === targetIndex) {
              currentPlayingIndex = -1;
            }
          }
        };
        spacebarFadeInterval = setInterval(fadeDown, 50);
      } else {
        // Track is paused - play and fade volume up
        player.playVideo();
        if (playButton) {
          playButton.innerHTML = getSVGIcon('pause');
          playButton.classList.add('playing');
        }
        if (videoCard) videoCard.classList.add('playing');
        currentPlayingIndex = targetIndex;
        currentFocusedIndex = targetIndex;
        // Start with low volume and fade up
        let currentVolume = 0;
        volumeSlider.value = 0;
        player.setVolume(0);
        const volumeValue = document.getElementById(`volumeValue${targetIndex}`);
        if (volumeValue) volumeValue.textContent = 0;
        
        const fadeUp = () => {
          if (currentVolume < 100) {
            currentVolume = Math.min(100, currentVolume + 5);
            volumeSlider.value = currentVolume;
            player.setVolume(currentVolume);
            if (volumeValue) volumeValue.textContent = currentVolume;
          } else {
            clearInterval(spacebarFadeInterval);
            spacebarFadeInterval = null;
          }
        };
        spacebarFadeInterval = setInterval(fadeUp, 50);
      }
      
      // Visual feedback
      const spacebarButton = document.getElementById('spacebarButton');
      if (spacebarButton) {
        spacebarButton.classList.add('active');
        setTimeout(() => {
          spacebarButton.classList.remove('active');
        }, 200);
      }
    }


    function fadeOutTrack(index) {
      const player = players[index];
      if (!player) return;

      // Stop loop when fading out
      stopLoop(index);

      const fadeSteps = 20;
      const currentVolume = player.getVolume();
      const stepSize = currentVolume / fadeSteps;
      let step = 0;

      const fadeInterval = setInterval(() => {
        step++;
        player.setVolume(Math.max(0, currentVolume - (stepSize * step)));
        
        if (step >= fadeSteps) {
          clearInterval(fadeInterval);
          player.pauseVideo();
          stopLoop(index); // Ensure loop is stopped
        }
      }, 100);
    }

    function adjustMix(playingTracks) {
      playingTracks.forEach(index => {
        const player = players[index];
        if (!player) return;

        const volumeAdjust = (Math.random() - 0.5) * 15;
        const speedAdjust = (Math.random() - 0.5) * 0.08;
        
        const currentVolume = player.getVolume();
        const newVolume = Math.max(30, Math.min(90, currentVolume + volumeAdjust));
        const currentSpeed = player.getPlaybackRate();
        const newSpeed = Math.max(0.75, Math.min(1.5, currentSpeed + speedAdjust));
        
        player.setVolume(newVolume);
        player.setPlaybackRate(newSpeed);
        
        document.getElementById(`volume${index}`).value = newVolume;
        document.getElementById(`volumeValue${index}`).textContent = Math.round(newVolume) + '%';
        document.getElementById(`speed${index}`).value = newSpeed;
        document.getElementById(`speedValue${index}`).textContent = newSpeed.toFixed(2) + 'x';
      });
    }


    function beatDropMix() {
      if (players.length < 2) return;
      
      // Find currently playing track
      const playingTracks = [];
      players.forEach((player, index) => {
        if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
          playingTracks.push(index);
        }
      });
      
      if (playingTracks.length === 0) {
        // No track playing, start first one
        if (players[0]) {
          players[0].playVideo();
          players[0].setVolume(70);
          return;
        }
      }
      
      // Get current playing track
      const currentIndex = playingTracks[0] || currentPlayingIndex;
      if (currentIndex === -1 || !players[currentIndex]) return;
      
      // Find next track to mix in
      const nextIndex = (currentIndex + 1) % players.length;
      const currentPlayer = players[currentIndex];
      const nextPlayer = players[nextIndex];
      
      if (!currentPlayer || !nextPlayer) return;
      
      // Get current track info
      const currentVolume = currentPlayer.getVolume();
      const currentSpeed = currentPlayer.getPlaybackRate();
      const currentPitch = trackPitch[currentIndex] || 0;
      
      // Prepare next track - match tempo and pitch for seamless transition
      const nextPitch = trackPitch[nextIndex] || 0;
      const pitchMultiplier = Math.pow(2, nextPitch / 12);
      nextPlayer.setPlaybackRate(currentSpeed * pitchMultiplier);
      nextPlayer.setVolume(0);
      
      // Update UI for next track
      const nextSpeedSlider = document.getElementById(`speed${nextIndex}`);
      const nextPitchSlider = document.getElementById(`pitch${nextIndex}`);
      if (nextSpeedSlider) nextSpeedSlider.value = currentSpeed;
      if (nextPitchSlider) nextPitchSlider.value = nextPitch;
      
      // Start next track
      nextPlayer.playVideo();
      
      // Seamless crossfade - smooth volume transition
      const fadeDuration = 2000; // 2 seconds for smooth transition
      const steps = 40;
      const stepDuration = fadeDuration / steps;
      let step = 0;
      
      const crossfadeInterval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Smooth easing curve
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Fade out current track
        const newCurrentVolume = currentVolume * (1 - easeProgress);
        currentPlayer.setVolume(Math.max(0, newCurrentVolume));
        
        // Fade in next track
        const newNextVolume = 70 * easeProgress;
        nextPlayer.setVolume(newNextVolume);
        
        if (step >= steps) {
          clearInterval(crossfadeInterval);
          // Complete the transition
          currentPlayer.pauseVideo();
          nextPlayer.setVolume(70);
          currentPlayingIndex = nextIndex;
          
          // Update play buttons
          const currentPlayBtn = document.getElementById(`playBtn${currentIndex}`);
          const nextPlayBtn = document.getElementById(`playBtn${nextIndex}`);
          if (currentPlayBtn) {
            currentPlayBtn.textContent = 'Play';
            currentPlayBtn.classList.remove('playing');
          }
          if (nextPlayBtn) {
            nextPlayBtn.textContent = 'Pause';
            nextPlayBtn.classList.add('playing');
          }
          
          // Update card states
          const currentCard = document.getElementById(`card${currentIndex}`);
          const nextCard = document.getElementById(`card${nextIndex}`);
          if (currentCard) currentCard.classList.remove('playing');
          if (nextCard) nextCard.classList.add('playing');
        }
      }, stepDuration);
    }

    function toggleBeatDropMix() {
      beatDropActive = !beatDropActive;
      const button = document.getElementById('beatDropButton');
      
      // Stop copilot if active
      if (copilotActive) {
        toggleCopilot();
      }
      
      if (beatDropActive) {
        button.classList.add('active');
        button.textContent = 'Stop Beat Drop';
        
        // Start beat drop mixing
        beatDropMix(); // Initial mix
        
        // Continue mixing every 8-12 seconds
        beatDropInterval = setInterval(() => {
          if (beatDropActive) {
            beatDropMix();
          }
        }, 8000 + Math.random() * 4000); // Random interval between 8-12 seconds
      } else {
        button.classList.remove('active');
        button.textContent = 'Beat Drop Mix';
        
        // Stop mixing
        if (beatDropInterval) {
          clearInterval(beatDropInterval);
          beatDropInterval = null;
        }
      }
    }

    function updateControlsForLockState() {
        players.forEach((player, index) => {
          const card = document.getElementById(`card${index}`);
          const playButton = document.getElementById(`playBtn${index}`);
          const volumeSlider = document.getElementById(`volume${index}`);
          const speedSlider = document.getElementById(`speed${index}`);
          const pitchSlider = document.getElementById(`pitch${index}`);
          const loopCheckbox = document.getElementById(`loop${index}`);
        const loopPatternInput = document.getElementById(`loopPattern${index}`);
        
        if (djVeeLocked) {
          // Locked: disable all manual controls
          if (card) card.classList.add('disabled');
          if (playButton) playButton.disabled = true;
          if (volumeSlider) volumeSlider.disabled = true;
          if (speedSlider) speedSlider.disabled = true;
          if (pitchSlider) pitchSlider.disabled = true;
          if (loopCheckbox) loopCheckbox.disabled = true;
          if (loopPatternInput) loopPatternInput.disabled = true;
        } else {
          // Unlocked: enable controls for manual mixing (JAM mode)
          if (card) card.classList.remove('disabled');
          if (playButton) playButton.disabled = false;
          if (volumeSlider) volumeSlider.disabled = false;
          if (speedSlider) speedSlider.disabled = false;
          if (pitchSlider) pitchSlider.disabled = false;
          if (loopCheckbox) loopCheckbox.disabled = false;
          if (loopPatternInput) loopPatternInput.disabled = false;
        }
      });
    }

    function toggleCopilot() {
      copilotActive = !copilotActive;
      const button = document.getElementById('copilotButton');
      const body = document.body;
      
      // Stop beat drop mix if active
      if (beatDropActive) {
        toggleBeatDropMix();
      }
      
      if (copilotActive) {
        button.classList.add('active');
        button.textContent = 'Stop DJ VEEX20';
        body.classList.add('copilot-active');
        
        // Show lock button
        const lockButton = document.getElementById('lockButton');
        if (lockButton) {
          lockButton.style.display = 'flex';
        }
        
        // Update controls based on lock state
        updateControlsForLockState();
        
        // Dynamic interval based on mix intensity
        // Calculate base interval - People Mode adjusts based on energy
        let baseInterval;
        if (peopleModeActive) {
          // Energy-based rhythm: High energy = faster (2-4s), Low energy = slower (5-8s)
          baseInterval = 5000 - (energyLevel * 3000); // 2-5 seconds based on energy
        } else {
          baseInterval = 3000 + (1 - mixIntensity) * 2000; // 3-5 seconds (faster reaction)
        }
        
        copilotInterval = setInterval(() => {
          djAlgorithm();
          // Adjust interval dynamically - People Mode uses energy, normal mode uses intensity
          if (copilotInterval) {
            clearInterval(copilotInterval);
            let newInterval;
            if (peopleModeActive) {
              newInterval = 5000 - (energyLevel * 3000) + Math.random() * 1000; // 2-6 seconds based on energy
            } else {
              newInterval = 3000 + (1 - mixIntensity) * 2000 + Math.random() * 1000; // 3-6 seconds
            }
            copilotInterval = setInterval(() => djAlgorithm(), newInterval);
          }
        }, baseInterval);
        setTimeout(() => djAlgorithm(), 500); // Start faster
      } else {
        button.classList.remove('active');
        button.textContent = 'DJ VEEX20';
        body.classList.remove('copilot-active');
        
        // Hide lock button
        const lockButton = document.getElementById('lockButton');
        if (lockButton) {
          lockButton.style.display = 'none';
        }
        
        // Reset lock state
        djVeeLocked = true;
        const lockIcon = document.getElementById('lockIcon');
        const lockText = document.getElementById('lockText');
        if (lockIcon) lockIcon.innerHTML = getSVGIcon('lock');
        if (lockText) lockText.textContent = 'Lock';
        if (lockButton) lockButton.classList.remove('unlocked');
        
        // Stop all loops when copilot is disabled
        players.forEach((player, index) => {
          stopLoop(index);
        });
        
        // Re-enable all controls
        players.forEach((player, index) => {
          const card = document.getElementById(`card${index}`);
          if (card) {
            card.classList.remove('disabled');
          }
          const playButton = document.getElementById(`playBtn${index}`);
          if (playButton) {
            playButton.disabled = false;
          }
          const volumeSlider = document.getElementById(`volume${index}`);
          if (volumeSlider) {
            volumeSlider.disabled = false;
          }
          const speedSlider = document.getElementById(`speed${index}`);
          if (speedSlider) {
            speedSlider.disabled = false;
          }
          const pitchSlider = document.getElementById(`pitch${index}`);
          if (pitchSlider) {
            pitchSlider.disabled = false;
          }
          const loopCheckbox = document.getElementById(`loop${index}`);
          if (loopCheckbox) {
            loopCheckbox.disabled = false;
          }
          const loopPatternInput = document.getElementById(`loopPattern${index}`);
          if (loopPatternInput) {
            loopPatternInput.disabled = false;
          }
        });
        
        if (copilotInterval) {
          clearInterval(copilotInterval);
          copilotInterval = null;
        }
      }
    }

    function stopBackgroundVideos() {
      localVideoElements.forEach((video, index) => {
        if (video) {
          video.pause();
          video.classList.remove('active');
          video.style.opacity = '0';
        }
      });
      const overlay = document.querySelector('.background-overlay');
      if (overlay) {
        overlay.classList.add('search-active');
      }
    }

    function resumeBackgroundVideos() {
      const overlay = document.querySelector('.background-overlay');
      if (overlay) {
        overlay.classList.remove('search-active');
      }
      // Don't auto-resume, let user control
    }

    function handleFormSubmit(event) {
      event.preventDefault();
      const searchQuery = document.getElementById('searchQuery').value.trim();
      
      if (!searchQuery) {
        return;
      }

      // Stop background videos when search is active
      stopBackgroundVideos();

      if (copilotActive) {
        toggleCopilot();
      }
      
      // Stop auto-play on new search
      autoPlayActive = false;
      userInteracted = false;

      // Reset track history on new search
      trackHistory = [];
      trackPlayCount = {};
      mixIntensity = 0.5;
      userInteracted = false;
      autoPlayActive = true;
      readyPlayers = [];

      const tracksPanel = document.getElementById('tracksPanel');
      if (tracksPanel) {
        tracksPanel.innerHTML = '<div class="loading">Searching...</div>';
      }

      const request = new XMLHttpRequest();
      const apiKey = 'AIzaSyAEzhGEyJJgZpoN6ahBTvnZyr4g5FV5s9s';
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=4&q=${encodeURIComponent(searchQuery)}&key=${apiKey}&type=video`;

      request.open('GET', url, true);

      request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
          const data = JSON.parse(request.responseText);
          displayResults(data);
        } else {
          const tracksPanel = document.getElementById('tracksPanel');
          if (tracksPanel) {
            tracksPanel.innerHTML = '<div class="empty-state"><p>Error fetching videos. Please try again.</p></div>';
          }
          console.error('Error fetching data from YouTube.');
        }
      };

      request.onerror = function() {
        const tracksPanel = document.getElementById('tracksPanel');
        if (tracksPanel) {
          tracksPanel.innerHTML = '<div class="empty-state"><p>Network error. Please check your connection.</p></div>';
        }
        console.error('Network error.');
      };

      request.send();
    }

    function handleAddMoreSubmit(event) {
      event.preventDefault();
      const searchQuery = document.getElementById('addMoreQuery').value.trim();
      
      if (!searchQuery) {
        return;
      }

      // Stop beat drop mix if active
      if (beatDropActive) {
        toggleBeatDropMix();
      }

      const tracksPanel = document.getElementById('tracksPanel');
      if (!tracksPanel) return;
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading';
      loadingDiv.textContent = 'Adding songs...';
      tracksPanel.appendChild(loadingDiv);

      const request = new XMLHttpRequest();
      const apiKey = 'AIzaSyAEzhGEyJJgZpoN6ahBTvnZyr4g5FV5s9s';
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=4&q=${encodeURIComponent(searchQuery)}&key=${apiKey}&type=video`;

      request.open('GET', url, true);

      request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
          const data = JSON.parse(request.responseText);
          if (data.items && data.items.length > 0) {
            // Remove loading indicator
            loadingDiv.remove();
            // Add new items to existing videoData
            const newItems = data.items.slice(0, 4);
            const startIndex = videoData.length;
            videoData = videoData.concat(newItems);
            
            // Detect genres for new tracks
            newItems.forEach((item, idx) => {
              const index = startIndex + idx;
              trackGenres[index] = detectGenre(item);
            });
            
            // Create players for new items
            createPlayersForItems(newItems, startIndex);
            
            // Clear the search input
            document.getElementById('addMoreQuery').value = '';
          } else {
            loadingDiv.textContent = 'No additional results found.';
            setTimeout(() => loadingDiv.remove(), 2000);
          }
        } else {
          loadingDiv.textContent = 'Error fetching videos.';
          setTimeout(() => loadingDiv.remove(), 2000);
        }
      };

      request.onerror = function() {
        loadingDiv.textContent = 'Network error.';
        setTimeout(() => loadingDiv.remove(), 2000);
      };

      request.send();
    }

    function createPlayersForItems(items, startIndex) {
      items.forEach((item, relativeIndex) => {
        const index = startIndex + relativeIndex;
        const tracksPanel = document.getElementById('tracksPanel');
        if (!tracksPanel) return;
        
        const videoCard = document.createElement('div');
        videoCard.className = 'video-card';
        videoCard.id = `card${index}`;
        videoCard.style.animationDelay = `${index * 0.1}s`;
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.className = 'close-button';
        closeButton.innerHTML = getSVGIcon('close');
        closeButton.title = 'Remove this song';
        closeButton.onclick = () => removeSong(index);
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper';
        const videoDiv = document.createElement('div');
        videoDiv.id = `player${index}`;
        videoWrapper.appendChild(videoDiv);
        
        videoCard.appendChild(closeButton);
        
        const detectedGenre = trackGenres[index] || 'electronic';
        
        const videoInfo = document.createElement('div');
        videoInfo.className = 'video-info';
        videoInfo.innerHTML = `
          <div class="video-title">${item.snippet.title}</div>
          <div class="video-channel">${item.snippet.channelTitle}</div>
          <div class="video-genre" id="genre${index}">${detectedGenre.toUpperCase()}</div>
        `;
        
        const controls = document.createElement('div');
        controls.className = 'controls';
        
        const playButton = document.createElement('button');
        playButton.className = 'play-button';
        playButton.id = `playBtn${index}`;
        playButton.innerHTML = getSVGIcon('play');
        playButton.onclick = () => togglePlay(index);
        playButton.title = 'Play/Pause';
        
        // Add reverse button
        const reverseButton = document.createElement('button');
        reverseButton.className = 'reverse-button';
        reverseButton.id = `reverseBtn${index}`;
        reverseButton.innerHTML = getSVGIcon('reverse');
        reverseButton.onclick = () => toggleReverse(index);
        reverseButton.title = 'Play in Reverse';
        reverseButton.style.cssText = 'padding: 6px 12px; font-size: 11px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; color: #ffffff; cursor: pointer; min-height: 32px; display: flex; align-items: center; justify-content: center; flex: 1;';
        
        // Create button group for play and reverse
        const playControlsGroup = document.createElement('div');
        playControlsGroup.style.cssText = 'display: flex; gap: 8px; width: 100%;';
        playControlsGroup.appendChild(playButton);
        playControlsGroup.appendChild(reverseButton);
        
        const volumeGroup = document.createElement('div');
        volumeGroup.className = 'control-group';
        volumeGroup.innerHTML = `
          <span class="control-icon" title="Volume">${getSVGIcon('volume')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="volume${index}" min="0" max="100" value="50">
          </div>
          <span class="control-value" id="volumeValue${index}">50%</span>
        `;
        
        const speedGroup = document.createElement('div');
        speedGroup.className = 'control-group';
        speedGroup.innerHTML = `
          <span class="control-icon" title="Speed">${getSVGIcon('speed')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="speed${index}" min="0.25" max="2" step="0.05" value="1">
          </div>
          <span class="control-value" id="speedValue${index}">1.0x</span>
        `;
        
        const pitchGroup = document.createElement('div');
        pitchGroup.className = 'control-group';
        pitchGroup.innerHTML = `
          <span class="control-icon" title="Pitch">${getSVGIcon('pitch')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="pitch${index}" min="-12" max="12" step="1" value="0">
          </div>
          <span class="control-value" id="pitchValue${index}">0</span>
        `;
        
        const loopGroup = document.createElement('div');
        loopGroup.className = 'control-group';
        loopGroup.style.flexDirection = 'column';
        loopGroup.style.gap = '6px';
        loopGroup.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
            <span class="control-icon" title="Loop">${getSVGIcon('loop')}</span>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;">
              <input type="checkbox" id="loop${index}" style="cursor: pointer;">
              <span style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Loop</span>
            </label>
          </div>
          <input 
            type="text" 
            id="loopPattern${index}" 
            placeholder="x xx xxx xxxxxx" 
            style="width: 100%; padding: 4px 8px; font-size: 11px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; background: rgba(255, 255, 255, 0.05); color: #ffffff; outline: none; font-family: monospace;"
            title="Loop pattern: each 'x' = 1 second, spaces separate segments"
          >
        `;
        
        // Add numbered cue buttons (1-5)
        const cueButtonsGroup = document.createElement('div');
        cueButtonsGroup.className = 'cue-buttons-group';
        cueButtonsGroup.style.cssText = 'display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;';
        cueButtonsGroup.innerHTML = `
          <button class="cue-number-btn" id="cueBtn${index}_1" title="Set/Jump to Cue 1">1</button>
          <button class="cue-number-btn" id="cueBtn${index}_2" title="Set/Jump to Cue 2">2</button>
          <button class="cue-number-btn" id="cueBtn${index}_3" title="Set/Jump to Cue 3">3</button>
          <button class="cue-number-btn" id="cueBtn${index}_4" title="Set/Jump to Cue 4">4</button>
          <button class="cue-number-btn" id="cueBtn${index}_5" title="Set/Jump to Cue 5">5</button>
        `;
        
        // Add event listeners for cue buttons
        for (let cueNum = 1; cueNum <= 5; cueNum++) {
          const cueBtn = document.getElementById(`cueBtn${index}_${cueNum}`);
          if (cueBtn) {
            cueBtn.addEventListener('click', () => handleCueButton(index, cueNum));
          }
        }
        
        // Add EQ controls
        const eqControls = document.createElement('div');
        eqControls.className = 'eq-controls';
        eqControls.innerHTML = `
          <div class="eq-control">
            <span class="eq-label" title="Low frequencies (Bass, Kick) - Adjust bass and low-end sounds">Low</span>
            <input type="range" class="eq-slider" id="eqLow${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Low frequencies: Bass, kick drums">
            <span class="control-value" id="eqLowValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="Mid frequencies (Vocals, Instruments) - Adjust vocals and mid-range instruments">Mid</span>
            <input type="range" class="eq-slider" id="eqMid${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Mid frequencies: Vocals, instruments">
            <span class="control-value" id="eqMidValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="High frequencies (Treble, Cymbals) - Adjust high-end sounds and clarity">High</span>
            <input type="range" class="eq-slider" id="eqHigh${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="High frequencies: Treble, cymbals">
            <span class="control-value" id="eqHighValue${index}" style="font-size: 9px;">0</span>
          </div>
        `;
        
        // Simple controls: play, volume, speed, pitch
        controls.appendChild(playControlsGroup);
        controls.appendChild(volumeGroup);
        controls.appendChild(speedGroup);
        controls.appendChild(pitchGroup);
        
        videoCard.appendChild(videoWrapper);
        videoCard.appendChild(videoInfo);
        videoCard.appendChild(controls);
        tracksPanel.appendChild(videoCard);

        // Initialize track state
        trackLoops[index] = false;
        trackPitch[index] = 0;
        trackReverse[index] = false;
        loopPatterns[index] = '';
        loopPatternIndex[index] = 0;
        loopSegmentLooped[index] = false;
        trackEQ[index] = { low: 0, mid: 0, high: 0 };
        cuePoints[index] = {}; // Initialize as object for numbered cues
        trackBPM[index] = 120; // Default BPM

        // Wait for card to be rendered, then create player
        setTimeout(() => {
          const cardWidth = videoCard.offsetWidth || 280;
          const cardHeight = Math.round(cardWidth * 0.5625);
          
          const videoId = item.id?.videoId || item.id;
          if (!videoId) {
            console.error('No video ID found for item:', item);
            return;
          }
          
          const createPlayer = () => {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
              setTimeout(createPlayer, 200);
              return;
            }
            
            try {
              players[index] = new YT.Player(videoDiv.id, {
                height: cardHeight.toString(),
                width: cardWidth.toString(),
                videoId: videoId,
                playerVars: {
                  modestbranding: 1,
                  rel: 0,
                  showinfo: 0,
                  playsinline: 1,
                  enablejsapi: 1
                },
                events: {
                  'onReady': function(event) {
                    event.target.setVolume(50);
                    setupControls(index);
                    readyPlayers.push(index);
                    
                    const iframe = videoDiv.querySelector('iframe');
                    if (iframe) {
                      iframe.style.width = '100%';
                      iframe.style.height = '100%';
                      iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture; accelerometer; gyroscope; clipboard-write; web-share');
                      iframe.setAttribute('allowfullscreen', 'true');
                    }
                  },
                  'onStateChange': function(event) {
                    updatePlayButton(index, event.data);
                    
                    if (event.data === YT.PlayerState.PLAYING && trackLoops[index]) {
                      startLoop(index);
                    } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                      stopLoop(index);
                    }
                  },
                  'onError': function(event) {
                    console.error('YouTube player error:', event.data);
                    const videoInfo = videoCard.querySelector('.video-info');
                    if (videoInfo) {
                      const errorDiv = document.createElement('div');
                      errorDiv.style.cssText = 'color: #ff6b6b; font-size: 11px; margin-top: 4px; padding: 4px; background: rgba(255, 107, 107, 0.1); border-radius: 4px;';
                      errorDiv.textContent = 'Video unavailable';
                      videoInfo.appendChild(errorDiv);
                    }
                    videoCard.style.opacity = '0.6';
                    videoCard.style.pointerEvents = 'none';
                  }
                }
              });
            } catch (error) {
              console.error('Error creating YouTube player:', error);
            }
          };
          
          createPlayer();
        }, 100);
      });
    }

    function togglePeopleMode() {
      peopleModeActive = !peopleModeActive;
      const peopleModeButton = document.getElementById('peopleModeButton');
      const energyLevelElement = document.getElementById('energyLevel');
      
      if (peopleModeActive) {
        peopleModeButton.classList.add('active');
        energyHistory = []; // Reset energy history
        energyLevel = 0.5; // Start at medium
        updateEnergyDisplay();
        console.log('People Mode: ON - Rhythm adjusts based on energy');
      } else {
        peopleModeButton.classList.remove('active');
        updateEnergyDisplay();
        console.log('People Mode: OFF');
      }
    }

    function toggleLock() {
      if (!copilotActive) return; // Only allow locking when DJ VEEX20 is active
      
      djVeeLocked = !djVeeLocked;
      const lockButton = document.getElementById('lockButton');
      const lockIcon = document.getElementById('lockIcon');
      const lockText = document.getElementById('lockText');
      
      if (djVeeLocked) {
        lockButton.classList.remove('unlocked');
        lockIcon.innerHTML = getSVGIcon('lock');
        lockText.textContent = 'Lock';
      } else {
        lockButton.classList.add('unlocked');
        lockIcon.innerHTML = getSVGIcon('unlock');
        lockText.textContent = 'Unlock';
      }
      
      // Update controls based on new lock state
      updateControlsForLockState();
    }

    const searchForm = document.getElementById('searchForm');
    searchForm.addEventListener('submit', handleFormSubmit);

    const addMoreForm = document.getElementById('addMoreForm');
    if (addMoreForm) {
    addMoreForm.addEventListener('submit', handleAddMoreSubmit);
    }

    const copilotButton = document.getElementById('copilotButton');
    copilotButton.addEventListener('click', toggleCopilot);

    const beatDropButton = document.getElementById('beatDropButton');
    if (beatDropButton) {
      beatDropButton.addEventListener('click', toggleBeatDropMix);
    }

    // Play All button
    const playAllButton = document.getElementById('playAllButton');
    if (playAllButton) {
      playAllButton.addEventListener('click', playAllTracks);
    }

    // Shift button
    const shiftButton = document.getElementById('shiftButton');
    if (shiftButton) {
      shiftButton.addEventListener('click', shiftToNext);
    }

    // Initialize voice button icon (if it exists)
    const voiceButton = document.getElementById('voiceButton');
    if (voiceButton) {
      const voiceIcon = document.getElementById('voiceIcon');
      if (voiceIcon) {
        voiceIcon.innerHTML = getSVGIcon('mic');
      }
      voiceButton.addEventListener('click', toggleVoice);
    }

    // TTS Setup
    const ttsButton = document.getElementById('ttsButton');
    const ttsIcon = document.getElementById('ttsIcon');
    const ttsInput = document.getElementById('ttsInput');
    
    if (ttsIcon) {
      ttsIcon.innerHTML = getSVGIcon('tts');
    }
    
    if (ttsButton) {
      ttsButton.addEventListener('click', handleTTS);
    }
    
    // TTS Stop button
    const ttsStopButton = document.getElementById('ttsStopButton');
    if (ttsStopButton) {
      ttsStopButton.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        stopTTS();
        // Visual feedback
        this.style.transform = 'scale(0.95)';
        this.style.background = 'rgba(255, 0, 0, 0.4)';
        setTimeout(() => {
          this.style.transform = 'scale(1)';
          this.style.background = 'rgba(255, 0, 0, 0.2)';
        }, 150);
      });
      // Ensure button is never disabled
      ttsStopButton.disabled = false;
    }
    
    // Prefill buttons
    document.querySelectorAll('.tts-prefill').forEach(button => {
      button.addEventListener('click', function() {
        const text = this.getAttribute('data-text');
        if (ttsInput) {
          ttsInput.value = text;
        }
        handleTTS();
      });
    });
    
    // Enter key to speak
    if (ttsInput) {
      ttsInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          handleTTS();
        }
      });
    }

    // Spacebar button initialization
    const spacebarButton = document.getElementById('spacebarButton');
    const spacebarIcon = document.getElementById('spacebarIcon');
    if (spacebarIcon) {
      spacebarIcon.innerHTML = getSVGIcon('spacebar');
    }
    if (spacebarButton) {
      spacebarButton.addEventListener('click', handleSpacebar);
    }

    // People Mode button initialization
    const peopleModeButton = document.getElementById('peopleModeButton');
    if (peopleModeButton) {
      peopleModeButton.addEventListener('click', togglePeopleMode);
    }

    // Keyboard event listener for spacebar
    document.addEventListener('keydown', function(e) {
      // Only handle spacebar if not typing in an input field
      if (e.key === ' ' || e.key === 'Spacebar') {
        const activeElement = document.activeElement;
        const isInputField = activeElement && (
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA' ||
          activeElement.isContentEditable
        );
        
        if (!isInputField) {
          e.preventDefault();
          handleSpacebar();
        }
      }
    });

    // Sound effects button event listeners
    const truckSoundBtn = document.getElementById('truckSoundBtn');
    const fireStationSoundBtn = document.getElementById('fireStationSoundBtn');
    const bowBowBowBtn = document.getElementById('bowBowBowBtn');
    
    if (truckSoundBtn) {
      truckSoundBtn.addEventListener('click', function() {
        playTruckSound();
        this.style.transform = 'scale(0.95)';
        setTimeout(() => {
          this.style.transform = 'scale(1)';
        }, 200);
      });
    }
    
    if (fireStationSoundBtn) {
      fireStationSoundBtn.addEventListener('click', function() {
        playFireStationSound();
        this.style.transform = 'scale(0.95)';
        setTimeout(() => {
          this.style.transform = 'scale(1)';
        }, 200);
      });
    }
    
    if (bowBowBowBtn) {
      bowBowBowBtn.addEventListener('click', function() {
        playBowBowBow();
        this.style.transform = 'scale(0.95)';
        setTimeout(() => {
          this.style.transform = 'scale(1)';
        }, 200);
      });
    }

    // Voice recording and playback functions
    async function toggleVoice() {
      if (!voiceRecording && !voiceAudio) {
        // Start recording
        await startVoiceRecording();
      } else if (voiceRecording) {
        // Stop recording and play
        await stopVoiceRecording();
      } else if (voiceAudio) {
        // Stop playback
        stopVoicePlayback();
      }
    }

    async function startVoiceRecording() {
      try {
        voiceStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(voiceStream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          if (audioChunks.length === 0) {
            console.error('No audio data recorded');
            return;
          }
          
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(audioBlob);
          voiceAudio = new Audio(audioUrl);
          
          // Play voice directly through speakers
          try {
            await voiceAudio.play();
            const voiceButton = document.getElementById('voiceButton');
            if (voiceButton) {
              voiceButton.classList.add('playing');
              voiceButton.classList.remove('recording');
              const voiceText = voiceButton.querySelector('#voiceText');
              if (voiceText) voiceText.textContent = 'Playing...';
            }
          } catch (playError) {
            console.error('Error playing audio:', playError);
            alert('Error playing recorded audio. Please try again.');
          }
          
          voiceAudio.onended = () => {
            const voiceButton = document.getElementById('voiceButton');
            if (voiceButton) {
              voiceButton.classList.remove('playing');
              const voiceText = voiceButton.querySelector('#voiceText');
              if (voiceText) voiceText.textContent = 'Voice';
            }
            voiceAudio = null;
          };
        };

        mediaRecorder.start();
        voiceRecording = true;
        const voiceButton = document.getElementById('voiceButton');
        if (voiceButton) {
          voiceButton.classList.add('recording');
          const voiceText = voiceButton.querySelector('#voiceText');
          if (voiceText) voiceText.textContent = 'Recording...';
        }
      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('Microphone access denied. Please allow microphone access to record your voice.');
        voiceRecording = false;
      }
    }

    async function stopVoiceRecording() {
      if (mediaRecorder && voiceRecording) {
        try {
          mediaRecorder.stop();
          if (voiceStream) {
            voiceStream.getTracks().forEach(track => track.stop());
          }
          voiceRecording = false;
          const voiceButton = document.getElementById('voiceButton');
          if (voiceButton) {
            const voiceText = voiceButton.querySelector('#voiceText');
            if (voiceText) voiceText.textContent = 'Processing...';
          }
        } catch (error) {
          console.error('Error stopping recording:', error);
        }
      }
    }

    function stopVoicePlayback() {
      if (voiceAudio) {
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        voiceAudio = null;
        const voiceButton = document.getElementById('voiceButton');
        if (voiceButton) {
          voiceButton.classList.remove('playing');
          const voiceText = voiceButton.querySelector('#voiceText');
          if (voiceText) voiceText.textContent = 'Voice';
        }
      }
    }

    // Text-to-Speech Functions - Optimized for LOUD and MELODIOUS voice
    function initializeTTS() {
      if ('speechSynthesis' in window) {
        // Get available voices
        const loadVoices = () => {
          ttsVoices = speechSynthesis.getVoices();
          
          // Select HEAVY/DEEP voice - prefer male voices for heavy, bassy sound
          // Male voices tend to be deeper and heavier for powerful DJ announcements
          const preferredHeavyVoices = [
            'Google UK English Male',     // Deep and clear
            'Google US English Male',     // Heavy and powerful
            'Microsoft David',           // Professional deep male voice
            'Microsoft Mark',            // Deep male voice
            'Alex',                      // Apple's deep male voice
            'Daniel',                    // Deep British voice
            'Tom',                       // Deep American voice
            'Microsoft David Desktop',   // Windows deep voice
            'Microsoft Mark Desktop'     // Windows heavy voice
          ];
          
          // Try to find preferred heavy/deep voice
          for (const preferred of preferredHeavyVoices) {
            const voice = ttsVoices.find(v => 
              v.name.includes(preferred) || 
              (v.name.toLowerCase().includes('male') && v.lang.startsWith('en'))
            );
            if (voice) {
              selectedVoice = voice;
              console.log('Selected heavy voice:', voice.name);
              break;
            }
          }
          
          // If no preferred found, prefer male English voices for heavy sound
          if (!selectedVoice) {
            selectedVoice = ttsVoices.find(v => 
              v.lang.startsWith('en') && 
              (v.name.toLowerCase().includes('male') || v.name.toLowerCase().includes('man') || v.name.toLowerCase().includes('david') || v.name.toLowerCase().includes('mark') || v.name.toLowerCase().includes('alex'))
            ) || ttsVoices.find(v => v.lang.startsWith('en')) || ttsVoices[0];
          }
          
          if (selectedVoice) {
            console.log('Using TTS voice:', selectedVoice.name, 'for HEAVY DJ announcements');
          }
        };
        
        loadVoices();
        speechSynthesis.onvoiceschanged = loadVoices;
      }
    }

    function speakText(text, options = {}) {
      if (!('speechSynthesis' in window)) {
        console.error('Text-to-speech not supported');
        alert('Text-to-speech is not supported in your browser.');
        return Promise.resolve();
      }

      // Cancel any ongoing speech
      if (isTTSPlaying) {
        speechSynthesis.cancel();
      }

      return new Promise((resolve) => {
        if (!text || text.trim() === '') {
          resolve();
          return;
        }

        const utterance = new SpeechSynthesisUtterance(text.trim());
        
        // Use selected voice or best available
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        // Set properties for HEAVY voice
        // Make TTS LOUDER and HEAVIER (DEEP) for DJ announcements
        utterance.rate = options.rate || 0.85; // Slower rate for heavier, more powerful effect
        utterance.pitch = options.pitch || 0.7; // LOWER pitch (0.7) for HEAVY, deep DJ voice
        utterance.volume = options.volume || 1.0; // MAXIMUM volume (1.0) for LOUDNESS
        utterance.lang = selectedVoice?.lang || 'en-US';
        
        // Enhanced HEAVY effect - create deep, powerful intonation
        // Lower pitch creates heavier, more powerful DJ announcements
        if (!options.noHeavy) {
          // Add pitch variation for heavy effect
          const isExclamation = text.includes('!');
          const isQuestion = text.includes('?');
          
          if (isExclamation) {
            // Exclamations get slightly higher but still heavy
            utterance.pitch = 0.75;
            utterance.rate = 0.80; // Slower for dramatic heavy effect
          } else if (isQuestion) {
            // Questions get slightly higher but still deep
            utterance.pitch = 0.72;
          } else {
            // Normal statements with heavy deep pitch
            utterance.pitch = 0.7;
          }
        }
        
        utterance.onstart = () => {
          isTTSPlaying = true;
        };
        
        utterance.onend = () => {
          isTTSPlaying = false;
          resolve();
        };
        
        utterance.onerror = (error) => {
          console.error('TTS Error:', error);
          isTTSPlaying = false;
          resolve();
        };
        
        try {
          speechSynthesis.speak(utterance);
        } catch (error) {
          console.error('Error starting speech synthesis:', error);
          alert('Error starting text-to-speech. Please try again.');
          isTTSPlaying = false;
          resolve();
        }
      });
    }

    function stopTTS() {
      try {
        if ('speechSynthesis' in window) {
          // Cancel all pending and current speech
          speechSynthesis.cancel();
          
          // Clear the queue
          ttsQueue = [];
          
          // Reset playing state
          isTTSPlaying = false;
          
          // Force stop any remaining utterances
          if (window.speechSynthesis.speaking) {
            window.speechSynthesis.cancel();
          }
          
          console.log('TTS stopped and queue cleared');
          
          // Visual feedback on button
          const stopButton = document.getElementById('ttsStopButton');
          if (stopButton) {
            stopButton.disabled = false;
            stopButton.style.opacity = '1';
            stopButton.style.cursor = 'pointer';
          }
        }
      } catch (error) {
        console.error('Error stopping TTS:', error);
      }
    }

    function playTTSBetweenTracks(text) {
      // Add to queue for DJ VEEX20 to play between tracks
      ttsQueue.push(text);
    }

    // Auto-generate TTS phrases for DJ VEEX20 based on context
    function generateAutoTTSPhrase(context) {
      const phrases = {
        trackStart: [
          'Let\'s go!',
          'Here we go!',
          'Feel the beat!',
          'Energy rising!',
          'This is DJ VEEX20!'
        ],
        trackTransition: [
          'Smooth transition!',
          'Here comes the drop!',
          'Feel the mix!',
          'Next level!',
          'Keep it going!'
        ],
        energyBoost: [
          'Energy boost!',
          'Pump it up!',
          'Feel the power!',
          'Maximum energy!',
          'Let\'s go higher!'
        ],
        genreChange: [
          'Changing the vibe!',
          'New energy!',
          'Different flow!',
          'Fresh sound!',
          'New direction!'
        ]
      };
      
      const categoryPhrases = phrases[context] || phrases.trackStart;
      return categoryPhrases[Math.floor(Math.random() * categoryPhrases.length)];
    }

    async function handleTTS() {
      const ttsInput = document.getElementById('ttsInput');
      if (!ttsInput) {
        console.error('TTS input not found');
        return;
      }
      
      const text = ttsInput.value.trim();
      
      if (!text) {
        alert('Please enter text to speak');
        return;
      }
      
      // Initialize TTS if not already done
      if (ttsVoices.length === 0) {
        initializeTTS();
        // Wait a bit for voices to load
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      try {
        // Play immediately - LOUD and MELODIOUS
        await speakText(text, {
          volume: 1.0,  // MAXIMUM volume - LOUD
          rate: 0.85,  // Slower for heavier, more powerful effect
          pitch: 0.7   // LOWER pitch (0.7) for HEAVY, deep DJ voice
        });
        
        // Also add to DJ VEEX20 queue
        playTTSBetweenTracks(text);
        
        // Clear input
        ttsInput.value = '';
      } catch (error) {
        console.error('Error in handleTTS:', error);
        alert('Error speaking text. Please try again.');
      }
    }

    // Initialize TTS on page load
    initializeTTS();

    document.getElementById('searchQuery').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        handleFormSubmit(e);
      }
    });


    // Removed - YouTube only
    function createLocalVideoPlayer_removed(index, videoUrl, fileName) {
      const resultsDiv = document.getElementById('results');
      
      const videoCard = document.createElement('div');
      videoCard.className = 'video-card';
      videoCard.id = `card${index}`;
      videoCard.style.animationDelay = `${index * 0.1}s`;
      
      // Close button
      const closeButton = document.createElement('button');
      closeButton.className = 'close-button';
      closeButton.innerHTML = getSVGIcon('close');
      closeButton.title = 'Remove this song';
      closeButton.onclick = () => {
        if (localVideoPlayers[index]) {
          localVideoPlayers[index].pause();
          localVideoPlayers[index].src = '';
          URL.revokeObjectURL(videoUrl);
        }
        uploadedVideos = uploadedVideos.filter(v => v.index !== index);
        delete localVideoPlayers[index];
        videoCard.remove();
      };
      
      const videoWrapper = document.createElement('div');
      videoWrapper.className = 'video-wrapper';
      
      // Create HTML5 video element
      const videoElement = document.createElement('video');
      videoElement.src = videoUrl;
      videoElement.controls = false;
      videoElement.playsinline = true;
      videoElement.preload = 'metadata';
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';
      videoElement.id = `localVideo${index}`;
      
      videoWrapper.appendChild(videoElement);
      videoCard.appendChild(closeButton);
      videoCard.appendChild(videoWrapper);
      
      // Video info
      const videoInfo = document.createElement('div');
      videoInfo.className = 'video-info';
      videoInfo.innerHTML = `
        <div class="video-title">${fileName}</div>
        <div class="video-channel">Local Video File</div>
        <div class="video-genre" id="genre${index}">MUSIC</div>
      `;
      videoCard.appendChild(videoInfo);
      
      // Initialize track state
      trackLoops[index] = false;
      trackPitch[index] = 0;
      trackReverse[index] = false;
      loopPatterns[index] = '';
      loopPatternIndex[index] = 0;
      loopSegmentLooped[index] = false;
      trackEQ[index] = { low: 0, mid: 0, high: 0 };
      cuePoints[index] = {};
      trackBPM[index] = 120;
      trackGenres[index] = 'electronic';
      
      // Store video element
      localVideoPlayers[index] = videoElement;
      
      // Create controls (same as YouTube players)
      const controls = document.createElement('div');
      controls.className = 'controls';
      
      // Play button
      const playButton = document.createElement('button');
      playButton.className = 'play-button';
      playButton.id = `playBtn${index}`;
      playButton.innerHTML = getSVGIcon('play');
      playButton.onclick = () => toggleLocalVideoPlay(index);
      playButton.title = 'Play/Pause';
      
      const playControlsGroup = document.createElement('div');
      playControlsGroup.className = 'play-controls-group';
      playControlsGroup.appendChild(playButton);
      
      // Volume control
      const volumeGroup = document.createElement('div');
      volumeGroup.className = 'control-group';
      volumeGroup.innerHTML = `
        <label>Volume</label>
        <input type="range" id="volume${index}" min="0" max="100" value="50" class="slider">
        <span class="control-value" id="volumeValue${index}">50%</span>
      `;
      
      // Speed control
      const speedGroup = document.createElement('div');
      speedGroup.className = 'control-group';
      speedGroup.innerHTML = `
        <label>Speed</label>
        <input type="range" id="speed${index}" min="0.25" max="2" step="0.01" value="1" class="slider">
        <span class="control-value" id="speedValue${index}">1.00x</span>
      `;
      
      // Loop checkbox
      const loopGroup = document.createElement('div');
      loopGroup.className = 'control-group';
      loopGroup.innerHTML = `
        <label style="display: flex; align-items: center; gap: 6px;">
          <input type="checkbox" id="loop${index}" style="width: auto;">
          <span>Loop</span>
        </label>
        <input type="text" id="loopPattern${index}" placeholder="Pattern: x xx xxx" style="margin-top: 4px; padding: 4px; font-size: 11px; width: 100%;">
      `;
      
      // EQ controls
      const eqControls = document.createElement('div');
      eqControls.className = 'eq-controls';
      eqControls.innerHTML = `
        <div class="eq-control">
          <span class="eq-label">Low</span>
          <input type="range" class="eq-slider" id="eqLow${index}" min="-12" max="12" step="1" value="0" orient="vertical">
          <span class="control-value" id="eqLowValue${index}" style="font-size: 9px;">0</span>
        </div>
        <div class="eq-control">
          <span class="eq-label">Mid</span>
          <input type="range" class="eq-slider" id="eqMid${index}" min="-12" max="12" step="1" value="0" orient="vertical">
          <span class="control-value" id="eqMidValue${index}" style="font-size: 9px;">0</span>
        </div>
        <div class="eq-control">
          <span class="eq-label">High</span>
          <input type="range" class="eq-slider" id="eqHigh${index}" min="-12" max="12" step="1" value="0" orient="vertical">
          <span class="control-value" id="eqHighValue${index}" style="font-size: 9px;">0</span>
        </div>
      `;
      
      controls.appendChild(playControlsGroup);
      controls.appendChild(volumeGroup);
      controls.appendChild(speedGroup);
      controls.appendChild(loopGroup);
      controls.appendChild(eqControls);
      
      videoCard.appendChild(controls);
      resultsDiv.appendChild(videoCard);
      
      // Setup controls
      setupLocalVideoControls(index, videoElement);
      
      // Add to ready players
      videoElement.addEventListener('loadedmetadata', () => {
        readyPlayers.push(index);
      });
    }
    
    // Setup controls for local video
    function setupLocalVideoControls(index, videoElement) {
      // Volume
      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      if (volumeSlider && volumeValue) {
        volumeSlider.addEventListener('input', function() {
          const volume = parseInt(this.value);
          videoElement.volume = volume / 100;
          volumeValue.textContent = volume + '%';
        });
      }
      
      // Speed
      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      if (speedSlider && speedValue) {
        speedSlider.addEventListener('input', function() {
          const speed = parseFloat(this.value);
          videoElement.playbackRate = speed;
          speedValue.textContent = speed.toFixed(2) + 'x';
        });
      }
      
      // Loop
      const loopCheckbox = document.getElementById(`loop${index}`);
      if (loopCheckbox) {
        loopCheckbox.addEventListener('change', function() {
          trackLoops[index] = this.checked;
          videoElement.loop = this.checked;
          if (this.checked) {
            startLocalVideoLoop(index);
          } else {
            stopLocalVideoLoop(index);
          }
        });
      }
      
      // EQ (visual only for now)
      ['Low', 'Mid', 'High'].forEach(eqType => {
        const eqSlider = document.getElementById(`eq${eqType}${index}`);
        const eqValue = document.getElementById(`eq${eqType}Value${index}`);
        if (eqSlider && eqValue) {
          eqSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            if (!trackEQ[index]) trackEQ[index] = { low: 0, mid: 0, high: 0 };
            trackEQ[index][eqType.toLowerCase()] = value;
            eqValue.textContent = value > 0 ? '+' + value : value;
          });
        }
      });
    }
    
    // Toggle local video play
    function toggleLocalVideoPlay(index) {
      const video = localVideoPlayers[index];
      if (!video) return;
      
      if (video.paused) {
        video.play();
        const playButton = document.getElementById(`playBtn${index}`);
        if (playButton) {
          playButton.innerHTML = getSVGIcon('pause');
          playButton.classList.add('playing');
        }
        const card = document.getElementById(`card${index}`);
        if (card) card.classList.add('playing');
        
        if (trackLoops[index]) {
          startLocalVideoLoop(index);
        }
      } else {
        video.pause();
        const playButton = document.getElementById(`playBtn${index}`);
        if (playButton) {
          playButton.innerHTML = getSVGIcon('play');
          playButton.classList.remove('playing');
        }
        const card = document.getElementById(`card${index}`);
        if (card) card.classList.remove('playing');
        stopLocalVideoLoop(index);
      }
    }
    
    // Loop functions for local videos
    function startLocalVideoLoop(index) {
      const video = localVideoPlayers[index];
      if (!video || !trackLoops[index]) return;
      
      stopLocalVideoLoop(index);
      
      // If loop points are set, use them; otherwise loop entire video
      if (loopStartTimes[index] !== undefined && loopEndTimes[index] !== undefined) {
        const checkLoop = () => {
          if (!trackLoops[index] || !video) return;
          const current = video.currentTime;
          if (current >= loopEndTimes[index] - 0.3) {
            video.currentTime = loopStartTimes[index];
          }
        };
        loopIntervals[index] = setInterval(checkLoop, 100);
      } else {
        // Loop entire video
        video.loop = true;
      }
    }
    
    function stopLocalVideoLoop(index) {
      if (loopIntervals[index]) {
        clearInterval(loopIntervals[index]);
        loopIntervals[index] = null;
      }
      const video = localVideoPlayers[index];
      if (video) {
        video.loop = false;
      }
    }

    function displayLocalVideos() {
      const backgroundContainer = document.getElementById('backgroundVideos');
      if (!backgroundContainer) return;
      
      backgroundContainer.innerHTML = '';
      
      localVideoElements = [];
      backgroundVideoStarted = false;

      localVideos.forEach((videoFile, index) => {
        const videoElement = document.createElement('video');
        videoElement.className = 'background-video';
        videoElement.id = `bgVideo${index}`;
        videoElement.src = videoFile;
        videoElement.muted = true;
        videoElement.loop = false;
        videoElement.playsinline = true;
        videoElement.preload = 'auto';
        
        backgroundContainer.appendChild(videoElement);
        localVideoElements.push(videoElement);
        
        // Start first video when ready
        if (index === 0) {
          const startFirstVideo = () => {
            if (!backgroundVideoStarted) {
            backgroundVideoStarted = true;
              setTimeout(() => playBackgroundVideo(0), 300);
            }
          };
          
          videoElement.addEventListener('canplay', startFirstVideo, { once: true });
          videoElement.addEventListener('loadeddata', startFirstVideo, { once: true });
        }
        
        // Auto-advance to next video when current ends
        videoElement.addEventListener('ended', () => {
          const nextIndex = (index + 1) % localVideos.length;
          switchToNextBackground(index);
        });
        
        // Try to load immediately
        videoElement.load();
      });
    }

    function playBackgroundVideo(index) {
      if (localVideoElements.length === 0) return;
      
      // Stop all background videos
      localVideoElements.forEach((video, i) => {
        if (video) {
          video.pause();
          video.classList.remove('active');
          video.style.opacity = '0';
        }
      });
      
      // Play selected video
      const video = localVideoElements[index];
      if (!video) return;
      
      video.currentTime = 0;
      video.muted = true;
      video.style.opacity = '1';
      video.classList.add('active');
      
      const playPromise = video.play();
      if (playPromise !== undefined) {
        playPromise.catch(err => {
          // Retry on user interaction
          document.addEventListener('click', function retryPlay() {
            video.play().catch(() => {});
            document.removeEventListener('click', retryPlay);
          }, { once: true });
        });
      }
    }

    function switchToNextBackground(currentIndex) {
      const nextIndex = (currentIndex + 1) % localVideoElements.length;
      
      const currentVideo = localVideoElements[currentIndex];
      const nextVideo = localVideoElements[nextIndex];
      
      if (currentVideo) {
        currentVideo.classList.remove('active');
        currentVideo.style.opacity = '0';
        currentVideo.pause();
      }
      
      setTimeout(() => {
        if (nextVideo) {
          nextVideo.currentTime = 0;
          nextVideo.muted = true;
          nextVideo.style.opacity = '1';
          nextVideo.classList.add('active');
          
          const playPromise = nextVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch(() => {
              // Retry on next user interaction
              document.addEventListener('click', function retryPlay() {
                nextVideo.play().catch(() => {});
                document.removeEventListener('click', retryPlay);
              }, { once: true });
            });
          }
        }
      }, 500);
    }

    // Get current playing video index
    function getCurrentBackgroundIndex() {
      for (let i = 0; i < localVideoElements.length; i++) {
        if (localVideoElements[i] && localVideoElements[i].classList.contains('active') && !localVideoElements[i].paused) {
          return i;
        }
      }
      return -1;
    }

    // Enable video playback on any user interaction (click anywhere)
    document.addEventListener('click', function enableVideos() {
      if (localVideoElements.length > 0) {
        const activeVideo = localVideoElements.find(v => v.classList.contains('active'));
        if (!activeVideo || activeVideo.paused) {
          const currentIndex = localVideoElements.findIndex(v => v.classList.contains('active'));
          const indexToPlay = currentIndex >= 0 ? currentIndex : 0;
          playBackgroundVideo(indexToPlay);
        }
      }
    }, { once: false });

    function setupLocalControls(index, videoElement) {
      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      
      if (volumeSlider && volumeValue) {
        volumeSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - enable unmuting
            if (!userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
              // Unmute all videos after user interaction
              localVideoElements.forEach(v => {
                if (v) v.muted = false;
              });
            }
            
            const volume = parseInt(this.value);
            videoElement.volume = volume / 100;
            if (videoElement.muted && volume > 0) {
              videoElement.muted = false;
            }
            volumeValue.textContent = volume + '%';
          }
        });
      }

      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      if (speedSlider && speedValue) {
        speedSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - enable unmuting
            if (!userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
              // Unmute all videos after user interaction
              localVideoElements.forEach(v => {
                if (v) v.muted = false;
              });
            }
            
            const speed = parseFloat(this.value);
            videoElement.playbackRate = speed;
            speedValue.textContent = speed.toFixed(2) + 'x';
          }
        });
      }
    }

    function toggleLocalPlay(index) {
      // Always stop all other videos first - only one plays at a time
      localVideoElements.forEach((video, i) => {
        if (i !== index && !video.paused) {
          video.pause();
          updateLocalPlayButton(i, false);
          const card = document.getElementById(`card${i}`);
          if (card) card.classList.remove('playing');
        }
      });
      
      // User interaction - enable unmuting
      if (!userInteracted) {
        userInteracted = true;
        autoPlayActive = false;
        // Unmute all videos after user interaction
        localVideoElements.forEach(video => {
          if (video) {
            video.muted = false;
          }
        });
      }
      
      const video = localVideoElements[index];
      if (!video) return;
      
      if (video.paused) {
        // Unmute on play if user has interacted
        if (userInteracted) {
          video.muted = false;
        }
        video.play().catch(err => {
          console.log('Play failed, trying muted:', err);
          video.muted = true;
          video.play();
        });
        updateLocalPlayButton(index, true);
        document.getElementById(`card${index}`).classList.add('playing');
        currentPlayingIndex = index;
      } else {
        video.pause();
        updateLocalPlayButton(index, false);
        document.getElementById(`card${index}`).classList.remove('playing');
        currentPlayingIndex = -1;
      }
    }

    function updateLocalPlayButton(index, playing) {
      const playButton = document.getElementById(`playBtn${index}`);
      if (playButton) {
        playButton.textContent = playing ? 'Pause' : 'Play';
        playButton.classList.toggle('playing', playing);
      }
    }

    function playLocalVideoAuto(index) {
      if (!autoPlayActive || userInteracted) return;
      
      const video = localVideoElements[index];
      if (!video) return;
      
      // ALWAYS stop all other videos first - only one plays at a time
      localVideoElements.forEach((v, i) => {
        if (i !== index) {
          v.pause();
          updateLocalPlayButton(i, false);
          const card = document.getElementById(`card${i}`);
          if (card) card.classList.remove('playing');
        }
      });
      
      // Start muted for autoplay policy compliance
      video.muted = true;
      video.volume = 0.5; // Set volume but keep muted until user interaction
      
      // Try to play (will be muted)
      video.play().catch(err => {
        console.log('Autoplay failed:', err);
      });
      
      // Fade in volume over 1 second (but video stays muted until user interaction)
      let volumeStep = 0;
      const fadeInterval = setInterval(() => {
        volumeStep += 2;
        if (volumeStep <= 50) {
          video.volume = volumeStep / 100;
        } else {
          clearInterval(fadeInterval);
          video.volume = 0.5;
        }
      }, 40);
      
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      
      if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
      }
      if (videoCard) {
        videoCard.classList.add('playing');
      }
      
      currentPlayingIndex = index;
    }

    // Auto-load background videos on page load
    window.addEventListener('load', function() {
      console.log('Page loaded, initializing background videos');
      setTimeout(() => {
        displayLocalVideos();
      }, 500);
    });

    // Also try on DOMContentLoaded as fallback
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM ready, checking for background videos');
      if (localVideoElements.length === 0) {
        setTimeout(() => {
          displayLocalVideos();
        }, 300);
      }
      
      // Initialize voice button icon
      const voiceIcon = document.getElementById('voiceIcon');
      if (voiceIcon) {
        voiceIcon.innerHTML = getSVGIcon('mic');
      }
      
      // Initialize lock button icon
      const lockIcon = document.getElementById('lockIcon');
      if (lockIcon) {
        lockIcon.innerHTML = getSVGIcon('lock');
      }
      
      // Initialize TTS
      initializeTTS();
    });

    // Make a track primary (move to right panel)
    function makePrimary(index) {
      if (!videoData[index]) return;
      
      const item = videoData[index];
      const primaryVideoCard = document.getElementById('primaryVideoCard');
      const primaryVideoWrapper = document.getElementById('primaryVideoWrapper');
      const primaryVideoInfo = document.getElementById('primaryVideoInfo');
      const primaryControls = document.getElementById('primaryControls');
      const emptyState = document.getElementById('emptyState');
      const trackCard = document.getElementById(`trackCard${index}`);
      
      if (!primaryVideoCard || !primaryVideoWrapper) return;
      
      // Update active state
      document.querySelectorAll('.track-card-small').forEach(card => {
        card.classList.remove('active');
      });
      if (trackCard) trackCard.classList.add('active');
      
      primaryVideoIndex = index;
      primaryVideoCard.style.display = 'flex';
      emptyState.style.display = 'none';
      
      // Clear primary panel
      primaryVideoWrapper.innerHTML = '';
      primaryControls.innerHTML = '';
      
      // Get or create player
      let player = players[index];
      if (!player) {
        // Player not ready yet, will be created
        return;
      }
      
      // Move iframe to primary panel - check both thumbnail and hidden player div
      let iframe = document.querySelector(`#thumb${index} iframe`);
      if (!iframe) {
        iframe = document.querySelector(`#player${index} iframe`);
      }
      if (iframe) {
        // Move the actual iframe (YouTube player API will still work)
        primaryVideoWrapper.innerHTML = '';
        primaryVideoWrapper.appendChild(iframe);
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.minHeight = '400px';
        iframe.style.border = 'none';
        iframe.style.display = 'block';
        iframe.style.position = 'absolute';
        iframe.style.top = '0';
        iframe.style.left = '0';
        
        // Force the wrapper to have a height
        if (!primaryVideoWrapper.style.height || primaryVideoWrapper.style.height === '0px') {
          primaryVideoWrapper.style.height = '500px';
        }
        
        // Update iframe dimensions for larger display
        try {
          if (player && player.setSize) {
            player.setSize(window.innerWidth * 0.6, 500);
          }
        } catch (e) {
          console.warn('Could not resize player:', e);
        }
      } else {
        console.warn(`Iframe not found for player ${index}. Player may not be ready yet.`);
        // If player exists but iframe not found, wait a bit and try again
        if (player) {
          setTimeout(() => {
            let iframe = document.querySelector(`#thumb${index} iframe`) || document.querySelector(`#player${index} iframe`);
            if (iframe && primaryVideoWrapper) {
              primaryVideoWrapper.innerHTML = '';
              primaryVideoWrapper.appendChild(iframe);
              iframe.style.width = '100%';
              iframe.style.height = '100%';
              iframe.style.minHeight = '400px';
              iframe.style.border = 'none';
              iframe.style.display = 'block';
              iframe.style.position = 'absolute';
              iframe.style.top = '0';
              iframe.style.left = '0';
              if (!primaryVideoWrapper.style.height || primaryVideoWrapper.style.height === '0px') {
                primaryVideoWrapper.style.height = '500px';
              }
              // Update iframe dimensions for larger display
              const player = players[index];
              if (player && player.setSize) {
                try {
                  player.setSize(window.innerWidth * 0.6, 500);
                } catch (e) {
                  console.warn('Could not resize player:', e);
                }
              }
            }
          }, 500);
        }
      }
      
      // Update info
      const detectedGenre = trackGenres[index] || 'electronic';
      primaryVideoInfo.innerHTML = `
        <div class="video-title">${item.snippet.title}</div>
        <div class="video-channel">${item.snippet.channelTitle}</div>
        <div class="video-genre">${detectedGenre.toUpperCase()}</div>
      `;
      
      // Setup controls
      setupPrimaryControls(index);
      
      // Update play button state if video is already playing
      if (player && player.getPlayerState) {
        try {
          const state = player.getPlayerState();
          updatePlayButton(index, state);
        } catch (e) {
          console.warn('Could not get player state:', e);
        }
      }
    }
    
    // Setup controls for primary video
    function setupPrimaryControls(index) {
      const primaryControls = document.getElementById('primaryControls');
      if (!primaryControls) return;
      
      primaryControls.innerHTML = '';
      
      // Play button
      const playButton = document.createElement('button');
      playButton.className = 'play-button';
      playButton.id = `primaryPlayBtn${index}`;
      playButton.innerHTML = getSVGIcon('play');
      playButton.onclick = () => togglePlay(index);
      playButton.style.cssText = 'padding: 12px 24px; font-size: 16px; margin-bottom: 16px;';
      
      // Volume
      const volumeGroup = document.createElement('div');
      volumeGroup.className = 'control-group';
      volumeGroup.innerHTML = `
        <span class="control-icon">${getSVGIcon('volume')}</span>
        <div class="slider-container" style="flex: 1;">
          <input type="range" class="slider" id="primaryVolume${index}" min="0" max="100" value="50">
        </div>
        <span class="control-value" id="primaryVolumeValue${index}">50%</span>
      `;
      
      // Speed
      const speedGroup = document.createElement('div');
      speedGroup.className = 'control-group';
      speedGroup.innerHTML = `
        <span class="control-icon">${getSVGIcon('speed')}</span>
        <div class="slider-container" style="flex: 1;">
          <input type="range" class="slider" id="primarySpeed${index}" min="0.25" max="2" step="0.05" value="1">
        </div>
        <span class="control-value" id="primarySpeedValue${index}">1.0x</span>
      `;
      
      // Pitch
      const pitchGroup = document.createElement('div');
      pitchGroup.className = 'control-group';
      pitchGroup.innerHTML = `
        <span class="control-icon">${getSVGIcon('pitch')}</span>
        <div class="slider-container" style="flex: 1;">
          <input type="range" class="slider" id="primaryPitch${index}" min="-12" max="12" step="1" value="0">
        </div>
        <span class="control-value" id="primaryPitchValue${index}">0</span>
      `;
      
      primaryControls.appendChild(playButton);
      primaryControls.appendChild(volumeGroup);
      primaryControls.appendChild(speedGroup);
      primaryControls.appendChild(pitchGroup);
      
      // Connect controls to existing player
      const player = players[index];
      if (player) {
        // Volume
        const volSlider = document.getElementById(`primaryVolume${index}`);
        const volValue = document.getElementById(`primaryVolumeValue${index}`);
        if (volSlider && volValue) {
          volSlider.addEventListener('input', function() {
            player.setVolume(parseInt(this.value));
            volValue.textContent = this.value + '%';
          });
        }
        
        // Speed
        const speedSlider = document.getElementById(`primarySpeed${index}`);
        const speedValue = document.getElementById(`primarySpeedValue${index}`);
        if (speedSlider && speedValue) {
          speedSlider.addEventListener('input', function() {
            const speed = parseFloat(this.value);
            const pitchMultiplier = Math.pow(2, (trackPitch[index] || 0) / 12);
            player.setPlaybackRate(speed * pitchMultiplier);
            speedValue.textContent = speed.toFixed(2) + 'x';
          });
        }
        
        // Pitch
        const pitchSlider = document.getElementById(`primaryPitch${index}`);
        const pitchValue = document.getElementById(`primaryPitchValue${index}`);
        if (pitchSlider && pitchValue) {
          pitchSlider.addEventListener('input', function() {
            const pitchSemitones = parseInt(this.value);
            trackPitch[index] = pitchSemitones;
            const speed = parseFloat(speedSlider.value) || 1.0;
            const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
            player.setPlaybackRate(speed * pitchMultiplier);
            pitchValue.textContent = pitchSemitones > 0 ? '+' + pitchSemitones : pitchSemitones.toString();
          });
        }
      }
    }

    // Videos now automatically advance when each one ends (no timer needed)
  </script>
</body>
</html>

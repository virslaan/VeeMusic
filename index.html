<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta http-equiv="Permissions-Policy" content="autoplay=*, encrypted-media=*, picture-in-picture=*, accelerometer=*, gyroscope=*, clipboard-write=*, web-share=*">
  <title>VeeMusic DJ - Professional DJ Mixing Experience</title>
  <meta name="copyright" content="¬© 2025 VIPUL RULES. All rights reserved.">
  <meta name="author" content="VIPUL RULES">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000000;
      color: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', Arial, sans-serif;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      position: relative;
      transition: background 0.5s ease;
      -webkit-overflow-scrolling: touch;
    }

    .background-videos {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      overflow: hidden;
      background: #000000;
    }

    .background-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 1s ease-in-out;
      display: block;
    }

    .background-video.active {
      opacity: 1;
      z-index: 1;
    }

    .background-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: -1;
      pointer-events: none;
      transition: background 0.3s ease;
    }

    .background-overlay.search-active {
      background: rgba(0, 0, 0, 0.85);
    }

    .container {
      flex: 1;
      display: flex;
      flex-direction: column;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      padding: 20px;
      overflow: visible;
      position: relative;
      z-index: 10;
      min-height: 100vh;
    }

    body.copilot-active {
      animation: clubLights 3s ease infinite;
    }

    @keyframes clubLights {
      0% {
        background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
      }
      25% {
        background: linear-gradient(135deg, #fb5607 0%, #ff006e 50%, #8338ec 100%);
      }
      50% {
        background: linear-gradient(135deg, #ffbe0b 0%, #fb5607 50%, #ff006e 100%);
      }
      75% {
        background: linear-gradient(135deg, #06ffa5 0%, #ffbe0b 50%, #fb5607 100%);
      }
      100% {
        background: linear-gradient(135deg, #3a86ff 0%, #06ffa5 50%, #ffbe0b 100%);
      }
    }


    header {
      flex-shrink: 0;
      margin-bottom: 24px;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 2px;
      letter-spacing: -0.3px;
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      font-weight: 400;
      margin-bottom: 4px;
    }

    .instruction-text {
      color: rgba(255, 255, 255, 0.5);
      font-size: 11px;
      font-weight: 400;
      line-height: 1.4;
      margin-top: 6px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .search-section {
      flex-shrink: 0;
      margin-bottom: 20px;
    }

    #searchForm {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #searchQuery {
      flex: 1;
      padding: 10px 14px;
      font-size: 15px;
      font-weight: 400;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: #ffffff;
      outline: none;
      transition: all 0.2s ease;
    }

    #searchQuery::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #searchQuery:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    #searchButton {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.95);
      border: none;
      border-radius: 6px;
      color: #000000;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #searchButton:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    .copilot-section {
      flex-shrink: 0;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    #copilotButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #copilotButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #copilotButton.active {
      background: #ffffff;
      color: #000000;
      border-color: #ffffff;
    }

    #beatDropButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
    }

    #beatDropButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #beatDropButton.active {
      background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
      color: #ffffff;
      border-color: transparent;
      animation: pulse 1.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 0, 110, 0.7);
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 20px 5px rgba(255, 0, 110, 0.4);
      }
    }

    #lockButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #lockButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #lockButton.unlocked {
      background: linear-gradient(135deg, #06ffa5 0%, #3a86ff 100%);
      border-color: transparent;
      animation: pulse 2s ease infinite;
    }

    #lockButton.unlocked #lockText::after {
      content: " - JAM with DJ VEE";
    }

    #spacebarButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #spacebarButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #spacebarButton.active {
      background: linear-gradient(135deg, #ff006e 0%, #8338ec 100%);
      border-color: transparent;
      animation: pulse 1s ease infinite;
    }

    #voiceButton {
      padding: 10px 20px;
      font-size: 13px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #voiceButton:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    #voiceButton.recording {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.5);
      animation: pulse 1s ease infinite;
    }

    #voiceButton.playing {
      background: rgba(0, 255, 0, 0.2);
      border-color: rgba(0, 255, 0, 0.4);
    }

    #voiceIcon {
      width: 18px;
      height: 18px;
      display: inline-block;
    }

    #voiceIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    #lockIcon {
      width: 18px;
      height: 18px;
      display: inline-block;
    }

    #lockIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .add-more-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tts-section {
      margin-top: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .tts-prefill {
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tts-prefill:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
    }

    #ttsIcon {
      width: 16px;
      height: 16px;
      display: inline-block;
    }

    #ttsIcon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    #ttsInput::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #ttsInput:focus {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.05);
    }

    #addMoreQuery::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    #addMoreQuery:focus {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    #results {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      overflow: visible;
      padding: 0;
      padding-bottom: 20px;
      min-height: 0;
    }

    #results::-webkit-scrollbar {
      width: 6px;
    }

    #results::-webkit-scrollbar-track {
      background: transparent;
    }

    #results::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    #results::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .video-card {
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.02);
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      opacity: 0;
      transform: translateY(20px);
      animation: fadeInUp 0.6s ease forwards;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      position: relative;
    }

    .close-button {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: none;
      color: rgba(255, 255, 255, 0.7);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: all 0.2s ease;
      padding: 0;
      opacity: 0.7;
    }

    .close-button svg {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .close-button:hover {
      background: rgba(255, 0, 0, 0.8);
      color: #ffffff;
      transform: scale(1.1);
      opacity: 1;
    }

    .beat-indicator {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      z-index: 50;
      transition: all 0.1s ease;
    }

    .beat-indicator.active {
      background: #06ffa5;
      box-shadow: 0 0 8px #06ffa5;
      transform: scale(1.4);
    }

    .eq-controls {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }

    .eq-control {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .eq-label {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.6);
      font-weight: 600;
      text-transform: uppercase;
      cursor: help;
    }

    .cue-buttons-group {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      justify-content: center;
    }

    .cue-number-btn {
      width: 32px;
      height: 32px;
      padding: 0;
      font-size: 12px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cue-number-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .cue-number-btn.active {
      background: #3a86ff;
      border-color: #3a86ff;
      transform: scale(1.1);
    }

    .eq-slider {
      width: 100%;
      height: 60px;
      -webkit-appearance: slider-vertical;
      appearance: slider-vertical;
      writing-mode: bt-lr;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      outline: none;
      cursor: pointer;
    }

    .cue-point-button {
      padding: 4px 8px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .cue-point-button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .cue-point-button.active {
      background: #3a86ff;
      border-color: #3a86ff;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .video-card:nth-child(1) {
      animation-delay: 0.1s;
    }

    .video-card:nth-child(2) {
      animation-delay: 0.2s;
    }

    .video-card:nth-child(3) {
      animation-delay: 0.3s;
    }

    .video-card:nth-child(4) {
      animation-delay: 0.4s;
    }

    .video-card.disabled {
      opacity: 0.6;
      pointer-events: none;
    }

    .video-card.disabled .play-button,
    .video-card.disabled .slider {
      cursor: not-allowed;
      opacity: 0.5;
    }

    .video-card:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.1);
    }

    .video-card.playing {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.06);
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%;
      background: #0a0a0a;
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .video-wrapper video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 20px;
    }

    .video-wrapper > div {
      border-radius: 20px;
      overflow: hidden;
    }

    .video-wrapper > div {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .video-wrapper iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .video-info {
      margin-bottom: 10px;
      flex-shrink: 0;
    }

    .video-title {
      font-size: 12px;
      font-weight: 500;
      color: #ffffff;
      margin-bottom: 2px;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-channel {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      font-weight: 400;
    }

    .video-genre {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.5);
      font-weight: 500;
      margin-top: 3px;
      padding: 2px 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
      display: inline-block;
      letter-spacing: 0.3px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-shrink: 0;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-icon {
      width: 20px;
      height: 20px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.7;
    }

    .control-icon svg {
      width: 100%;
      height: 100%;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
    }

    .control-value {
      font-size: 11px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.8);
      min-width: 40px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .slider-container {
      flex: 1;
      position: relative;
    }

    .slider {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .slider:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      transition: all 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      border: none;
    }

    .play-button {
      width: 100%;
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #ffffff;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .play-button svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: currentColor;
      stroke-width: 0;
    }

    .play-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .play-button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .play-button.playing {
      background: rgba(6, 255, 165, 0.2);
      border-color: rgba(6, 255, 165, 0.4);
      color: #06ffa5;
    }

    .loading {
      text-align: center;
      padding: 40px 20px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 14px;
      font-weight: 400;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: rgba(255, 255, 255, 0.6);
    }

    .empty-state p {
      font-size: 14px;
      margin-top: 12px;
    }

    @media (max-width: 768px) {
      body {
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .container {
        padding: 12px;
        min-height: auto;
      }

      #results {
        grid-template-columns: 1fr;
        gap: 12px;
        padding-bottom: 40px;
      }

      #searchForm {
        flex-direction: column;
        gap: 8px;
      }

      #searchButton {
        width: 100%;
        padding: 12px;
      }

      #searchQuery {
        width: 100%;
        padding: 12px;
        font-size: 16px; /* Prevents zoom on iOS */
      }

      h1 {
        font-size: 24px;
        margin-bottom: 8px;
      }

      .subtitle {
        font-size: 12px;
      }

      .instruction-text {
        font-size: 11px;
        padding: 10px;
        margin-top: 8px;
      }

      .video-card {
        padding: 12px;
        border-radius: 16px;
      }

      .video-wrapper {
        border-radius: 16px;
        margin-bottom: 10px;
      }

      .video-title {
        font-size: 12px;
      }

      .video-channel {
        font-size: 11px;
      }

      .video-genre {
        font-size: 9px;
        padding: 2px 5px;
      }

      .controls {
        gap: 8px;
      }

      .control-group {
        gap: 6px;
      }

      .control-icon {
        font-size: 12px;
        width: 20px;
      }

      .control-value {
        font-size: 10px;
        min-width: 35px;
      }

      .slider {
        height: 6px;
      }

      .slider::-webkit-slider-thumb {
        width: 16px;
        height: 16px;
      }

      .play-button {
        padding: 10px;
        font-size: 14px;
      }

      header {
        margin-bottom: 16px;
      }

      .search-section {
        margin-bottom: 16px;
      }

      .copilot-section {
        margin-bottom: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      #copilotButton {
        width: 100%;
        padding: 12px;
      }

      #beatDropButton {
        width: 100%;
        padding: 12px;
        margin-left: 0 !important;
      }

      #lockButton {
        width: 100%;
        padding: 12px;
        margin-left: 0 !important;
      }

      .add-more-section {
        margin-top: 16px;
        padding-top: 16px;
      }

      #addMoreForm {
        flex-direction: column;
        gap: 8px;
      }

      #addMoreButton {
        width: 100%;
      }

      .close-button {
        width: 32px;
        height: 32px;
        font-size: 22px;
        top: 8px;
        right: 8px;
      }

      .beat-indicator {
        width: 10px;
        height: 10px;
        top: 8px;
        left: 8px;
      }

      .eq-controls {
        flex-direction: row;
        gap: 4px;
        padding: 6px;
      }

      .eq-slider {
        height: 50px;
      }

      .cue-point-button {
        font-size: 9px;
        padding: 3px 6px;
      }

      footer {
        margin-top: 30px;
        padding: 16px;
      }

      .tts-section {
        margin-top: 12px;
        padding: 10px;
      }

      .tts-prefill {
        font-size: 10px;
        padding: 5px 10px;
      }

      #ttsInput {
        font-size: 12px;
        padding: 8px 10px;
      }

      #ttsButton {
        font-size: 12px;
        padding: 8px 12px;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 10px;
      }

      h1 {
        font-size: 20px;
      }

      .video-card {
        padding: 10px;
      }

      .control-group label {
        font-size: 11px;
      }

      .control-group input[type="checkbox"] {
        width: 18px;
        height: 18px;
      }
    }

    video {
      display: none;
    }

    #overlay {
      display: none;
    }
  </style>
</head>
<body>
  <video id="webcam" autoplay playsinline></video>
  <div id="overlay"></div>

  <div class="background-videos" id="backgroundVideos"></div>
  <div class="background-overlay"></div>

  <div class="container">
    <header>
  <h1>VeeMusic DJ</h1>
      <p class="subtitle">Professional DJ Mixing Experience</p>
      <p class="instruction-text">Search video, enter and press the DJ Vee take care and use the controls to feel the dj already</p>
      <p class="eq-explanation" style="font-size: 10px; color: rgba(255, 255, 255, 0.4); margin-top: 6px; padding: 6px; background: rgba(255, 255, 255, 0.02); border-radius: 4px; text-align: center;">
        <strong>EQ Controls:</strong> Low (Bass) ‚Ä¢ Mid (Vocals) ‚Ä¢ High (Treble) - Adjust frequency ranges for better mixing
      </p>
      <p class="copyright-notice" style="font-size: 9px; color: rgba(255, 255, 255, 0.3); margin-top: 4px; text-align: center;">¬© 2025 VIPUL RULES. All rights reserved.</p>
    </header>

    <div class="search-section">
  <form id="searchForm">
        <input 
          type="text" 
          id="searchQuery" 
          placeholder="Search songs, artists..."
          autocomplete="off"
        >
    <button type="submit" id="searchButton">Search</button>
  </form>
    </div>

    <div class="copilot-section">
      <button id="copilotButton">DJ VEE</button>
      <button id="beatDropButton" style="margin-left: 10px;">Beat Drop Mix</button>
      <button id="lockButton" style="margin-left: 10px; display: none;" title="Lock/Unlock DJ VEE for manual mixing">
        <span id="lockIcon"></span>
        <span id="lockText" style="margin-left: 5px;">Lock</span>
      </button>
      <button id="voiceButton" style="margin-left: 10px;" title="Record and play your voice">
        <span id="voiceIcon"></span>
        <span id="voiceText" style="margin-left: 5px;">Voice</span>
      </button>
      <button id="spacebarButton" style="margin-left: 10px;" title="Press Spacebar: Play current track and fade up/down for mixing">
        <span id="spacebarIcon"></span>
        <span id="spacebarText" style="margin-left: 5px;">Spacebar</span>
      </button>
    </div>

    <div class="tts-section" id="ttsSection" style="display: none; margin-top: 12px; padding: 12px; background: rgba(255, 255, 255, 0.02); border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.05);">
      <div style="display: flex; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
        <button class="tts-prefill" data-text="Let's go!">Let's go!</button>
        <button class="tts-prefill" data-text="Drop the beat!">Drop the beat!</button>
        <button class="tts-prefill" data-text="This is DJ VEE!">DJ VEE!</button>
        <button class="tts-prefill" data-text="Feel the music!">Feel the music!</button>
        <button class="tts-prefill" data-text="Energy rising!">Energy rising!</button>
        <button class="tts-prefill" data-text="Here we go!">Here we go!</button>
      </div>
      <div style="display: flex; gap: 8px; align-items: center;">
        <input 
          type="text" 
          id="ttsInput" 
          placeholder="Type text to speak..."
          style="flex: 1; padding: 8px 12px; font-size: 13px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; background: rgba(255, 255, 255, 0.03); color: #ffffff; outline: none;"
        >
        <button id="ttsButton" style="padding: 8px 16px; font-size: 13px; font-weight: 500; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 6px; color: #ffffff; cursor: pointer; min-height: 36px;">
          <span id="ttsIcon"></span>
          <span style="margin-left: 5px;">Speak</span>
        </button>
      </div>
    </div>

  <div id="results"></div>

  <div class="add-more-section" id="addMoreSection" style="display: none;">
    <form id="addMoreForm" style="display: flex; gap: 10px; align-items: center;">
      <input 
        type="text" 
        id="addMoreQuery" 
        placeholder="Search more songs to add..."
        autocomplete="off"
        style="flex: 1; padding: 10px 14px; font-size: 15px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; background: rgba(255, 255, 255, 0.05); color: #ffffff; outline: none;"
      >
      <button type="submit" id="addMoreButton" style="padding: 10px 20px; font-size: 20px; font-weight: 600; background: #ffffff; border: none; border-radius: 8px; color: #000000; cursor: pointer; min-width: 50px; min-height: 44px;">+</button>
    </form>
  </div>

  <footer style="margin-top: 40px; padding: 20px; text-align: center; border-top: 1px solid rgba(255, 255, 255, 0.1);">
    <p style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px;">
      ¬© 2025 VIPUL RULES. All rights reserved.
    </p>
    <p style="font-size: 11px; color: rgba(255, 255, 255, 0.4);">
      Professional DJ Mixing Experience | VeeMusic DJ
    </p>
  </footer>
  </div>

  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // SVG Icon Functions - Minimalistic Design
    function getSVGIcon(type) {
      const icons = {
        volume: '<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>',
        speed: '<svg viewBox="0 0 24 24"><path d="M13 3L4 14h7v7l9-11h-7V3z"/></svg>',
        pitch: '<svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>',
        loop: '<svg viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>',
        close: '<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>',
        lock: '<svg viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>',
        unlock: '<svg viewBox="0 0 24 24"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H8.9V6z"/></svg>',
        mic: '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>',
        speaker: '<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>',
        cue: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
        tts: '<svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>',
        play: '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>',
        pause: '<svg viewBox="0 0 24 24"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>',
        spacebar: '<svg viewBox="0 0 24 24"><path d="M4 9h16v2H4V9zm0 4h16v2H4v-2z"/></svg>'
      };
      return icons[type] || '';
    }

    let players = [];
    let voiceRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];
    let voiceAudio = null;
    let voiceStream = null;
    let ttsVoices = [];
    let selectedVoice = null;
    let ttsQueue = [];
    let isTTSPlaying = false;
    let videoData = [];
    let ytApiReady = false;
    let copilotActive = false;
    let copilotInterval = null;
    let beatDropActive = false;
    let beatDropInterval = null;
    let djVeeLocked = true; // Lock state for DJ VEE (locked = no manual mixing, unlocked = allow manual mixing)
    let currentPlayingIndex = -1;
    let currentFocusedIndex = 0; // Track focused for spacebar control
    let trackHistory = [];
    let trackPlayCount = {};
    let spacebarFadeInterval = null;
    let lastMixTime = 0;
    let mixIntensity = 0.5; // 0 = calm, 1 = intense
    let autoPlayActive = true;
    let autoPlayInterval = null;
    let readyPlayers = [];
    let userInteracted = false;
    let localVideos = ['bg.mp4', 'bg2.mp4', 'bg3.mp4'];
    let localVideoElements = [];
    let backgroundVideoStarted = false;
    let trackLoops = {}; // Track loop state for each player
    let loopIntervals = {}; // Store loop interval IDs
    let loopStartTimes = {}; // Store loop start times
    let loopEndTimes = {}; // Store loop end times
    let loopPatterns = {}; // Store loop patterns for each player (e.g., "x xx xxx")
    let loopPatternIndex = {}; // Current position in pattern
    let loopSegmentLooped = {}; // Track if current segment has looped back
    let trackPitch = {}; // Track pitch offset for each player (in semitones)
    let trackGenres = {}; // Track genre for each player
    let genreProfiles = {}; // Genre-specific mixing profiles
    let trackEQ = {}; // Track EQ settings: {low: -12 to 12, mid: -12 to 12, high: -12 to 12}
    let cuePoints = {}; // Cue points for each track: {[index]: {1: time, 2: time, 3: time, 4: time, 5: time}}
    let beatIndicators = {}; // Beat indicator intervals
    let trackBPM = {}; // Estimated BPM for each track

    // Check if running via file:// protocol (YouTube requires HTTP/HTTPS)
    if (window.location.protocol === 'file:') {
      console.warn('‚ö†Ô∏è File opened via file:// protocol. YouTube API works best over HTTP/HTTPS.');
      console.warn('üí° To fix: Use a local server like "python -m http.server" or "npx serve"');
      
      // Show user-friendly warning
      setTimeout(() => {
        const warning = document.createElement('div');
        warning.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #ff6b6b; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
        warning.innerHTML = `
          <strong>‚ö†Ô∏è Protocol Warning</strong><br>
          <small>For best results, serve this file over HTTP/HTTPS.<br>
          Use: <code>python -m http.server</code> or <code>npx serve</code></small>
          <button onclick="this.parentElement.remove()" style="margin-top: 8px; padding: 4px 8px; background: white; color: #ff6b6b; border: none; border-radius: 4px; cursor: pointer;">Dismiss</button>
        `;
        document.body.appendChild(warning);
      }, 1000);
    }

    window.onYouTubeIframeAPIReady = function() {
      ytApiReady = true;
    }

    // Genre detection based on title, description, and keywords
    function detectGenre(item) {
      const title = (item.snippet.title || '').toLowerCase();
      const description = (item.snippet.description || '').toLowerCase();
      const channel = (item.snippet.channelTitle || '').toLowerCase();
      const text = title + ' ' + description + ' ' + channel;
      
      // Genre keywords with weights
      const genreKeywords = {
        'house': ['house', 'deep house', 'tech house', 'progressive house', 'future house', 'bass house'],
        'techno': ['techno', 'hard techno', 'minimal techno', 'acid techno', 'industrial techno'],
        'trance': ['trance', 'uplifting trance', 'progressive trance', 'psytrance', 'vocal trance'],
        'dubstep': ['dubstep', 'riddim', 'brostep', 'future bass', 'trap'],
        'drumandbass': ['drum and bass', 'dnb', 'jungle', 'liquid dnb', 'neurofunk'],
        'hiphop': ['hip hop', 'hiphop', 'rap', 'trap', 'drill', 'grime'],
        'edm': ['edm', 'electronic', 'big room', 'festival', 'drop', 'bass boosted', 'bass boost', 'remix', 'remixes', 'tomorrowland', 'ultra', 'david guetta', 'martin garrix', 'tiesto', 'avicii', 'axwell', 'meduza', 'gigi d\'agostino', 'dj mix', 'music mix'],
        'pop': ['pop', 'top 40', 'mainstream', 'radio'],
        'rock': ['rock', 'metal', 'punk', 'alternative', 'indie rock'],
        'reggae': ['reggae', 'dancehall', 'dub', 'ska'],
        'jazz': ['jazz', 'smooth jazz', 'bebop', 'fusion'],
        'classical': ['classical', 'orchestral', 'symphony', 'concerto'],
        'ambient': ['ambient', 'chill', 'lounge', 'downtempo'],
        'country': ['country', 'bluegrass', 'folk'],
        'r&b': ['r&b', 'rnb', 'soul', 'neo soul']
      };
      
      let genreScores = {};
      
      // Score each genre
      Object.keys(genreKeywords).forEach(genre => {
        genreScores[genre] = 0;
        genreKeywords[genre].forEach(keyword => {
          const regex = new RegExp(keyword, 'gi');
          const matches = text.match(regex);
          if (matches) {
            genreScores[genre] += matches.length;
          }
        });
      });
      
      // Find highest scoring genre
      let maxScore = 0;
      let detectedGenre = 'electronic'; // default
      
      Object.keys(genreScores).forEach(genre => {
        if (genreScores[genre] > maxScore) {
          maxScore = genreScores[genre];
          detectedGenre = genre;
        }
      });
      
      // If no strong match, use default
      if (maxScore === 0) {
        detectedGenre = 'electronic';
      }
      
      return detectedGenre;
    }

    // Genre-specific mixing profiles
    function initializeGenreProfiles() {
      genreProfiles = {
        'house': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.5,
          crossfadeDuration: 3000,
          mixingStyle: 'smooth',
          variations: ['longCrossfade', 'beatMatch', 'harmonicMix']
        },
        'techno': {
          tempo: { min: 0.98, max: 1.02, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 50, max: 80, preferred: 65 },
          loopChance: 0.7,
          crossfadeDuration: 4000,
          mixingStyle: 'seamless',
          variations: ['longCrossfade', 'beatMatch', 'layerBuild', 'minimalVariation']
        },
        'trance': {
          tempo: { min: 0.97, max: 1.03, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 40, max: 85, preferred: 70 },
          loopChance: 0.4,
          crossfadeDuration: 5000,
          mixingStyle: 'epic',
          variations: ['buildUp', 'drop', 'longCrossfade', 'pitchShift']
        },
        'dubstep': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -4, max: 4, preferred: 0 },
          volume: { min: 55, max: 90, preferred: 75 },
          loopChance: 0.3,
          crossfadeDuration: 2000,
          mixingStyle: 'aggressive',
          variations: ['quickCut', 'drop', 'pitchShift', 'volumeSpike']
        },
        'drumandbass': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 50, max: 80, preferred: 70 },
          loopChance: 0.6,
          crossfadeDuration: 2500,
          mixingStyle: 'energetic',
          variations: ['quickCut', 'beatMatch', 'layerBuild', 'tempoMatch']
        },
        'hiphop': {
          tempo: { min: 0.85, max: 1.15, preferred: 1.0 },
          pitch: { min: -6, max: 6, preferred: 0 },
          volume: { min: 45, max: 85, preferred: 65 },
          loopChance: 0.8,
          crossfadeDuration: 1500,
          mixingStyle: 'creative',
          variations: ['scratch', 'quickCut', 'pitchShift', 'loopMash']
        },
        'edm': {
          tempo: { min: 0.92, max: 1.08, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 50, max: 90, preferred: 75 },
          loopChance: 0.4,
          crossfadeDuration: 3000,
          mixingStyle: 'festival',
          variations: ['buildUp', 'drop', 'longCrossfade', 'volumeSpike']
        },
        'pop': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 40, max: 80, preferred: 60 },
          loopChance: 0.2,
          crossfadeDuration: 2000,
          mixingStyle: 'smooth',
          variations: ['smoothCrossfade', 'fadeOut', 'simpleTransition']
        },
        'rock': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 55, max: 90, preferred: 75 },
          loopChance: 0.1,
          crossfadeDuration: 2000,
          mixingStyle: 'powerful',
          variations: ['hardCut', 'volumeSpike', 'fadeOut']
        },
        'reggae': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 45, max: 70, preferred: 55 },
          loopChance: 0.6,
          crossfadeDuration: 4000,
          mixingStyle: 'laidback',
          variations: ['longCrossfade', 'smoothTransition', 'beatMatch']
        },
        'jazz': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 40, max: 70, preferred: 55 },
          loopChance: 0.3,
          crossfadeDuration: 5000,
          mixingStyle: 'smooth',
          variations: ['longCrossfade', 'harmonicMix', 'smoothTransition']
        },
        'classical': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -1, max: 1, preferred: 0 },
          volume: { min: 35, max: 65, preferred: 50 },
          loopChance: 0.1,
          crossfadeDuration: 6000,
          mixingStyle: 'elegant',
          variations: ['longCrossfade', 'fadeOut', 'smoothTransition']
        },
        'ambient': {
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 30, max: 60, preferred: 45 },
          loopChance: 0.9,
          crossfadeDuration: 8000,
          mixingStyle: 'atmospheric',
          variations: ['longCrossfade', 'layerBuild', 'smoothTransition']
        },
        'country': {
          tempo: { min: 0.9, max: 1.1, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.2,
          crossfadeDuration: 2500,
          mixingStyle: 'natural',
          variations: ['smoothCrossfade', 'fadeOut', 'simpleTransition']
        },
        'r&b': {
          tempo: { min: 0.92, max: 1.08, preferred: 1.0 },
          pitch: { min: -3, max: 3, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.5,
          crossfadeDuration: 3000,
          mixingStyle: 'smooth',
          variations: ['smoothCrossfade', 'harmonicMix', 'beatMatch']
        },
        'electronic': { // Default fallback
          tempo: { min: 0.95, max: 1.05, preferred: 1.0 },
          pitch: { min: -2, max: 2, preferred: 0 },
          volume: { min: 45, max: 75, preferred: 60 },
          loopChance: 0.4,
          crossfadeDuration: 3000,
          mixingStyle: 'balanced',
          variations: ['smoothCrossfade', 'beatMatch', 'harmonicMix']
        }
      };
    }

    // Initialize genre profiles on load
    initializeGenreProfiles();

    function displayResults(data) {
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '';

      // Ensure background videos are stopped when showing search results
      stopBackgroundVideos();

      if (!data.items || data.items.length === 0) {
        resultsDiv.innerHTML = `
          <div class="empty-state">
            <p>No results found. Try a different search term.</p>
          </div>
        `;
        document.getElementById('copilotButton').style.display = 'none';
        document.getElementById('beatDropButton').style.display = 'none';
        return;
      }

      const limitedItems = data.items.slice(0, 4);
      videoData = limitedItems;
      
      // Clean up all loops before resetting players
      Object.keys(loopIntervals).forEach(index => {
        stopLoop(parseInt(index));
      });
      
      players = [];
      trackLoops = {};
      loopIntervals = {};
      loopStartTimes = {};
      loopEndTimes = {};
      loopPatterns = {};
      loopPatternIndex = {};
      loopSegmentLooped = {};
      trackPitch = {};
      trackGenres = {};
      
      // Detect genres for all tracks
      limitedItems.forEach((item, index) => {
        trackGenres[index] = detectGenre(item);
      });

      if (!ytApiReady && typeof YT === 'undefined') {
        resultsDiv.innerHTML = '<div class="loading">Loading...</div>';
        setTimeout(() => displayResults(data), 500);
        return;
      }

      limitedItems.forEach((item, index) => {
        const videoCard = document.createElement('div');
        videoCard.className = 'video-card';
        videoCard.id = `card${index}`;
        videoCard.style.animationDelay = `${index * 0.1}s`;
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.className = 'close-button';
        closeButton.innerHTML = getSVGIcon('close');
        closeButton.title = 'Remove this song';
        closeButton.onclick = () => removeSong(index);
        
        // Add beat indicator
        const beatIndicator = document.createElement('div');
        beatIndicator.className = 'beat-indicator';
        beatIndicator.id = `beatIndicator${index}`;
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper';
        const videoDiv = document.createElement('div');
        videoDiv.id = `player${index}`;
        videoWrapper.appendChild(videoDiv);
        
        videoCard.appendChild(closeButton);
        videoCard.appendChild(beatIndicator);
        
        // Use already detected genre
        const detectedGenre = trackGenres[index] || 'electronic';
        
        const videoInfo = document.createElement('div');
        videoInfo.className = 'video-info';
        videoInfo.innerHTML = `
          <div class="video-title">${item.snippet.title}</div>
          <div class="video-channel">${item.snippet.channelTitle}</div>
          <div class="video-genre" id="genre${index}">${detectedGenre.toUpperCase()}</div>
        `;
        
        const controls = document.createElement('div');
        controls.className = 'controls';
        
        const playButton = document.createElement('button');
        playButton.className = 'play-button';
        playButton.id = `playBtn${index}`;
        playButton.innerHTML = getSVGIcon('play');
        playButton.onclick = () => togglePlay(index);
        playButton.title = 'Play/Pause';
        
        const volumeGroup = document.createElement('div');
        volumeGroup.className = 'control-group';
        volumeGroup.innerHTML = `
          <span class="control-icon" title="Volume">${getSVGIcon('volume')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="volume${index}" min="0" max="100" value="50">
          </div>
          <span class="control-value" id="volumeValue${index}">50%</span>
        `;
        
        const speedGroup = document.createElement('div');
        speedGroup.className = 'control-group';
        speedGroup.innerHTML = `
          <span class="control-icon" title="Speed">${getSVGIcon('speed')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="speed${index}" min="0.25" max="2" step="0.05" value="1">
          </div>
          <span class="control-value" id="speedValue${index}">1.0x</span>
        `;
        
        const pitchGroup = document.createElement('div');
        pitchGroup.className = 'control-group';
        pitchGroup.innerHTML = `
          <span class="control-icon" title="Pitch">${getSVGIcon('pitch')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="pitch${index}" min="-12" max="12" step="1" value="0">
          </div>
          <span class="control-value" id="pitchValue${index}">0</span>
        `;
        
        const loopGroup = document.createElement('div');
        loopGroup.className = 'control-group';
        loopGroup.style.flexDirection = 'column';
        loopGroup.style.gap = '6px';
        loopGroup.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
            <span class="control-icon" title="Loop">${getSVGIcon('loop')}</span>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;">
            <input type="checkbox" id="loop${index}" style="cursor: pointer;">
            <span style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Loop</span>
          </label>
          </div>
          <input 
            type="text" 
            id="loopPattern${index}" 
            placeholder="x xx xxx xxxxxx" 
            style="width: 100%; padding: 4px 8px; font-size: 11px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; background: rgba(255, 255, 255, 0.05); color: #ffffff; outline: none; font-family: monospace;"
            title="Loop pattern: each 'x' = 1 second, spaces separate segments"
          >
        `;
        
        // Add numbered cue buttons (1-5)
        const cueButtonsGroup = document.createElement('div');
        cueButtonsGroup.className = 'cue-buttons-group';
        cueButtonsGroup.style.cssText = 'display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;';
        cueButtonsGroup.innerHTML = `
          <button class="cue-number-btn" id="cueBtn${index}_1" title="Set/Jump to Cue 1">1</button>
          <button class="cue-number-btn" id="cueBtn${index}_2" title="Set/Jump to Cue 2">2</button>
          <button class="cue-number-btn" id="cueBtn${index}_3" title="Set/Jump to Cue 3">3</button>
          <button class="cue-number-btn" id="cueBtn${index}_4" title="Set/Jump to Cue 4">4</button>
          <button class="cue-number-btn" id="cueBtn${index}_5" title="Set/Jump to Cue 5">5</button>
        `;
        
        // Add event listeners for cue buttons
        for (let cueNum = 1; cueNum <= 5; cueNum++) {
          const cueBtn = document.getElementById(`cueBtn${index}_${cueNum}`);
          if (cueBtn) {
            cueBtn.addEventListener('click', () => handleCueButton(index, cueNum));
          }
        }
        
        // Add EQ controls
        const eqControls = document.createElement('div');
        eqControls.className = 'eq-controls';
        eqControls.innerHTML = `
          <div class="eq-control">
            <span class="eq-label" title="Low frequencies (Bass, Kick) - Adjust bass and low-end sounds">Low</span>
            <input type="range" class="eq-slider" id="eqLow${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Low frequencies: Bass, kick drums">
            <span class="control-value" id="eqLowValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="Mid frequencies (Vocals, Instruments) - Adjust vocals and mid-range instruments">Mid</span>
            <input type="range" class="eq-slider" id="eqMid${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Mid frequencies: Vocals, instruments">
            <span class="control-value" id="eqMidValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="High frequencies (Treble, Cymbals) - Adjust high-end sounds and clarity">High</span>
            <input type="range" class="eq-slider" id="eqHigh${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="High frequencies: Treble, cymbals">
            <span class="control-value" id="eqHighValue${index}" style="font-size: 9px;">0</span>
          </div>
        `;
        
        controls.appendChild(playButton);
        controls.appendChild(volumeGroup);
        controls.appendChild(speedGroup);
        controls.appendChild(pitchGroup);
        controls.appendChild(loopGroup);
        controls.appendChild(cueButtonsGroup);
        controls.appendChild(eqControls);
        
        videoCard.appendChild(videoWrapper);
        videoCard.appendChild(videoInfo);
        videoCard.appendChild(controls);
        resultsDiv.appendChild(videoCard);
        
        // Initialize track state
        trackEQ[index] = { low: 0, mid: 0, high: 0 };
        cuePoints[index] = {}; // Initialize as object for numbered cues
        trackBPM[index] = 120; // Default BPM, will be estimated

        // Wait for card to be rendered, then calculate proper dimensions
        setTimeout(() => {
          const cardWidth = videoCard.offsetWidth || 280;
          const cardHeight = Math.round(cardWidth * 0.5625); // 16:9 aspect ratio
          
          // Verify videoId exists
          const videoId = item.id?.videoId || item.id;
          if (!videoId) {
            console.error('No video ID found for item:', item);
            return;
          }
          
          // Function to create player
          const createPlayer = () => {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
              console.log('YouTube API not ready, retrying...');
              setTimeout(createPlayer, 200);
              return;
            }
            
            try {
              players[index] = new YT.Player(videoDiv.id, {
                height: cardHeight.toString(),
                width: cardWidth.toString(),
                videoId: videoId,
                playerVars: {
                  modestbranding: 1,
                  rel: 0,
                  showinfo: 0,
                  playsinline: 1,
                  enablejsapi: 1
                },
                events: {
                  'onReady': function(event) {
                    event.target.setVolume(50);
                    setupControls(index);
                    readyPlayers.push(index);
                    
                    // Resize iframe to fill container and set permissions
                    const iframe = videoDiv.querySelector('iframe');
                    if (iframe) {
                      iframe.style.width = '100%';
                      iframe.style.height = '100%';
                      // Add permissions policy to iframe
                      iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture; accelerometer; gyroscope; clipboard-write; web-share');
                      iframe.setAttribute('allowfullscreen', 'true');
                    }
                    
                    // Start auto-play sequence when all players are ready
                    if (readyPlayers.length === limitedItems.length && autoPlayActive && !userInteracted) {
                      startAutoPlaySequence();
                    }
                  },
                  'onStateChange': function(event) {
                    updatePlayButton(index, event.data);
                    
                    // Start loop if enabled and track is playing
                    if (event.data === YT.PlayerState.PLAYING && trackLoops[index]) {
                      startLoop(index);
                    } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                      stopLoop(index);
                    }
                    
                    // Auto-advance to next video when current ends
                    if (autoPlayActive && !userInteracted && event.data === YT.PlayerState.ENDED) {
                      autoAdvanceToNext(index);
                    }
                  },
                  'onError': function(event) {
                    const errorCode = event.data;
                    console.error('YouTube player error:', errorCode);
                    
                    // YouTube error codes:
                    // 2 = Invalid parameter value
                    // 5 = HTML5 player error
                    // 100 = Video not found
                    // 101 = Not allowed to play in embedded players
                    // 150 = Not allowed to play in embedded players
                    // 153 = Not allowed to play in embedded players (specific format)
                    
                    let errorMessage = 'Video unavailable';
                    if (errorCode === 100 || errorCode === 101 || errorCode === 150 || errorCode === 153) {
                      errorMessage = 'Video cannot be embedded';
                    } else if (errorCode === 2) {
                      errorMessage = 'Invalid video';
                    } else if (errorCode === 5) {
                      errorMessage = 'Playback error';
                    }
                    
                    // Show error message on card
                    const videoInfo = videoCard.querySelector('.video-info');
                    if (videoInfo) {
                      const errorDiv = document.createElement('div');
                      errorDiv.style.cssText = 'color: #ff6b6b; font-size: 11px; margin-top: 4px; padding: 4px; background: rgba(255, 107, 107, 0.1); border-radius: 4px;';
                      errorDiv.textContent = errorMessage;
                      videoInfo.appendChild(errorDiv);
                    }
                    
                    videoCard.style.opacity = '0.6';
                    videoCard.style.pointerEvents = 'none';
                    
                    // Disable controls
                    const playButton = document.getElementById(`playBtn${index}`);
                    if (playButton) playButton.disabled = true;
                    const volumeSlider = document.getElementById(`volume${index}`);
                    if (volumeSlider) volumeSlider.disabled = true;
                    const speedSlider = document.getElementById(`speed${index}`);
                    if (speedSlider) speedSlider.disabled = true;
                    const pitchSlider = document.getElementById(`pitch${index}`);
                    if (pitchSlider) pitchSlider.disabled = true;
                    const loopCheckbox = document.getElementById(`loop${index}`);
                    if (loopCheckbox) loopCheckbox.disabled = true;
                    const loopPatternInput = document.getElementById(`loopPattern${index}`);
                    if (loopPatternInput) loopPatternInput.disabled = true;
                  }
                }
              });
            } catch (error) {
              console.error('Error creating YouTube player:', error);
            }
          };
          
          // Start creating player
          createPlayer();
        }, 100);
      });

      if (limitedItems.length > 0) {
        document.getElementById('copilotButton').style.display = 'block';
        document.getElementById('beatDropButton').style.display = 'block';
        document.getElementById('addMoreSection').style.display = 'block';
        document.getElementById('ttsSection').style.display = 'block';
      }
      
      // Reset auto-play state
      readyPlayers = [];
      userInteracted = false;
      autoPlayActive = true;
    }

    function startAutoPlaySequence() {
      if (!autoPlayActive || userInteracted || readyPlayers.length === 0) return;
      
      // Wait for fade-in animation to complete, then start playing
      const animationDelay = readyPlayers.length * 100 + 300; // Wait for all cards to fade in
      setTimeout(() => {
        if (autoPlayActive && !userInteracted) {
          const firstIndex = readyPlayers[0];
          // Check if using local videos or YouTube
          if (localVideoElements.length > 0) {
            playLocalVideoAuto(firstIndex);
      } else {
            playVideoAuto(firstIndex);
          }
        }
      }, animationDelay);
    }

    function playVideoAuto(index) {
      if (!autoPlayActive || userInteracted) return;
      
      const player = players[index];
      if (!player) return;
      
      // Stop all other videos
      players.forEach((p, i) => {
        if (i !== index && p && p.getPlayerState() === YT.PlayerState.PLAYING) {
          p.pauseVideo();
          updatePlayButton(i, YT.PlayerState.PAUSED);
          const card = document.getElementById(`card${i}`);
          if (card) card.classList.remove('playing');
        }
      });
      
      // Fade in volume for smooth start
      player.setVolume(0);
      player.playVideo();
      
      // Fade in volume over 1 second
      let volumeStep = 0;
      const fadeInterval = setInterval(() => {
        volumeStep += 2;
        if (volumeStep <= 50) {
          player.setVolume(volumeStep);
        } else {
          clearInterval(fadeInterval);
          player.setVolume(50);
        }
      }, 40);
      
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      
      if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
      }
      if (videoCard) {
        videoCard.classList.add('playing');
      }
      
      currentPlayingIndex = index;
    }

    function autoAdvanceToNext(currentIndex) {
      if (!autoPlayActive || userInteracted) return;
      
      // Find next video in sequence
      const currentPos = readyPlayers.indexOf(currentIndex);
      const nextPos = (currentPos + 1) % readyPlayers.length;
      const nextIndex = readyPlayers[nextPos];
      
      // Small delay before next video starts
      setTimeout(() => {
        if (autoPlayActive && !userInteracted) {
          // Check if using local videos or YouTube
          if (localVideoElements.length > 0) {
            playLocalVideoAuto(nextIndex);
          } else {
            playVideoAuto(nextIndex);
          }
        }
      }, 1000);
    }

    function setupControls(index) {
      const player = players[index];
      if (!player) return;

      // Initialize loop state
      trackLoops[index] = false;
      trackPitch[index] = 0;
      loopPatterns[index] = ''; // Default: no pattern (use default loop)
      loopPatternIndex[index] = 0;
      loopSegmentLooped[index] = false;

      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      
      volumeSlider.addEventListener('input', function() {
        if (!this.disabled) {
          // User interaction - stop auto-play
          if (autoPlayActive && !userInteracted) {
            userInteracted = true;
            autoPlayActive = false;
          }
          
          const volume = parseInt(this.value);
          player.setVolume(volume);
          volumeValue.textContent = volume + '%';
        }
      });

      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      speedSlider.addEventListener('input', function() {
        if (!this.disabled) {
          // User interaction - stop auto-play
          if (autoPlayActive && !userInteracted) {
            userInteracted = true;
            autoPlayActive = false;
          }
          
          const speed = parseFloat(this.value);
          // Apply pitch adjustment if any
          const pitchMultiplier = Math.pow(2, trackPitch[index] / 12);
          player.setPlaybackRate(speed * pitchMultiplier);
          speedValue.textContent = speed.toFixed(2) + 'x';
        }
      });

      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      
      if (pitchSlider && pitchValue) {
        pitchSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            const pitchSemitones = parseInt(this.value);
            
            // Update stored pitch value
            trackPitch[index] = pitchSemitones;
            
            // Get base speed from slider (this is the speed without pitch adjustment)
            const baseSpeed = parseFloat(speedSlider.value) || 1.0;
            
            // Calculate pitch multiplier (2^(semitones/12))
            const pitchMultiplier = Math.pow(2, pitchSemitones / 12);
            
            // Apply pitch to base speed
            const newPlaybackRate = baseSpeed * pitchMultiplier;
            
            // Clamp to YouTube's supported range (0.25 to 2.0)
            const clampedRate = Math.max(0.25, Math.min(2.0, newPlaybackRate));
            
            // Apply the new playback rate to the player
            try {
              if (player && typeof player.setPlaybackRate === 'function') {
                player.setPlaybackRate(clampedRate);
              }
            } catch (e) {
              console.error('Error setting playback rate for pitch:', e);
            }
            
            // Display pitch
            if (pitchSemitones === 0) {
              pitchValue.textContent = '0';
            } else if (pitchSemitones > 0) {
              pitchValue.textContent = '+' + pitchSemitones;
            } else {
              pitchValue.textContent = pitchSemitones.toString();
            }
          }
        });
      }

      const loopCheckbox = document.getElementById(`loop${index}`);
      if (loopCheckbox) {
        loopCheckbox.addEventListener('change', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            trackLoops[index] = this.checked;
            if (this.checked) {
              startLoop(index);
            } else {
              stopLoop(index);
            }
          }
        });
      }

      const loopPatternInput = document.getElementById(`loopPattern${index}`);
      if (loopPatternInput) {
        loopPatternInput.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - stop auto-play
            if (autoPlayActive && !userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
            }
            
            const pattern = this.value.trim();
            loopPatterns[index] = pattern;
            loopPatternIndex[index] = 0; // Reset pattern position
            loopSegmentLooped[index] = false; // Reset loop tracking
            
            // If loop is active, restart with new pattern
            if (trackLoops[index]) {
              stopLoop(index);
              setTimeout(() => startLoop(index), 100);
            }
          }
        });
      }

      // Setup EQ controls
      const eqLow = document.getElementById(`eqLow${index}`);
      const eqMid = document.getElementById(`eqMid${index}`);
      const eqHigh = document.getElementById(`eqHigh${index}`);
      const eqLowValue = document.getElementById(`eqLowValue${index}`);
      const eqMidValue = document.getElementById(`eqMidValue${index}`);
      const eqHighValue = document.getElementById(`eqHighValue${index}`);

      if (eqLow && eqLowValue) {
        eqLow.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            trackEQ[index].low = value;
            eqLowValue.textContent = value > 0 ? '+' + value : value;
            // Note: YouTube API doesn't support real-time EQ, but values are stored for reference
            // EQ controls help you visualize frequency adjustments for professional mixing
          }
        });
      }

      if (eqMid && eqMidValue) {
        eqMid.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            trackEQ[index].mid = value;
            eqMidValue.textContent = value > 0 ? '+' + value : value;
          }
        });
      }

      if (eqHigh && eqHighValue) {
        eqHigh.addEventListener('input', function() {
          if (!this.disabled) {
            const value = parseInt(this.value);
            trackEQ[index].high = value;
            eqHighValue.textContent = value > 0 ? '+' + value : value;
          }
        });
      }
    }

    function togglePlay(index) {
      // Allow manual play when DJ VEE is active but unlocked (JAM mode)
      if (copilotActive && djVeeLocked) return; // Don't allow manual play when copilot is active and locked
      
      // User has interacted - stop auto-play
      if (autoPlayActive && !userInteracted) {
        userInteracted = true;
        autoPlayActive = false;
        // Stop any currently playing auto-play video
        players.forEach((p, i) => {
          if (p && p.getPlayerState() === YT.PlayerState.PLAYING && i !== index) {
            p.pauseVideo();
            updatePlayButton(i, YT.PlayerState.PAUSED);
            document.getElementById(`card${i}`).classList.remove('playing');
          }
        });
      }
      
      const player = players[index];
      if (!player) return;

      players.forEach((p, i) => {
        if (i !== index && p && p.getPlayerState() === YT.PlayerState.PLAYING) {
          p.pauseVideo();
          updatePlayButton(i, YT.PlayerState.PAUSED);
          document.getElementById(`card${i}`).classList.remove('playing');
        }
      });

      const state = player.getPlayerState();
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      
      if (state === YT.PlayerState.PLAYING) {
        player.pauseVideo();
        stopLoop(index);
        stopBeatIndicator(index);
        playButton.innerHTML = getSVGIcon('play');
        playButton.classList.remove('playing');
        videoCard.classList.remove('playing');
        currentPlayingIndex = -1;
      } else {
        player.playVideo();
        startBeatIndicator(index);
        if (trackLoops[index]) {
          setTimeout(() => startLoop(index), 500);
        }
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
        videoCard.classList.add('playing');
        currentPlayingIndex = index;
      }
    }

    function updatePlayButton(index, state) {
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      if (!playButton) return;

      if (state === YT.PlayerState.PLAYING) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
        videoCard.classList.add('playing');
        currentPlayingIndex = index;
        startBeatIndicator(index);
      } else {
        playButton.innerHTML = getSVGIcon('play');
        playButton.classList.remove('playing');
        stopBeatIndicator(index);
        if (currentPlayingIndex === index) {
          videoCard.classList.remove('playing');
          currentPlayingIndex = -1;
        }
      }
    }

    function djAlgorithm() {
      if (players.length < 2) return;

      const now = Date.now();
      const timeSinceLastMix = now - lastMixTime;
      
      // Adjust mix intensity based on time
      if (timeSinceLastMix > 15000) {
        mixIntensity = Math.min(1, mixIntensity + 0.1);
      } else if (timeSinceLastMix < 5000) {
        mixIntensity = Math.max(0.3, mixIntensity - 0.1);
      }

      const playingTracks = [];
      const trackStates = [];
      
      players.forEach((player, index) => {
        if (player) {
          const state = player.getPlayerState();
          if (state === YT.PlayerState.PLAYING) {
            playingTracks.push(index);
            trackStates.push({
              index: index,
              volume: player.getVolume(),
              speed: player.getPlaybackRate(),
              playTime: now
            });
            }
          }
        });

      // Smart decision making with multiple factors
      const decision = Math.random();
      const trackCount = playingTracks.length;
      const totalTracks = players.length;
      
      if (trackCount === 0) {
        // No tracks - smart selection (avoid recently played)
        const nextIndex = selectNextTrack();
        startTrackWithDJMix(nextIndex);
      } else if (trackCount === 1) {
        const currentIndex = playingTracks[0];
        const currentState = trackStates[0];
        const currentGenre = trackGenres[currentIndex] || 'electronic';
        const currentProfile = genreProfiles[currentGenre] || genreProfiles['electronic'];
        
        // Genre-aware decision tree with more variations
        const variations = currentProfile.variations || ['smoothCrossfade', 'beatMatch'];
        const variationType = variations[Math.floor(Math.random() * variations.length)];
        
        if (decision < 0.35) {
          // 35% - Crossfade to new track (genre-aware)
          const nextIndex = selectNextTrack([currentIndex], currentGenre);
          crossfadeTracks(currentIndex, nextIndex, mixIntensity);
        } else if (decision < 0.55) {
          // 20% - Enhance current track with genre-specific effects
          enhanceTrackAdvanced(currentIndex, currentState);
        } else if (decision < 0.75) {
          // 20% - Add second track for layering
          const layerIndex = selectNextTrack([currentIndex], currentGenre);
          layerTracks(currentIndex, layerIndex);
        } else if (decision < 0.85) {
          // 10% - Create build-up effect (genre-specific)
          createBuildUp(currentIndex);
        } else if (decision < 0.92) {
          // 7% - Genre-specific variation
          applyGenreVariation(currentIndex, variationType);
        } else {
          // 8% - Quick cut (for aggressive genres)
          if (currentProfile.mixingStyle === 'aggressive' || currentProfile.mixingStyle === 'energetic') {
            quickCutToNext(currentIndex);
          } else {
            createBuildUp(currentIndex);
          }
        }
      } else if (trackCount === 2) {
        // Two tracks playing - balance and mix
        if (decision < 0.4) {
          // 40% - Perfect balance
          perfectBalance(trackStates);
        } else if (decision < 0.7) {
          // 30% - Dynamic mix adjustment
          adjustMixAdvanced(trackStates);
        } else {
          // 30% - Remove one track smoothly
          const toRemove = selectTrackToRemove(trackStates);
          fadeOutTrack(toRemove);
        }
      } else {
        // Multiple tracks - reduce and balance
        if (decision < 0.5) {
          const toRemove = selectTrackToRemove(trackStates);
          fadeOutTrack(toRemove);
        } else {
          adjustMixAdvanced(trackStates);
        }
      }
      
      lastMixTime = now;
    }

    function selectNextTrack(excludeIndices = [], currentGenre = null) {
      // Smart track selection - avoid recently played, consider genre compatibility
      const available = players.map((_, i) => i).filter(i => !excludeIndices.includes(i));
      
      // Genre compatibility groups
      const compatibleGenres = [
        ['house', 'techno', 'trance', 'edm'],
        ['dubstep', 'drumandbass', 'edm'],
        ['hiphop', 'r&b', 'pop'],
        ['rock', 'metal'],
        ['jazz', 'ambient', 'classical'],
        ['reggae', 'dancehall'],
        ['country', 'folk']
      ];
      
      // Prefer tracks that haven't been played recently and are genre-compatible
      const scored = available.map(index => {
        const playCount = trackPlayCount[index] || 0;
        const lastPlayed = trackHistory.filter(h => h.index === index);
        const timeSincePlay = lastPlayed.length > 0 ? Date.now() - lastPlayed[lastPlayed.length - 1].time : Infinity;
        
        const trackGenre = trackGenres[index] || 'electronic';
        
        // Genre compatibility bonus
        let genreBonus = 0;
        if (currentGenre) {
          const isSameGenre = trackGenre === currentGenre;
          const isCompatible = compatibleGenres.some(group => 
            group.includes(currentGenre) && group.includes(trackGenre)
          );
          
          if (isSameGenre) {
            genreBonus = -5; // Prefer same genre
          } else if (isCompatible) {
            genreBonus = -2; // Prefer compatible genres
          } else {
            genreBonus = 3; // Slight penalty for incompatible genres (but still allow variety)
          }
        }
        
        // Lower score = better (less played, longer ago, genre-compatible)
        const score = playCount * 10 - (timeSincePlay / 1000) + genreBonus;
        return { index, score, genre: trackGenre };
      });
      
      // Sort by score and pick from top 3 (adds more randomness while maintaining quality)
      scored.sort((a, b) => a.score - b.score);
      const topTracks = scored.slice(0, Math.min(3, scored.length));
      const selected = topTracks[Math.floor(Math.random() * topTracks.length)];
      
      return selected ? selected.index : available[Math.floor(Math.random() * available.length)];
    }

    function selectTrackToRemove(trackStates) {
      // Remove track with lowest volume or longest playing
      trackStates.sort((a, b) => {
        if (Math.abs(a.volume - b.volume) > 10) {
          return a.volume - b.volume; // Lower volume first
        }
        return b.playTime - a.playTime; // Longer playing first
      });
      return trackStates[0].index;
    }

    function startTrackWithDJMix(index) {
      const player = players[index];
      if (!player) return;

      // Get genre profile
      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      // Genre-based volume
      const volumeRange = profile.volume.max - profile.volume.min;
      const baseVolume = profile.volume.preferred + (mixIntensity - 0.5) * volumeRange * 0.5;
      const initialVolume = Math.max(profile.volume.min, Math.min(profile.volume.max, 
        baseVolume + (Math.random() - 0.5) * volumeRange * 0.3));
      
      // Genre-based speed/tempo
      const tempoRange = profile.tempo.max - profile.tempo.min;
      const initialSpeed = profile.tempo.preferred + (Math.random() - 0.5) * tempoRange;
      
      // Genre-based pitch
      const pitchRange = profile.pitch.max - profile.pitch.min;
      const initialPitch = profile.pitch.preferred + Math.floor((Math.random() - 0.5) * pitchRange);
      trackPitch[index] = initialPitch;
      
      // Apply pitch to speed
      const pitchMultiplier = Math.pow(2, initialPitch / 12);
      const finalSpeed = initialSpeed * pitchMultiplier;
      
      player.setVolume(0);
      player.setPlaybackRate(finalSpeed);
      
      // Update UI
      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      
      if (speedSlider) speedSlider.value = initialSpeed;
      if (speedValue) speedValue.textContent = initialSpeed.toFixed(2) + 'x';
      if (pitchSlider) pitchSlider.value = initialPitch;
      if (pitchValue) {
        if (initialPitch === 0) {
          pitchValue.textContent = '0';
        } else if (initialPitch > 0) {
          pitchValue.textContent = '+' + initialPitch;
        } else {
          pitchValue.textContent = initialPitch.toString();
        }
      }
      
      // Genre-appropriate fade in
      const fadeStyle = profile.mixingStyle === 'aggressive' ? 'quick' : 
                       profile.mixingStyle === 'atmospheric' ? 'slow' : 'normal';
      fadeInTrackAdvanced(index, initialVolume, fadeStyle);
      
      updateTrackUI(index, initialVolume, initialSpeed);
      
      player.playVideo();
      currentPlayingIndex = index;
      
      // Play TTS between tracks if queue has items, or auto-generate
      if (!isTTSPlaying) {
        let ttsText = null;
        if (ttsQueue.length > 0) {
          ttsText = ttsQueue.shift();
        } else if (Math.random() < 0.3) {
          // 30% chance to auto-generate TTS phrase
          ttsText = generateAutoTTSPhrase('trackStart');
        }
        
        if (ttsText) {
          // Play TTS after a short delay - LOUD and MELODIOUS
          setTimeout(() => {
            speakText(ttsText, { 
              volume: 1.0,  // MAXIMUM volume - LOUD
              rate: 0.92,   // Slower for more melodic, musical effect
              pitch: 1.2    // Higher pitch (1.2) for energetic, melodious DJ voice
            });
          }, 2000);
        }
      }
      
      // Genre-based loop chance
      if (Math.random() < profile.loopChance) {
        trackLoops[index] = true;
        const loopCheckbox = document.getElementById(`loop${index}`);
        if (loopCheckbox) {
          loopCheckbox.checked = true;
        }
        // Set loop points after video starts
        setTimeout(() => {
          try {
            const duration = player.getDuration();
            const currentTime = player.getCurrentTime();
            const loopStart = Math.max(0, currentTime);
            // Genre-appropriate loop length
            const loopLength = genre === 'ambient' ? 60 + Math.random() * 40 :
                               genre === 'techno' ? 32 + Math.random() * 16 :
                               genre === 'hiphop' ? 16 + Math.random() * 16 :
                               30 + Math.random() * 20;
            const loopEnd = Math.min(duration, currentTime + loopLength);
            setLoopPoints(index, loopStart, loopEnd);
          } catch (e) {
            console.error('Error setting loop points:', e);
          }
        }, 2000);
      }
      
      // Track history
      trackHistory.push({ index, time: Date.now(), genre });
      trackPlayCount[index] = (trackPlayCount[index] || 0) + 1;
    }

    function crossfadeTracks(fromIndex, toIndex, intensity = 0.5) {
      const fromPlayer = players[fromIndex];
      const toPlayer = players[toIndex];
      if (!fromPlayer || !toPlayer) return;

      // Get genre profiles
      const fromGenre = trackGenres[fromIndex] || 'electronic';
      const toGenre = trackGenres[toIndex] || 'electronic';
      const fromProfile = genreProfiles[fromGenre] || genreProfiles['electronic'];
      const toProfile = genreProfiles[toGenre] || genreProfiles['electronic'];
      
      // Enhanced beat matching - calculate BPM difference and adjust
      const fromBPM = trackBPM[fromIndex] || 120;
      const toBPM = trackBPM[toIndex] || 120;
      const bpmRatio = fromBPM / toBPM;
      
      // Genre-aware fade duration with professional DJ curve
      const baseFadeDuration = (fromProfile.crossfadeDuration + toProfile.crossfadeDuration) / 2;
      const fadeDuration = baseFadeDuration + (1 - intensity) * (baseFadeDuration * 0.5);
      const steps = 50; // More steps for smoother transition
      const stepDuration = fadeDuration / steps;
      let step = 0;

      const fromVolume = fromPlayer.getVolume();
      
      // Genre-based target volume with professional mixing
      const toVolumeRange = toProfile.volume.max - toProfile.volume.min;
      const baseVolume = toProfile.volume.preferred + (intensity - 0.5) * toVolumeRange * 0.5;
      const targetVolume = Math.max(toProfile.volume.min, Math.min(toProfile.volume.max,
        baseVolume + (Math.random() - 0.5) * toVolumeRange * 0.3));
      
      // Enhanced beat matching with BPM synchronization
      const fromSpeed = fromPlayer.getPlaybackRate();
      const fromPitch = trackPitch[fromIndex] || 0;
      
      // Professional beat matching: adjust speed to match BPMs (harmonic mixing)
      const genresMatch = fromGenre === toGenre;
      let pitchVariation;
      if (genresMatch) {
        // Same genre: stay close to current pitch for smooth harmonic transition
        pitchVariation = fromPitch + Math.floor((Math.random() - 0.5) * 2);
      } else {
        // Different genres: can vary more but still consider compatibility
        const compatibleGenres = [
          ['house', 'techno', 'trance'],
          ['dubstep', 'drumandbass', 'edm'],
          ['hiphop', 'r&b', 'pop'],
          ['rock', 'metal'],
          ['jazz', 'ambient', 'classical']
        ];
        const isCompatible = compatibleGenres.some(group => 
          group.includes(fromGenre) && group.includes(toGenre)
        );
        if (isCompatible) {
          pitchVariation = fromPitch + Math.floor((Math.random() - 0.5) * 4);
        } else {
          pitchVariation = toProfile.pitch.preferred + Math.floor((Math.random() - 0.5) * toProfile.pitch.max - toProfile.pitch.min);
        }
      }
      
      const targetPitch = Math.max(toProfile.pitch.min, Math.min(toProfile.pitch.max, pitchVariation));
      trackPitch[toIndex] = targetPitch;
      
      // Professional beat matching: combine BPM ratio with genre-based tempo
      const toTempoRange = toProfile.tempo.max - toProfile.tempo.min;
      let baseTargetSpeed;
      if (genresMatch) {
        // Same genre: match tempo closely with BPM consideration
        baseTargetSpeed = fromSpeed * (0.7 + 0.3 * bpmRatio); // Blend current speed with BPM match
      } else {
        // Different genre: use genre's preferred tempo adjusted for BPM
        const preferredSpeed = toProfile.tempo.preferred + (Math.random() - 0.5) * toTempoRange;
        baseTargetSpeed = preferredSpeed * bpmRatio;
      }
      const clampedSpeed = Math.max(toProfile.tempo.min, Math.min(toProfile.tempo.max, baseTargetSpeed));
      const pitchMultiplier = Math.pow(2, targetPitch / 12);
      const finalSpeed = clampedSpeed * pitchMultiplier;
      
      toPlayer.setVolume(0);
      toPlayer.setPlaybackRate(finalSpeed);
      toPlayer.playVideo();
      
      // Update UI
      const speedSlider = document.getElementById(`speed${toIndex}`);
      const speedValue = document.getElementById(`speedValue${toIndex}`);
      const pitchSlider = document.getElementById(`pitch${toIndex}`);
      const pitchValue = document.getElementById(`pitchValue${toIndex}`);
      
      if (speedSlider) speedSlider.value = clampedSpeed;
      if (speedValue) speedValue.textContent = clampedSpeed.toFixed(2) + 'x';
      if (pitchSlider) pitchSlider.value = targetPitch;
      if (pitchValue) {
        if (targetPitch === 0) {
          pitchValue.textContent = '0';
        } else if (targetPitch > 0) {
          pitchValue.textContent = '+' + targetPitch;
        } else {
          pitchValue.textContent = targetPitch.toString();
        }
      }
      
      updateTrackUI(toIndex, targetVolume, clampedSpeed);
      
      // Genre-based loop chance
      if (Math.random() < toProfile.loopChance) {
        trackLoops[toIndex] = true;
        const loopCheckbox = document.getElementById(`loop${toIndex}`);
        if (loopCheckbox) {
          loopCheckbox.checked = true;
        }
        setTimeout(() => {
          try {
            const duration = toPlayer.getDuration();
            const currentTime = toPlayer.getCurrentTime();
            const loopStart = Math.max(0, currentTime);
            // Genre-appropriate loop length
            const loopLength = toGenre === 'ambient' ? 60 + Math.random() * 40 :
                               toGenre === 'techno' ? 32 + Math.random() * 16 :
                               toGenre === 'hiphop' ? 16 + Math.random() * 16 :
                               25 + Math.random() * 15;
            const loopEnd = Math.min(duration, currentTime + loopLength);
            setLoopPoints(toIndex, loopStart, loopEnd);
          } catch (e) {
            console.error('Error setting loop points:', e);
          }
        }, 2000);
      }

      // Professional DJ crossfade with S-curve (professional mixing curve)
      const fadeInterval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Professional S-curve easing for smooth DJ transitions
        // This creates a more natural fade that DJs use
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress * (3 - 2 * progress) // Smooth acceleration
          : 1 - 2 * (1 - progress) * (1 - progress) * (3 - 2 * (1 - progress)); // Smooth deceleration
        
        // Fade out old track
        const fromNewVolume = fromVolume * (1 - easeProgress);
        fromPlayer.setVolume(Math.max(0, fromNewVolume));
        
        // Fade in new track
        const toNewVolume = targetVolume * easeProgress;
        toPlayer.setVolume(toNewVolume);
        
        if (step >= steps) {
          clearInterval(fadeInterval);
          fromPlayer.pauseVideo();
          toPlayer.setVolume(targetVolume);
          currentPlayingIndex = toIndex;
          
          // Play TTS between tracks if queue has items, or auto-generate
          if (!isTTSPlaying) {
            let ttsText = null;
            if (ttsQueue.length > 0) {
              ttsText = ttsQueue.shift();
            } else if (Math.random() < 0.25) {
              // 25% chance to auto-generate TTS phrase during transition
              const fromGenre = trackGenres[fromIndex] || 'electronic';
              const toGenre = trackGenres[toIndex] || 'electronic';
              const context = fromGenre !== toGenre ? 'genreChange' : 'trackTransition';
              ttsText = generateAutoTTSPhrase(context);
            }
            
            if (ttsText) {
              // Play TTS during transition - LOUD and MELODIOUS
              setTimeout(() => {
                speakText(ttsText, { 
                  volume: 1.0,  // MAXIMUM volume - LOUD
                  rate: 0.92,   // Slower for more melodic, musical effect
                  pitch: 1.2    // Higher pitch (1.2) for energetic, melodious DJ voice
                });
              }, 1000);
            }
          }
          
          // Track history
          trackHistory.push({ index: toIndex, time: Date.now(), genre: toGenre });
          trackPlayCount[toIndex] = (trackPlayCount[toIndex] || 0) + 1;
        }
      }, stepDuration);
    }

    function enhanceTrackAdvanced(index, trackState) {
      const player = players[index];
      if (!player) return;

      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const currentVolume = trackState.volume;
      const currentSpeed = trackState.speed;
      const currentPitch = trackPitch[index] || 0;
      
      // Genre-aware volume adjustments
      const volumeRange = profile.volume.max - profile.volume.min;
      const volumeDirection = currentVolume < profile.volume.preferred ? 1 : 
                            (currentVolume > profile.volume.preferred ? -1 : (Math.random() > 0.5 ? 1 : -1));
      const volumeChange = (3 + mixIntensity * 8) * volumeDirection;
      const newVolume = Math.max(profile.volume.min, Math.min(profile.volume.max, currentVolume + volumeChange));
      
      // Genre-aware speed adjustments - pull towards genre preferred tempo
      const speedBias = profile.tempo.preferred - currentSpeed;
      const speedChange = speedBias * 0.03 + (Math.random() - 0.5) * (profile.tempo.max - profile.tempo.min) * 0.1;
      const newSpeed = Math.max(profile.tempo.min, Math.min(profile.tempo.max, currentSpeed + speedChange));
      
      // Genre-aware pitch adjustments
      const pitchChange = Math.random() < 0.3 ? Math.floor((Math.random() - 0.5) * (profile.pitch.max - profile.pitch.min) * 0.3) : 0;
      const newPitch = Math.max(profile.pitch.min, Math.min(profile.pitch.max, currentPitch + pitchChange));
      trackPitch[index] = newPitch;
      
      // Apply pitch to speed
      const pitchMultiplier = Math.pow(2, newPitch / 12);
      const finalSpeed = newSpeed * pitchMultiplier;
      
      // Genre-appropriate transition speed
      const transitionDuration = profile.mixingStyle === 'aggressive' ? 300 : 
                                profile.mixingStyle === 'atmospheric' ? 800 : 500;
      
      // Smooth transition
      animateVolumeChange(index, currentVolume, newVolume, transitionDuration);
      animateSpeedChangeWithPitch(index, currentSpeed, newSpeed, currentPitch, newPitch, transitionDuration);
      
      // Update pitch UI
      const pitchSlider = document.getElementById(`pitch${index}`);
      const pitchValue = document.getElementById(`pitchValue${index}`);
      if (pitchSlider) pitchSlider.value = newPitch;
      if (pitchValue) {
        if (newPitch === 0) {
          pitchValue.textContent = '0';
        } else if (newPitch > 0) {
          pitchValue.textContent = '+' + newPitch;
        } else {
          pitchValue.textContent = newPitch.toString();
        }
      }
    }

    function createBuildUp(index) {
      const player = players[index];
      if (!player) return;

      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const currentVolume = player.getVolume();
      const currentSpeed = player.getPlaybackRate();
      
      // Genre-appropriate build-up intensity
      const buildIntensity = profile.mixingStyle === 'epic' ? 20 : 
                            profile.mixingStyle === 'aggressive' ? 25 : 15;
      const targetVolume = Math.min(profile.volume.max, currentVolume + buildIntensity);
      const targetSpeed = Math.min(profile.tempo.max, currentSpeed + 0.05);
      
      const buildDuration = profile.mixingStyle === 'epic' ? 3000 : 2000;
      animateVolumeChange(index, currentVolume, targetVolume, buildDuration);
      animateSpeedChange(index, currentSpeed, targetSpeed, buildDuration);
      
      // Then drop back down after a moment
      setTimeout(() => {
        animateVolumeChange(index, targetVolume, currentVolume, buildDuration * 0.75);
        animateSpeedChange(index, targetSpeed, currentSpeed, buildDuration * 0.75);
      }, buildDuration + 1000);
    }

    function applyGenreVariation(index, variationType) {
      const player = players[index];
      if (!player) return;
      
      const genre = trackGenres[index] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      switch(variationType) {
        case 'pitchShift':
          // Dramatic pitch shift
          const currentPitch = trackPitch[index] || 0;
          const pitchShift = Math.floor((Math.random() - 0.5) * 8); // -4 to +4
          const newPitch = Math.max(profile.pitch.min, Math.min(profile.pitch.max, currentPitch + pitchShift));
          trackPitch[index] = newPitch;
          
          const currentSpeed = parseFloat(document.getElementById(`speed${index}`).value);
          const pitchMultiplier = Math.pow(2, newPitch / 12);
          player.setPlaybackRate(currentSpeed * pitchMultiplier);
          
          const pitchSlider = document.getElementById(`pitch${index}`);
          const pitchValue = document.getElementById(`pitchValue${index}`);
          if (pitchSlider) pitchSlider.value = newPitch;
          if (pitchValue) {
            pitchValue.textContent = newPitch === 0 ? '0' : (newPitch > 0 ? '+' + newPitch : newPitch.toString());
          }
          break;
          
        case 'volumeSpike':
          // Quick volume spike
          const currentVol = player.getVolume();
          const spikeVol = Math.min(95, currentVol + 20);
          animateVolumeChange(index, currentVol, spikeVol, 300);
          setTimeout(() => {
            animateVolumeChange(index, spikeVol, currentVol, 500);
          }, 500);
          break;
          
        case 'tempoMatch':
          // Match tempo to genre standard
          const targetTempo = profile.tempo.preferred;
          const currentTempo = parseFloat(document.getElementById(`speed${index}`).value);
          animateSpeedChange(index, currentTempo, targetTempo, 1000);
          break;
          
        case 'minimalVariation':
          // Very subtle changes (for techno/minimal)
          const vol = player.getVolume();
          const newVol = vol + (Math.random() - 0.5) * 5;
          animateVolumeChange(index, vol, Math.max(profile.volume.min, Math.min(profile.volume.max, newVol)), 2000);
          break;
          
        case 'loopMash':
          // Quick loop activation
          if (!trackLoops[index]) {
            trackLoops[index] = true;
            const loopCheckbox = document.getElementById(`loop${index}`);
            if (loopCheckbox) loopCheckbox.checked = true;
            startLoop(index);
          }
          break;
          
        default:
          enhanceTrackAdvanced(index, {
            volume: player.getVolume(),
            speed: player.getPlaybackRate(),
            playTime: Date.now()
          });
      }
    }

    function quickCutToNext(currentIndex) {
      const currentGenre = trackGenres[currentIndex] || 'electronic';
      const nextIndex = selectNextTrack([currentIndex], currentGenre);
      const currentPlayer = players[currentIndex];
      const nextPlayer = players[nextIndex];
      
      if (!currentPlayer || !nextPlayer) return;
      
      // Instant cut - no fade
      currentPlayer.pauseVideo();
      stopLoop(currentIndex);
      
      const genre = trackGenres[nextIndex] || 'electronic';
      const profile = genreProfiles[genre] || genreProfiles['electronic'];
      
      const targetVolume = profile.volume.preferred + (Math.random() - 0.5) * 10;
      const targetSpeed = profile.tempo.preferred + (Math.random() - 0.5) * (profile.tempo.max - profile.tempo.min) * 0.3;
      
      nextPlayer.setVolume(targetVolume);
      nextPlayer.setPlaybackRate(targetSpeed);
      nextPlayer.playVideo();
      
      updateTrackUI(nextIndex, targetVolume, targetSpeed);
      currentPlayingIndex = nextIndex;
      
      trackHistory.push({ index: nextIndex, time: Date.now(), genre });
      trackPlayCount[nextIndex] = (trackPlayCount[nextIndex] || 0) + 1;
    }

    function layerTracks(mainIndex, layerIndex) {
      const mainPlayer = players[mainIndex];
      const layerPlayer = players[layerIndex];
      if (!mainPlayer || !layerPlayer) return;

      // Layer: play both tracks with main louder
      const mainVolume = mainPlayer.getVolume();
      const layerVolume = Math.min(40, mainVolume * 0.5);
      
      layerPlayer.setVolume(0);
      layerPlayer.setPlaybackRate(mainPlayer.getPlaybackRate()); // Match tempo
      layerPlayer.playVideo();
      
      fadeInTrackAdvanced(layerIndex, layerVolume);
      updateTrackUI(layerIndex, layerVolume, mainPlayer.getPlaybackRate());
    }

    function perfectBalance(trackStates) {
      // Balance two tracks perfectly
      const avgVolume = trackStates.reduce((sum, t) => sum + t.volume, 0) / trackStates.length;
      const targetVolume = Math.min(70, Math.max(40, avgVolume));
      
      trackStates.forEach(state => {
        animateVolumeChange(state.index, state.volume, targetVolume, 1000);
      });
    }

    function adjustMixAdvanced(trackStates) {
      // Advanced mixing with better balance
      const totalVolume = trackStates.reduce((sum, t) => sum + t.volume, 0);
      const avgVolume = totalVolume / trackStates.length;
      const targetVolume = Math.min(75, Math.max(35, avgVolume));
      
      trackStates.forEach((state, i) => {
        // Vary volumes slightly but keep balanced
        const variation = (Math.random() - 0.5) * 10;
        const newVolume = Math.max(30, Math.min(80, targetVolume + variation));
        
        // Slight tempo adjustments
        const speedAdjust = (Math.random() - 0.5) * 0.06;
        const newSpeed = Math.max(0.85, Math.min(1.15, state.speed + speedAdjust));
        
        // Slight pitch adjustments for harmonic mixing
        const currentPitch = trackPitch[state.index] || 0;
        const pitchAdjust = Math.random() < 0.2 ? Math.floor((Math.random() - 0.5) * 3) : 0; // 20% chance
        const newPitch = Math.max(-12, Math.min(12, currentPitch + pitchAdjust));
        trackPitch[state.index] = newPitch;
        
        // Update pitch UI
        const pitchSlider = document.getElementById(`pitch${state.index}`);
        const pitchValue = document.getElementById(`pitchValue${state.index}`);
        if (pitchSlider) pitchSlider.value = newPitch;
        if (pitchValue) {
          if (newPitch === 0) {
            pitchValue.textContent = '0';
          } else if (newPitch > 0) {
            pitchValue.textContent = '+' + newPitch;
          } else {
            pitchValue.textContent = newPitch.toString();
          }
        }
        
        animateVolumeChange(state.index, state.volume, newVolume, 800);
        animateSpeedChange(state.index, state.speed, newSpeed, 800);
      });
    }

    function animateVolumeChange(index, from, to, duration) {
      const player = players[index];
      if (!player) return;

      const steps = 20;
      const stepSize = (to - from) / steps;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const currentVolume = from + (stepSize * step);
        player.setVolume(Math.max(0, Math.min(100, currentVolume)));
        
        if (step >= steps) {
          clearInterval(interval);
          player.setVolume(to);
          updateTrackUI(index, to, player.getPlaybackRate());
        }
      }, stepDuration);
    }

    function animateSpeedChange(index, from, to, duration) {
      const player = players[index];
      if (!player) return;

      const currentPitch = trackPitch[index] || 0;
      const pitchMultiplier = Math.pow(2, currentPitch / 12);

      const steps = 15;
      const stepSize = (to - from) / steps;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const currentSpeed = from + (stepSize * step);
        const finalSpeed = currentSpeed * pitchMultiplier;
        player.setPlaybackRate(Math.max(0.5, Math.min(2, finalSpeed)));
        
        if (step >= steps) {
          clearInterval(interval);
          player.setPlaybackRate(to * pitchMultiplier);
          updateTrackUI(index, player.getVolume(), to);
        }
      }, stepDuration);
    }

    function animateSpeedChangeWithPitch(index, fromSpeed, toSpeed, fromPitch, toPitch, duration) {
      const player = players[index];
      if (!player) return;

      const steps = 15;
      const stepDuration = duration / steps;
      let step = 0;

      const interval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Interpolate speed
        const currentSpeed = fromSpeed + (toSpeed - fromSpeed) * progress;
        
        // Interpolate pitch
        const currentPitch = fromPitch + (toPitch - fromPitch) * progress;
        trackPitch[index] = Math.round(currentPitch);
        
        // Apply pitch to speed
        const pitchMultiplier = Math.pow(2, currentPitch / 12);
        const finalSpeed = currentSpeed * pitchMultiplier;
        
        player.setPlaybackRate(Math.max(0.5, Math.min(2, finalSpeed)));
        
        if (step >= steps) {
          clearInterval(interval);
          const finalPitchMultiplier = Math.pow(2, toPitch / 12);
          player.setPlaybackRate(toSpeed * finalPitchMultiplier);
          trackPitch[index] = toPitch;
          updateTrackUI(index, player.getVolume(), toSpeed);
        }
      }, stepDuration);
    }

    function fadeInTrackAdvanced(index, targetVolume, style = 'normal') {
      const player = players[index];
      if (!player) return;

      let fadeSteps, stepDuration, easing;
      
      switch(style) {
        case 'quick':
          fadeSteps = 10;
          stepDuration = 50;
          easing = (p) => p; // Linear for quick
          break;
        case 'slow':
          fadeSteps = 40;
          stepDuration = 100;
          easing = (p) => 1 - Math.pow(1 - p, 4); // Very smooth
          break;
        default: // normal
          fadeSteps = 20;
          stepDuration = 80;
          easing = (p) => 1 - Math.pow(1 - p, 3); // Standard exponential
      }

      let step = 0;
      player.setVolume(0);
      player.playVideo();

      const fadeInterval = setInterval(() => {
        step++;
        const progress = step / fadeSteps;
        const easedProgress = easing(progress);
        player.setVolume(targetVolume * easedProgress);
        
        if (step >= fadeSteps) {
          clearInterval(fadeInterval);
          player.setVolume(targetVolume);
        }
      }, stepDuration);
    }

    function updateTrackUI(index, volume, speed) {
      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      if (volumeSlider) volumeSlider.value = volume;
      if (volumeValue) volumeValue.textContent = Math.round(volume) + '%';
      if (speedSlider) speedSlider.value = speed;
      if (speedValue) speedValue.textContent = speed.toFixed(2) + 'x';
    }

    // Parse loop pattern into segments (e.g., "x xx xxx" -> [1, 2, 3])
    function parseLoopPattern(pattern) {
      if (!pattern || !pattern.trim()) return null;
      
      const segments = pattern.trim().split(/\s+/).filter(s => s.length > 0);
      return segments.map(segment => {
        // Count 'x' characters (case insensitive, also count 'X')
        const xCount = (segment.match(/x/gi) || []).length;
        return xCount > 0 ? xCount : 1; // Default to 1 if no 'x' found
      });
    }

    function startLoop(index) {
      const player = players[index];
      if (!player) return;
      
      stopLoop(index); // Clear any existing loop
      
      // Get current position and video duration
      const currentTime = player.getCurrentTime();
      const duration = player.getDuration();
      
      // Check if pattern-based looping is enabled
      const pattern = loopPatterns[index] || '';
      const patternSegments = parseLoopPattern(pattern);
      
      if (patternSegments && patternSegments.length > 0) {
        // Pattern-based looping
        const segmentLengths = patternSegments; // Each number represents seconds
        let currentSegmentIndex = loopPatternIndex[index] || 0;
        if (currentSegmentIndex >= segmentLengths.length) {
          currentSegmentIndex = 0;
          loopPatternIndex[index] = 0;
        }
        
        // Calculate loop points based on current pattern segment
        const segmentLength = segmentLengths[currentSegmentIndex];
        const startTime = Math.max(0, currentTime);
        const endTime = Math.min(duration, startTime + segmentLength);
        
        loopStartTimes[index] = startTime;
        loopEndTimes[index] = endTime;
        loopSegmentLooped[index] = false; // Reset loop tracking for new segment
        
        // Check if we're near the end of the current segment
        const checkPatternLoop = () => {
          if (!trackLoops[index] || !player) return;
          
          try {
            const current = player.getCurrentTime();
            const currentStartTime = loopStartTimes[index];
            const currentEndTime = loopEndTimes[index];
            
            if (current >= currentEndTime - 0.3) {
              if (!loopSegmentLooped[index]) {
                // First time reaching end: jump back to start of current segment
                player.seekTo(currentStartTime, true);
                loopSegmentLooped[index] = true;
              } else {
                // Already looped back once, now move to next segment
                let nextSegmentIndex = (currentSegmentIndex + 1) % segmentLengths.length;
                loopPatternIndex[index] = nextSegmentIndex;
                loopSegmentLooped[index] = false; // Reset for new segment
                
                // Calculate new loop segment starting from current position
                const newSegmentLength = segmentLengths[nextSegmentIndex];
                const newCurrentTime = player.getCurrentTime();
                const newStartTime = Math.max(0, newCurrentTime);
                const newEndTime = Math.min(duration, newStartTime + newSegmentLength);
                
                loopStartTimes[index] = newStartTime;
                loopEndTimes[index] = newEndTime;
              }
            }
          } catch (e) {
            console.error('Pattern loop check error:', e);
          }
        };
        
        // Check every 100ms
        loopIntervals[index] = setInterval(checkPatternLoop, 100);
      } else {
        // Default looping behavior - continuous repeat from start to end
        // If loop points are manually set, use them; otherwise loop entire track
      if (!loopStartTimes[index]) {
          loopStartTimes[index] = 0; // Start from beginning
      }
      if (!loopEndTimes[index]) {
          loopEndTimes[index] = duration; // Loop to end
      }
      
      const startTime = loopStartTimes[index];
      const endTime = loopEndTimes[index];
      
        // Check if we're near the end of the loop - jump back to start continuously
      const checkLoop = () => {
        if (!trackLoops[index] || !player) return;
        
        try {
          const current = player.getCurrentTime();
            // Check if we're at or past the end time (with small buffer)
            if (current >= endTime - 0.3 || current >= duration - 0.3) {
              // Jump back to start of loop - repeat again and again
            player.seekTo(startTime, true);
          }
        } catch (e) {
          console.error('Loop check error:', e);
        }
      };
      
        // Check every 100ms for smooth looping
      loopIntervals[index] = setInterval(checkLoop, 100);
      }
    }

    function stopLoop(index) {
      if (loopIntervals[index]) {
        clearInterval(loopIntervals[index]);
        loopIntervals[index] = null;
      }
      loopStartTimes[index] = null;
      loopEndTimes[index] = null;
    }

    function setLoopPoints(index, startTime, endTime) {
      loopStartTimes[index] = startTime;
      loopEndTimes[index] = endTime;
      if (trackLoops[index]) {
        startLoop(index);
      }
    }

    function removeSong(index) {
      // Stop the player if playing
      if (players[index]) {
        try {
          players[index].pauseVideo();
          players[index].destroy();
        } catch (e) {
          console.error('Error destroying player:', e);
        }
      }
      
      // Stop any loops and beat indicators
      stopLoop(index);
      if (beatIndicators[index]) {
        clearInterval(beatIndicators[index]);
        delete beatIndicators[index];
      }
      
      // Remove the card from DOM with animation
      const card = document.getElementById(`card${index}`);
      if (card) {
        card.style.opacity = '0';
        card.style.transform = 'scale(0.8)';
        setTimeout(() => {
          card.remove();
        }, 300);
      }
      
      // Clean up arrays
      players[index] = null;
      if (videoData[index]) videoData[index] = null;
      trackLoops[index] = null;
      trackPitch[index] = null;
      loopPatterns[index] = null;
      loopIntervals[index] = null;
      loopStartTimes[index] = null;
      loopEndTimes[index] = null;
      trackGenres[index] = null;
      trackEQ[index] = null;
      cuePoints[index] = null;
      trackBPM[index] = null;
      
      // Update current playing index if needed
      if (currentPlayingIndex === index) {
        currentPlayingIndex = -1;
      }
    }

    function handleCueButton(index, cueNumber) {
      const player = players[index];
      if (!player) return;
      
      try {
        if (!cuePoints[index]) {
          cuePoints[index] = {};
        }
        
        // If cue point already exists, jump to it
        if (cuePoints[index][cueNumber]) {
          player.seekTo(cuePoints[index][cueNumber], true);
          console.log(`Jumped to cue ${cueNumber} at ${cuePoints[index][cueNumber].toFixed(2)}s`);
        } else {
          // Set new cue point at current position
          const currentTime = player.getCurrentTime();
          cuePoints[index][cueNumber] = currentTime;
          console.log(`Cue ${cueNumber} set at ${currentTime.toFixed(2)}s for track ${index}`);
        }
        
        // Visual feedback
        const cueButton = document.getElementById(`cueBtn${index}_${cueNumber}`);
        if (cueButton) {
          cueButton.classList.add('active');
          setTimeout(() => {
            cueButton.classList.remove('active');
          }, 300);
        }
      } catch (e) {
        console.error('Error handling cue button:', e);
      }
    }

    function handleSpacebar() {
      // Find the current focused track or first available track
      let targetIndex = currentFocusedIndex;
      
      // If no focused track or track doesn't exist, find first available
      if (targetIndex < 0 || !players[targetIndex] || players.length === 0) {
        targetIndex = 0;
        if (players.length > 0 && currentPlayingIndex >= 0) {
          targetIndex = currentPlayingIndex;
        }
      }
      
      if (targetIndex < 0 || !players[targetIndex]) return;
      
      const player = players[targetIndex];
      const state = player.getPlayerState();
      const volumeSlider = document.getElementById(`volume${targetIndex}`);
      const playButton = document.getElementById(`playBtn${targetIndex}`);
      const videoCard = document.getElementById(`card${targetIndex}`);
      
      // Clear any existing fade
      if (spacebarFadeInterval) {
        clearInterval(spacebarFadeInterval);
        spacebarFadeInterval = null;
      }
      
      if (state === YT.PlayerState.PLAYING) {
        // Track is playing - fade volume down for mixing
        let currentVolume = parseInt(volumeSlider.value) || 50;
        const fadeDown = () => {
          if (currentVolume > 0) {
            currentVolume = Math.max(0, currentVolume - 5);
            volumeSlider.value = currentVolume;
            player.setVolume(currentVolume);
            const volumeValue = document.getElementById(`volumeValue${targetIndex}`);
            if (volumeValue) volumeValue.textContent = currentVolume;
          } else {
            clearInterval(spacebarFadeInterval);
            spacebarFadeInterval = null;
            player.pauseVideo();
            if (playButton) {
              playButton.innerHTML = getSVGIcon('play');
              playButton.classList.remove('playing');
            }
            if (videoCard) videoCard.classList.remove('playing');
            if (currentPlayingIndex === targetIndex) {
              currentPlayingIndex = -1;
            }
          }
        };
        spacebarFadeInterval = setInterval(fadeDown, 50);
      } else {
        // Track is paused - play and fade volume up
        player.playVideo();
        if (playButton) {
          playButton.innerHTML = getSVGIcon('pause');
          playButton.classList.add('playing');
        }
        if (videoCard) videoCard.classList.add('playing');
        currentPlayingIndex = targetIndex;
        currentFocusedIndex = targetIndex;
        startBeatIndicator(targetIndex);
        
        // Start with low volume and fade up
        let currentVolume = 0;
        volumeSlider.value = 0;
        player.setVolume(0);
        const volumeValue = document.getElementById(`volumeValue${targetIndex}`);
        if (volumeValue) volumeValue.textContent = 0;
        
        const fadeUp = () => {
          if (currentVolume < 100) {
            currentVolume = Math.min(100, currentVolume + 5);
            volumeSlider.value = currentVolume;
            player.setVolume(currentVolume);
            if (volumeValue) volumeValue.textContent = currentVolume;
          } else {
            clearInterval(spacebarFadeInterval);
            spacebarFadeInterval = null;
          }
        };
        spacebarFadeInterval = setInterval(fadeUp, 50);
      }
      
      // Visual feedback
      const spacebarButton = document.getElementById('spacebarButton');
      if (spacebarButton) {
        spacebarButton.classList.add('active');
        setTimeout(() => {
          spacebarButton.classList.remove('active');
        }, 200);
      }
    }

    function startBeatIndicator(index) {
      if (beatIndicators[index]) {
        clearInterval(beatIndicators[index]);
      }
      
      const indicator = document.getElementById(`beatIndicator${index}`);
      if (!indicator) return;
      
      // Estimate BPM and create beat animation
      const estimatedBPM = trackBPM[index] || 120;
      const beatInterval = (60 / estimatedBPM) * 1000; // Convert to milliseconds
      
      beatIndicators[index] = setInterval(() => {
        if (indicator) {
          indicator.classList.add('active');
          setTimeout(() => {
            if (indicator) indicator.classList.remove('active');
          }, 100);
        }
      }, beatInterval);
    }

    function stopBeatIndicator(index) {
      if (beatIndicators[index]) {
        clearInterval(beatIndicators[index]);
        beatIndicators[index] = null;
      }
      const indicator = document.getElementById(`beatIndicator${index}`);
      if (indicator) {
        indicator.classList.remove('active');
      }
    }

    function fadeOutTrack(index) {
      const player = players[index];
      if (!player) return;

      // Stop loop when fading out
      stopLoop(index);

      const fadeSteps = 20;
      const currentVolume = player.getVolume();
      const stepSize = currentVolume / fadeSteps;
      let step = 0;

      const fadeInterval = setInterval(() => {
        step++;
        player.setVolume(Math.max(0, currentVolume - (stepSize * step)));
        
        if (step >= fadeSteps) {
          clearInterval(fadeInterval);
          player.pauseVideo();
          stopLoop(index); // Ensure loop is stopped
        }
      }, 100);
    }

    function adjustMix(playingTracks) {
      playingTracks.forEach(index => {
        const player = players[index];
        if (!player) return;

        const volumeAdjust = (Math.random() - 0.5) * 15;
        const speedAdjust = (Math.random() - 0.5) * 0.08;
        
        const currentVolume = player.getVolume();
        const newVolume = Math.max(30, Math.min(90, currentVolume + volumeAdjust));
        const currentSpeed = player.getPlaybackRate();
        const newSpeed = Math.max(0.75, Math.min(1.5, currentSpeed + speedAdjust));
        
        player.setVolume(newVolume);
        player.setPlaybackRate(newSpeed);
        
        document.getElementById(`volume${index}`).value = newVolume;
        document.getElementById(`volumeValue${index}`).textContent = Math.round(newVolume) + '%';
        document.getElementById(`speed${index}`).value = newSpeed;
        document.getElementById(`speedValue${index}`).textContent = newSpeed.toFixed(2) + 'x';
      });
    }


    function beatDropMix() {
      if (players.length < 2) return;
      
      // Find currently playing track
      const playingTracks = [];
      players.forEach((player, index) => {
        if (player && player.getPlayerState() === YT.PlayerState.PLAYING) {
          playingTracks.push(index);
        }
      });
      
      if (playingTracks.length === 0) {
        // No track playing, start first one
        if (players[0]) {
          players[0].playVideo();
          players[0].setVolume(70);
          return;
        }
      }
      
      // Get current playing track
      const currentIndex = playingTracks[0] || currentPlayingIndex;
      if (currentIndex === -1 || !players[currentIndex]) return;
      
      // Find next track to mix in
      const nextIndex = (currentIndex + 1) % players.length;
      const currentPlayer = players[currentIndex];
      const nextPlayer = players[nextIndex];
      
      if (!currentPlayer || !nextPlayer) return;
      
      // Get current track info
      const currentVolume = currentPlayer.getVolume();
      const currentSpeed = currentPlayer.getPlaybackRate();
      const currentPitch = trackPitch[currentIndex] || 0;
      
      // Prepare next track - match tempo and pitch for seamless transition
      const nextPitch = trackPitch[nextIndex] || 0;
      const pitchMultiplier = Math.pow(2, nextPitch / 12);
      nextPlayer.setPlaybackRate(currentSpeed * pitchMultiplier);
      nextPlayer.setVolume(0);
      
      // Update UI for next track
      const nextSpeedSlider = document.getElementById(`speed${nextIndex}`);
      const nextPitchSlider = document.getElementById(`pitch${nextIndex}`);
      if (nextSpeedSlider) nextSpeedSlider.value = currentSpeed;
      if (nextPitchSlider) nextPitchSlider.value = nextPitch;
      
      // Start next track
      nextPlayer.playVideo();
      
      // Seamless crossfade - smooth volume transition
      const fadeDuration = 2000; // 2 seconds for smooth transition
      const steps = 40;
      const stepDuration = fadeDuration / steps;
      let step = 0;
      
      const crossfadeInterval = setInterval(() => {
        step++;
        const progress = step / steps;
        
        // Smooth easing curve
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        // Fade out current track
        const newCurrentVolume = currentVolume * (1 - easeProgress);
        currentPlayer.setVolume(Math.max(0, newCurrentVolume));
        
        // Fade in next track
        const newNextVolume = 70 * easeProgress;
        nextPlayer.setVolume(newNextVolume);
        
        if (step >= steps) {
          clearInterval(crossfadeInterval);
          // Complete the transition
          currentPlayer.pauseVideo();
          nextPlayer.setVolume(70);
          currentPlayingIndex = nextIndex;
          
          // Update play buttons
          const currentPlayBtn = document.getElementById(`playBtn${currentIndex}`);
          const nextPlayBtn = document.getElementById(`playBtn${nextIndex}`);
          if (currentPlayBtn) {
            currentPlayBtn.textContent = 'Play';
            currentPlayBtn.classList.remove('playing');
          }
          if (nextPlayBtn) {
            nextPlayBtn.textContent = 'Pause';
            nextPlayBtn.classList.add('playing');
          }
          
          // Update card states
          const currentCard = document.getElementById(`card${currentIndex}`);
          const nextCard = document.getElementById(`card${nextIndex}`);
          if (currentCard) currentCard.classList.remove('playing');
          if (nextCard) nextCard.classList.add('playing');
        }
      }, stepDuration);
    }

    function toggleBeatDropMix() {
      beatDropActive = !beatDropActive;
      const button = document.getElementById('beatDropButton');
      
      // Stop copilot if active
      if (copilotActive) {
        toggleCopilot();
      }
      
      if (beatDropActive) {
        button.classList.add('active');
        button.textContent = 'Stop Beat Drop';
        
        // Start beat drop mixing
        beatDropMix(); // Initial mix
        
        // Continue mixing every 8-12 seconds
        beatDropInterval = setInterval(() => {
          if (beatDropActive) {
            beatDropMix();
          }
        }, 8000 + Math.random() * 4000); // Random interval between 8-12 seconds
      } else {
        button.classList.remove('active');
        button.textContent = 'Beat Drop Mix';
        
        // Stop mixing
        if (beatDropInterval) {
          clearInterval(beatDropInterval);
          beatDropInterval = null;
        }
      }
    }

    function updateControlsForLockState() {
        players.forEach((player, index) => {
          const card = document.getElementById(`card${index}`);
          const playButton = document.getElementById(`playBtn${index}`);
          const volumeSlider = document.getElementById(`volume${index}`);
          const speedSlider = document.getElementById(`speed${index}`);
          const pitchSlider = document.getElementById(`pitch${index}`);
          const loopCheckbox = document.getElementById(`loop${index}`);
        const loopPatternInput = document.getElementById(`loopPattern${index}`);
        
        if (djVeeLocked) {
          // Locked: disable all manual controls
          if (card) card.classList.add('disabled');
          if (playButton) playButton.disabled = true;
          if (volumeSlider) volumeSlider.disabled = true;
          if (speedSlider) speedSlider.disabled = true;
          if (pitchSlider) pitchSlider.disabled = true;
          if (loopCheckbox) loopCheckbox.disabled = true;
          if (loopPatternInput) loopPatternInput.disabled = true;
        } else {
          // Unlocked: enable controls for manual mixing (JAM mode)
          if (card) card.classList.remove('disabled');
          if (playButton) playButton.disabled = false;
          if (volumeSlider) volumeSlider.disabled = false;
          if (speedSlider) speedSlider.disabled = false;
          if (pitchSlider) pitchSlider.disabled = false;
          if (loopCheckbox) loopCheckbox.disabled = false;
          if (loopPatternInput) loopPatternInput.disabled = false;
        }
      });
    }

    function toggleCopilot() {
      copilotActive = !copilotActive;
      const button = document.getElementById('copilotButton');
      const body = document.body;
      
      // Stop beat drop mix if active
      if (beatDropActive) {
        toggleBeatDropMix();
      }
      
      if (copilotActive) {
        button.classList.add('active');
        button.textContent = 'Stop DJ VEE';
        body.classList.add('copilot-active');
        
        // Show lock button
        const lockButton = document.getElementById('lockButton');
        if (lockButton) {
          lockButton.style.display = 'flex';
        }
        
        // Update controls based on lock state
        updateControlsForLockState();
        
        // Dynamic interval based on mix intensity
        const baseInterval = 6000 + (1 - mixIntensity) * 4000; // 6-10 seconds
        copilotInterval = setInterval(() => {
          djAlgorithm();
          // Adjust interval dynamically
          if (copilotInterval) {
            clearInterval(copilotInterval);
            const newInterval = 6000 + (1 - mixIntensity) * 4000 + Math.random() * 2000;
            copilotInterval = setInterval(() => djAlgorithm(), newInterval);
          }
        }, baseInterval);
        setTimeout(() => djAlgorithm(), 1000);
      } else {
        button.classList.remove('active');
        button.textContent = 'DJ VEE';
        body.classList.remove('copilot-active');
        
        // Hide lock button
        const lockButton = document.getElementById('lockButton');
        if (lockButton) {
          lockButton.style.display = 'none';
        }
        
        // Reset lock state
        djVeeLocked = true;
        const lockIcon = document.getElementById('lockIcon');
        const lockText = document.getElementById('lockText');
        if (lockIcon) lockIcon.innerHTML = getSVGIcon('lock');
        if (lockText) lockText.textContent = 'Lock';
        if (lockButton) lockButton.classList.remove('unlocked');
        
        // Stop all loops when copilot is disabled
        players.forEach((player, index) => {
          stopLoop(index);
        });
        
        // Re-enable all controls
        players.forEach((player, index) => {
          const card = document.getElementById(`card${index}`);
          if (card) {
            card.classList.remove('disabled');
          }
          const playButton = document.getElementById(`playBtn${index}`);
          if (playButton) {
            playButton.disabled = false;
          }
          const volumeSlider = document.getElementById(`volume${index}`);
          if (volumeSlider) {
            volumeSlider.disabled = false;
          }
          const speedSlider = document.getElementById(`speed${index}`);
          if (speedSlider) {
            speedSlider.disabled = false;
          }
          const pitchSlider = document.getElementById(`pitch${index}`);
          if (pitchSlider) {
            pitchSlider.disabled = false;
          }
          const loopCheckbox = document.getElementById(`loop${index}`);
          if (loopCheckbox) {
            loopCheckbox.disabled = false;
          }
          const loopPatternInput = document.getElementById(`loopPattern${index}`);
          if (loopPatternInput) {
            loopPatternInput.disabled = false;
          }
        });
        
        if (copilotInterval) {
          clearInterval(copilotInterval);
          copilotInterval = null;
        }
      }
    }

    function stopBackgroundVideos() {
      localVideoElements.forEach((video, index) => {
        if (video) {
          video.pause();
          video.classList.remove('active');
          video.style.opacity = '0';
        }
      });
      const overlay = document.querySelector('.background-overlay');
      if (overlay) {
        overlay.classList.add('search-active');
      }
    }

    function resumeBackgroundVideos() {
      const overlay = document.querySelector('.background-overlay');
      if (overlay) {
        overlay.classList.remove('search-active');
      }
      // Don't auto-resume, let user control
    }

    function handleFormSubmit(event) {
      event.preventDefault();
      const searchQuery = document.getElementById('searchQuery').value.trim();
      
      if (!searchQuery) {
        return;
      }

      // Stop background videos when search is active
      stopBackgroundVideos();

      if (copilotActive) {
        toggleCopilot();
      }
      
      // Stop auto-play on new search
      autoPlayActive = false;
      userInteracted = false;

      // Reset track history on new search
      trackHistory = [];
      trackPlayCount = {};
      mixIntensity = 0.5;
      userInteracted = false;
      autoPlayActive = true;
      readyPlayers = [];

      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '<div class="loading">Searching...</div>';

      const request = new XMLHttpRequest();
      const apiKey = 'AIzaSyAEzhGEyJJgZpoN6ahBTvnZyr4g5FV5s9s';
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=4&q=${encodeURIComponent(searchQuery)}&key=${apiKey}&type=video`;

      request.open('GET', url, true);

      request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
          const data = JSON.parse(request.responseText);
          displayResults(data);
        } else {
          resultsDiv.innerHTML = `
            <div class="empty-state">
              <p>Error fetching videos. Please try again.</p>
            </div>
          `;
          console.error('Error fetching data from YouTube.');
        }
      };

      request.onerror = function() {
        resultsDiv.innerHTML = `
          <div class="empty-state">
            <p>Network error. Please check your connection.</p>
          </div>
        `;
        console.error('Network error.');
      };

      request.send();
    }

    function handleAddMoreSubmit(event) {
      event.preventDefault();
      const searchQuery = document.getElementById('addMoreQuery').value.trim();
      
      if (!searchQuery) {
        return;
      }

      // Stop beat drop mix if active
      if (beatDropActive) {
        toggleBeatDropMix();
      }

      const resultsDiv = document.getElementById('results');
      const loadingDiv = document.createElement('div');
      loadingDiv.className = 'loading';
      loadingDiv.textContent = 'Adding songs...';
      resultsDiv.appendChild(loadingDiv);

      const request = new XMLHttpRequest();
      const apiKey = 'AIzaSyAEzhGEyJJgZpoN6ahBTvnZyr4g5FV5s9s';
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=4&q=${encodeURIComponent(searchQuery)}&key=${apiKey}&type=video`;

      request.open('GET', url, true);

      request.onload = function() {
        if (request.status >= 200 && request.status < 400) {
          const data = JSON.parse(request.responseText);
          if (data.items && data.items.length > 0) {
            // Remove loading indicator
            loadingDiv.remove();
            // Add new items to existing videoData
            const newItems = data.items.slice(0, 4);
            const startIndex = videoData.length;
            videoData = videoData.concat(newItems);
            
            // Detect genres for new tracks
            newItems.forEach((item, idx) => {
              const index = startIndex + idx;
              trackGenres[index] = detectGenre(item);
            });
            
            // Create players for new items
            createPlayersForItems(newItems, startIndex);
            
            // Clear the search input
            document.getElementById('addMoreQuery').value = '';
          } else {
            loadingDiv.textContent = 'No additional results found.';
            setTimeout(() => loadingDiv.remove(), 2000);
          }
        } else {
          loadingDiv.textContent = 'Error fetching videos.';
          setTimeout(() => loadingDiv.remove(), 2000);
        }
      };

      request.onerror = function() {
        loadingDiv.textContent = 'Network error.';
        setTimeout(() => loadingDiv.remove(), 2000);
      };

      request.send();
    }

    function createPlayersForItems(items, startIndex) {
      items.forEach((item, relativeIndex) => {
        const index = startIndex + relativeIndex;
        const resultsDiv = document.getElementById('results');
        
        const videoCard = document.createElement('div');
        videoCard.className = 'video-card';
        videoCard.id = `card${index}`;
        videoCard.style.animationDelay = `${index * 0.1}s`;
        
        // Add close button
        const closeButton = document.createElement('button');
        closeButton.className = 'close-button';
        closeButton.innerHTML = getSVGIcon('close');
        closeButton.title = 'Remove this song';
        closeButton.onclick = () => removeSong(index);
        
        // Add beat indicator
        const beatIndicator = document.createElement('div');
        beatIndicator.className = 'beat-indicator';
        beatIndicator.id = `beatIndicator${index}`;
        
        const videoWrapper = document.createElement('div');
        videoWrapper.className = 'video-wrapper';
        const videoDiv = document.createElement('div');
        videoDiv.id = `player${index}`;
        videoWrapper.appendChild(videoDiv);
        
        videoCard.appendChild(closeButton);
        videoCard.appendChild(beatIndicator);
        
        const detectedGenre = trackGenres[index] || 'electronic';
        
        const videoInfo = document.createElement('div');
        videoInfo.className = 'video-info';
        videoInfo.innerHTML = `
          <div class="video-title">${item.snippet.title}</div>
          <div class="video-channel">${item.snippet.channelTitle}</div>
          <div class="video-genre" id="genre${index}">${detectedGenre.toUpperCase()}</div>
        `;
        
        const controls = document.createElement('div');
        controls.className = 'controls';
        
        const playButton = document.createElement('button');
        playButton.className = 'play-button';
        playButton.id = `playBtn${index}`;
        playButton.innerHTML = getSVGIcon('play');
        playButton.onclick = () => togglePlay(index);
        playButton.title = 'Play/Pause';
        
        const volumeGroup = document.createElement('div');
        volumeGroup.className = 'control-group';
        volumeGroup.innerHTML = `
          <span class="control-icon" title="Volume">${getSVGIcon('volume')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="volume${index}" min="0" max="100" value="50">
          </div>
          <span class="control-value" id="volumeValue${index}">50%</span>
        `;
        
        const speedGroup = document.createElement('div');
        speedGroup.className = 'control-group';
        speedGroup.innerHTML = `
          <span class="control-icon" title="Speed">${getSVGIcon('speed')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="speed${index}" min="0.25" max="2" step="0.05" value="1">
          </div>
          <span class="control-value" id="speedValue${index}">1.0x</span>
        `;
        
        const pitchGroup = document.createElement('div');
        pitchGroup.className = 'control-group';
        pitchGroup.innerHTML = `
          <span class="control-icon" title="Pitch">${getSVGIcon('pitch')}</span>
          <div class="slider-container">
            <input type="range" class="slider" id="pitch${index}" min="-12" max="12" step="1" value="0">
          </div>
          <span class="control-value" id="pitchValue${index}">0</span>
        `;
        
        const loopGroup = document.createElement('div');
        loopGroup.className = 'control-group';
        loopGroup.style.flexDirection = 'column';
        loopGroup.style.gap = '6px';
        loopGroup.innerHTML = `
          <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
            <span class="control-icon" title="Loop">${getSVGIcon('loop')}</span>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;">
              <input type="checkbox" id="loop${index}" style="cursor: pointer;">
              <span style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">Loop</span>
            </label>
          </div>
          <input 
            type="text" 
            id="loopPattern${index}" 
            placeholder="x xx xxx xxxxxx" 
            style="width: 100%; padding: 4px 8px; font-size: 11px; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; background: rgba(255, 255, 255, 0.05); color: #ffffff; outline: none; font-family: monospace;"
            title="Loop pattern: each 'x' = 1 second, spaces separate segments"
          >
        `;
        
        // Add EQ controls
        const eqControls = document.createElement('div');
        eqControls.className = 'eq-controls';
        eqControls.innerHTML = `
          <div class="eq-control">
            <span class="eq-label" title="Low frequencies (Bass, Kick) - Adjust bass and low-end sounds">Low</span>
            <input type="range" class="eq-slider" id="eqLow${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Low frequencies: Bass, kick drums">
            <span class="control-value" id="eqLowValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="Mid frequencies (Vocals, Instruments) - Adjust vocals and mid-range instruments">Mid</span>
            <input type="range" class="eq-slider" id="eqMid${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="Mid frequencies: Vocals, instruments">
            <span class="control-value" id="eqMidValue${index}" style="font-size: 9px;">0</span>
          </div>
          <div class="eq-control">
            <span class="eq-label" title="High frequencies (Treble, Cymbals) - Adjust high-end sounds and clarity">High</span>
            <input type="range" class="eq-slider" id="eqHigh${index}" min="-12" max="12" step="1" value="0" orient="vertical" title="High frequencies: Treble, cymbals">
            <span class="control-value" id="eqHighValue${index}" style="font-size: 9px;">0</span>
          </div>
        `;
        
        // Add numbered cue buttons (1-5)
        const cueButtonsGroup = document.createElement('div');
        cueButtonsGroup.className = 'cue-buttons-group';
        cueButtonsGroup.style.cssText = 'display: flex; gap: 4px; margin-bottom: 8px; justify-content: center;';
        cueButtonsGroup.innerHTML = `
          <button class="cue-number-btn" id="cueBtn${index}_1" title="Set/Jump to Cue 1">1</button>
          <button class="cue-number-btn" id="cueBtn${index}_2" title="Set/Jump to Cue 2">2</button>
          <button class="cue-number-btn" id="cueBtn${index}_3" title="Set/Jump to Cue 3">3</button>
          <button class="cue-number-btn" id="cueBtn${index}_4" title="Set/Jump to Cue 4">4</button>
          <button class="cue-number-btn" id="cueBtn${index}_5" title="Set/Jump to Cue 5">5</button>
        `;
        
        // Add event listeners for cue buttons
        for (let cueNum = 1; cueNum <= 5; cueNum++) {
          const cueBtn = document.getElementById(`cueBtn${index}_${cueNum}`);
          if (cueBtn) {
            cueBtn.addEventListener('click', () => handleCueButton(index, cueNum));
          }
        }
        
        controls.appendChild(playButton);
        controls.appendChild(volumeGroup);
        controls.appendChild(speedGroup);
        controls.appendChild(pitchGroup);
        controls.appendChild(loopGroup);
        controls.appendChild(cueButtonsGroup);
        controls.appendChild(eqControls);
        
        videoCard.appendChild(videoWrapper);
        videoCard.appendChild(videoInfo);
        videoCard.appendChild(controls);
        resultsDiv.appendChild(videoCard);

        // Initialize track state
        trackLoops[index] = false;
        trackPitch[index] = 0;
        loopPatterns[index] = '';
        loopPatternIndex[index] = 0;
        loopSegmentLooped[index] = false;
        trackEQ[index] = { low: 0, mid: 0, high: 0 };
        cuePoints[index] = {}; // Initialize as object for numbered cues
        trackBPM[index] = 120; // Default BPM

        // Wait for card to be rendered, then create player
        setTimeout(() => {
          const cardWidth = videoCard.offsetWidth || 280;
          const cardHeight = Math.round(cardWidth * 0.5625);
          
          const videoId = item.id?.videoId || item.id;
          if (!videoId) {
            console.error('No video ID found for item:', item);
            return;
          }
          
          const createPlayer = () => {
            if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
              setTimeout(createPlayer, 200);
              return;
            }
            
            try {
              players[index] = new YT.Player(videoDiv.id, {
                height: cardHeight.toString(),
                width: cardWidth.toString(),
                videoId: videoId,
                playerVars: {
                  modestbranding: 1,
                  rel: 0,
                  showinfo: 0,
                  playsinline: 1,
                  enablejsapi: 1
                },
                events: {
                  'onReady': function(event) {
                    event.target.setVolume(50);
                    setupControls(index);
                    readyPlayers.push(index);
                    
                    const iframe = videoDiv.querySelector('iframe');
                    if (iframe) {
                      iframe.style.width = '100%';
                      iframe.style.height = '100%';
                      iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture; accelerometer; gyroscope; clipboard-write; web-share');
                      iframe.setAttribute('allowfullscreen', 'true');
                    }
                  },
                  'onStateChange': function(event) {
                    updatePlayButton(index, event.data);
                    
                    if (event.data === YT.PlayerState.PLAYING && trackLoops[index]) {
                      startLoop(index);
                    } else if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                      stopLoop(index);
                    }
                  },
                  'onError': function(event) {
                    console.error('YouTube player error:', event.data);
                    const videoInfo = videoCard.querySelector('.video-info');
                    if (videoInfo) {
                      const errorDiv = document.createElement('div');
                      errorDiv.style.cssText = 'color: #ff6b6b; font-size: 11px; margin-top: 4px; padding: 4px; background: rgba(255, 107, 107, 0.1); border-radius: 4px;';
                      errorDiv.textContent = 'Video unavailable';
                      videoInfo.appendChild(errorDiv);
                    }
                    videoCard.style.opacity = '0.6';
                    videoCard.style.pointerEvents = 'none';
                  }
                }
              });
            } catch (error) {
              console.error('Error creating YouTube player:', error);
            }
          };
          
          createPlayer();
        }, 100);
      });
    }

    function toggleLock() {
      if (!copilotActive) return; // Only allow locking when DJ VEE is active
      
      djVeeLocked = !djVeeLocked;
      const lockButton = document.getElementById('lockButton');
      const lockIcon = document.getElementById('lockIcon');
      const lockText = document.getElementById('lockText');
      
      if (djVeeLocked) {
        lockButton.classList.remove('unlocked');
        lockIcon.innerHTML = getSVGIcon('lock');
        lockText.textContent = 'Lock';
      } else {
        lockButton.classList.add('unlocked');
        lockIcon.innerHTML = getSVGIcon('unlock');
        lockText.textContent = 'Unlock';
      }
      
      // Update controls based on new lock state
      updateControlsForLockState();
    }

    const searchForm = document.getElementById('searchForm');
    searchForm.addEventListener('submit', handleFormSubmit);

    const addMoreForm = document.getElementById('addMoreForm');
    addMoreForm.addEventListener('submit', handleAddMoreSubmit);

    const copilotButton = document.getElementById('copilotButton');
    copilotButton.addEventListener('click', toggleCopilot);

    const beatDropButton = document.getElementById('beatDropButton');
    beatDropButton.addEventListener('click', toggleBeatDropMix);

    const lockButton = document.getElementById('lockButton');
    lockButton.addEventListener('click', toggleLock);

    // Initialize voice button icon
    const voiceButton = document.getElementById('voiceButton');
    const voiceIcon = document.getElementById('voiceIcon');
    if (voiceIcon) {
      voiceIcon.innerHTML = getSVGIcon('mic');
    }
    voiceButton.addEventListener('click', toggleVoice);

    // TTS Setup
    const ttsButton = document.getElementById('ttsButton');
    const ttsIcon = document.getElementById('ttsIcon');
    const ttsInput = document.getElementById('ttsInput');
    
    if (ttsIcon) {
      ttsIcon.innerHTML = getSVGIcon('tts');
    }
    
    if (ttsButton) {
      ttsButton.addEventListener('click', handleTTS);
    }
    
    // Prefill buttons
    document.querySelectorAll('.tts-prefill').forEach(button => {
      button.addEventListener('click', function() {
        const text = this.getAttribute('data-text');
        if (ttsInput) {
          ttsInput.value = text;
        }
        handleTTS();
      });
    });
    
    // Enter key to speak
    if (ttsInput) {
      ttsInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          handleTTS();
        }
      });
    }

    // Spacebar button initialization
    const spacebarButton = document.getElementById('spacebarButton');
    const spacebarIcon = document.getElementById('spacebarIcon');
    if (spacebarIcon) {
      spacebarIcon.innerHTML = getSVGIcon('spacebar');
    }
    if (spacebarButton) {
      spacebarButton.addEventListener('click', handleSpacebar);
    }

    // Keyboard event listener for spacebar
    document.addEventListener('keydown', function(e) {
      // Only handle spacebar if not typing in an input field
      if (e.key === ' ' || e.key === 'Spacebar') {
        const activeElement = document.activeElement;
        const isInputField = activeElement && (
          activeElement.tagName === 'INPUT' ||
          activeElement.tagName === 'TEXTAREA' ||
          activeElement.isContentEditable
        );
        
        if (!isInputField) {
          e.preventDefault();
          handleSpacebar();
        }
      }
    });

    // Voice recording and playback functions
    async function toggleVoice() {
      if (!voiceRecording && !voiceAudio) {
        // Start recording
        await startVoiceRecording();
      } else if (voiceRecording) {
        // Stop recording and play
        await stopVoiceRecording();
      } else if (voiceAudio) {
        // Stop playback
        stopVoicePlayback();
      }
    }

    async function startVoiceRecording() {
      try {
        voiceStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(voiceStream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
          const audioUrl = URL.createObjectURL(audioBlob);
          voiceAudio = new Audio(audioUrl);
          
          // Play voice directly through speakers
          voiceAudio.play();
          voiceButton.classList.add('playing');
          voiceButton.classList.remove('recording');
          
          voiceAudio.onended = () => {
            voiceButton.classList.remove('playing');
            voiceAudio = null;
          };
        };

        mediaRecorder.start();
        voiceRecording = true;
        voiceButton.classList.add('recording');
        voiceButton.querySelector('#voiceText').textContent = 'Recording...';
      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('Microphone access denied. Please allow microphone access to record your voice.');
      }
    }

    async function stopVoiceRecording() {
      if (mediaRecorder && voiceRecording) {
        mediaRecorder.stop();
        voiceStream.getTracks().forEach(track => track.stop());
        voiceRecording = false;
        voiceButton.querySelector('#voiceText').textContent = 'Playing...';
      }
    }

    function stopVoicePlayback() {
      if (voiceAudio) {
        voiceAudio.pause();
        voiceAudio.currentTime = 0;
        voiceAudio = null;
        voiceButton.classList.remove('playing');
        voiceButton.querySelector('#voiceText').textContent = 'Voice';
      }
    }

    // Text-to-Speech Functions - Optimized for LOUD and MELODIOUS voice
    function initializeTTS() {
      if ('speechSynthesis' in window) {
        // Get available voices
        const loadVoices = () => {
          ttsVoices = speechSynthesis.getVoices();
          
          // Select best MELODIOUS voice - prefer female voices for more musical sound
          // Female voices tend to be more melodic and energetic for DJ announcements
          const preferredMelodiousVoices = [
            'Google UK English Female',  // Very clear and melodic
            'Google US English Female',  // Energetic and clear
            'Microsoft Zira',            // Professional female voice
            'Samantha',                  // Apple's melodic female voice
            'Victoria',                  // Clear female voice
            'Karen',                     // Australian melodic voice
            'Moira',                     // Irish melodic voice
            'Tessa',                     // South African melodic voice
            'Fiona',                     // Scottish melodic voice
            'Microsoft Zira Desktop'     // Windows melodic voice
          ];
          
          // Try to find preferred melodious voice
          for (const preferred of preferredMelodiousVoices) {
            const voice = ttsVoices.find(v => 
              v.name.includes(preferred) || 
              (v.name.toLowerCase().includes('female') && v.lang.startsWith('en'))
            );
            if (voice) {
              selectedVoice = voice;
              console.log('Selected melodious voice:', voice.name);
              break;
            }
          }
          
          // If no preferred found, prefer female English voices for melodious sound
          if (!selectedVoice) {
            selectedVoice = ttsVoices.find(v => 
              v.lang.startsWith('en') && 
              (v.name.toLowerCase().includes('female') || v.name.toLowerCase().includes('woman'))
            ) || ttsVoices.find(v => v.lang.startsWith('en')) || ttsVoices[0];
          }
          
          if (selectedVoice) {
            console.log('Using TTS voice:', selectedVoice.name, 'for melodious DJ announcements');
          }
        };
        
        loadVoices();
        speechSynthesis.onvoiceschanged = loadVoices;
      }
    }

    function speakText(text, options = {}) {
      if (!('speechSynthesis' in window)) {
        console.error('Text-to-speech not supported');
        return;
      }

      return new Promise((resolve) => {
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Use selected voice or best available
        if (selectedVoice) {
          utterance.voice = selectedVoice;
        }
        
        // Set properties for best quality
        // Make TTS LOUDER and MORE MELODIOUS for DJ announcements
        utterance.rate = options.rate || 0.92; // Slower rate for more melodic, musical effect
        utterance.pitch = options.pitch || 1.2; // Higher pitch (1.2) for energetic, melodious DJ voice
        utterance.volume = options.volume || 1.0; // MAXIMUM volume (1.0) for LOUDNESS
        utterance.lang = selectedVoice?.lang || 'en-US';
        
        // Enhanced melodious effect - create musical intonation
        // Higher pitch creates more energetic, DJ-like announcements
        if (!options.noMelody) {
          // Add slight pitch variation for musicality
          const isExclamation = text.includes('!');
          const isQuestion = text.includes('?');
          
          if (isExclamation) {
            // Exclamations get even higher pitch for energy
            utterance.pitch = 1.25;
            utterance.rate = 0.88; // Slower for dramatic effect
          } else if (isQuestion) {
            // Questions get rising pitch
            utterance.pitch = 1.15;
          } else {
            // Normal statements with melodic pitch
            utterance.pitch = 1.2;
          }
        }
        
        utterance.onend = () => {
          isTTSPlaying = false;
          resolve();
        };
        
        utterance.onerror = (error) => {
          console.error('TTS Error:', error);
          isTTSPlaying = false;
          resolve();
        };
        
        isTTSPlaying = true;
        speechSynthesis.speak(utterance);
      });
    }

    function playTTSBetweenTracks(text) {
      // Add to queue for DJ VEE to play between tracks
      ttsQueue.push(text);
    }

    // Auto-generate TTS phrases for DJ VEE based on context
    function generateAutoTTSPhrase(context) {
      const phrases = {
        trackStart: [
          'Let\'s go!',
          'Here we go!',
          'Feel the beat!',
          'Energy rising!',
          'This is DJ VEE!'
        ],
        trackTransition: [
          'Smooth transition!',
          'Here comes the drop!',
          'Feel the mix!',
          'Next level!',
          'Keep it going!'
        ],
        energyBoost: [
          'Energy boost!',
          'Pump it up!',
          'Feel the power!',
          'Maximum energy!',
          'Let\'s go higher!'
        ],
        genreChange: [
          'Changing the vibe!',
          'New energy!',
          'Different flow!',
          'Fresh sound!',
          'New direction!'
        ]
      };
      
      const categoryPhrases = phrases[context] || phrases.trackStart;
      return categoryPhrases[Math.floor(Math.random() * categoryPhrases.length)];
    }

    async function handleTTS() {
      const ttsInput = document.getElementById('ttsInput');
      const text = ttsInput.value.trim();
      
      if (!text) return;
      
      // Play immediately - LOUD and MELODIOUS
      await speakText(text, {
        volume: 1.0,  // MAXIMUM volume - LOUD
        rate: 0.92,  // Slower for more melodic, musical effect
        pitch: 1.2   // Higher pitch (1.2) for energetic, melodious DJ voice
      });
      
      // Also add to DJ VEE queue
      playTTSBetweenTracks(text);
      
      // Clear input
      ttsInput.value = '';
    }

    // Initialize TTS on page load
    initializeTTS();

    document.getElementById('searchQuery').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        handleFormSubmit(e);
      }
    });

    function displayLocalVideos() {
      const backgroundContainer = document.getElementById('backgroundVideos');
      if (!backgroundContainer) return;
      
      backgroundContainer.innerHTML = '';
      
      localVideoElements = [];
      readyPlayers = [];
      autoPlayActive = true;
      userInteracted = false;
      backgroundVideoStarted = false;

      localVideos.forEach((videoFile, index) => {
        const videoElement = document.createElement('video');
        videoElement.className = 'background-video';
        videoElement.id = `bgVideo${index}`;
        videoElement.src = videoFile;
        videoElement.muted = true;
        videoElement.loop = false; // Don't loop - play sequentially
        videoElement.playsinline = true;
        videoElement.preload = 'auto';
        
        backgroundContainer.appendChild(videoElement);
        localVideoElements.push(videoElement);
        
        // Single event listener to start first video
        let videoStarted = false;
        const startVideoOnce = () => {
          if (index === 0 && autoPlayActive && !backgroundVideoStarted && !videoStarted) {
            videoStarted = true;
            backgroundVideoStarted = true;
            console.log('First background video ready, starting playback');
            setTimeout(() => playBackgroundVideo(0), 200);
          }
        };
        
        // Track when video is ready - use multiple events but only start once
        videoElement.addEventListener('canplay', () => {
          if (!readyPlayers.includes(index)) {
            readyPlayers.push(index);
            console.log(`Background video ${index} ready`);
          }
          startVideoOnce();
        });
        
        videoElement.addEventListener('loadeddata', () => {
          if (!readyPlayers.includes(index)) {
            readyPlayers.push(index);
          }
          startVideoOnce();
        });
        
        // Auto-advance to next video when current ends
        videoElement.addEventListener('ended', () => {
          console.log(`Background video ${index} ended, switching to next`);
          const nextIndex = (index + 1) % localVideos.length;
          switchToNextBackground(index);
        });
        
        // Handle errors
        videoElement.addEventListener('error', (e) => {
          console.error(`Error loading background video ${index}:`, e, videoFile);
        });
        
        // Try to load immediately
        videoElement.load();
      });
    }

    function startBackgroundVideoSequence() {
      if (!autoPlayActive || readyPlayers.length === 0 || backgroundVideoStarted) return;
      
      // Start with first video
      backgroundVideoStarted = true;
      playBackgroundVideo(0);
    }

    function playBackgroundVideo(index) {
      if (localVideoElements.length === 0) {
        console.log('No background videos available');
        return;
      }
      
      console.log(`Attempting to play background video ${index}`);
      
      // Stop all background videos
      localVideoElements.forEach((video, i) => {
        if (video) {
          video.pause();
          video.classList.remove('active');
        }
      });
      
      // Play selected video
      const video = localVideoElements[index];
      if (!video) {
        console.error(`Background video ${index} not found`);
        return;
      }
      
      console.log(`Playing video ${index}, src: ${video.src}`);
      video.currentTime = 0;
      video.muted = true; // Ensure muted for autoplay
      
      // Make visible immediately
      video.style.opacity = '1';
      video.classList.add('active');
      
      const playPromise = video.play();
      
      if (playPromise !== undefined) {
        playPromise.then(() => {
          console.log(`Background video ${index} playing successfully`);
          video.style.opacity = '1';
          video.classList.add('active');
          // Verify it's actually playing
          console.log(`Video playing state: ${!video.paused}, currentTime: ${video.currentTime}`);
        }).catch(err => {
          console.error(`Background video ${index} play failed:`, err);
          // Keep it visible even if play fails
          video.style.opacity = '1';
          video.classList.add('active');
          // Try again after a short delay
          setTimeout(() => {
            video.play().then(() => {
              console.log(`Background video ${index} playing on retry`);
              video.style.opacity = '1';
            }).catch(e => {
              console.error('Retry also failed:', e);
            });
          }, 1000);
        });
      } else {
        video.style.opacity = '1';
        video.classList.add('active');
      }
    }

    function switchToNextBackground(currentIndex) {
      const nextIndex = (currentIndex + 1) % localVideoElements.length;
      console.log(`Switching from video ${currentIndex} to video ${nextIndex}`);
      
      // Fade transition
      const currentVideo = localVideoElements[currentIndex];
      const nextVideo = localVideoElements[nextIndex];
      
      if (currentVideo) {
        currentVideo.classList.remove('active');
        currentVideo.style.opacity = '0';
        currentVideo.pause();
      }
      
      // Small delay for smooth transition
      setTimeout(() => {
        if (nextVideo) {
          nextVideo.currentTime = 0;
          nextVideo.muted = true;
          nextVideo.style.opacity = '1';
          nextVideo.classList.add('active');
          
          nextVideo.play().then(() => {
            console.log(`Background video ${nextIndex} playing`);
          }).catch(err => {
            console.error(`Background video ${nextIndex} play failed:`, err);
            // Retry
            setTimeout(() => {
              nextVideo.play().catch(e => console.error('Retry failed:', e));
            }, 500);
          });
        }
      }, 500);
    }

    // Get current playing video index
    function getCurrentBackgroundIndex() {
      for (let i = 0; i < localVideoElements.length; i++) {
        if (localVideoElements[i] && localVideoElements[i].classList.contains('active') && !localVideoElements[i].paused) {
          return i;
        }
      }
      return -1;
    }

    // Enable video playback on any user interaction (click anywhere)
    document.addEventListener('click', function enableVideos() {
      if (localVideoElements.length > 0 && !userInteracted) {
        userInteracted = true;
        localVideoElements.forEach(video => {
          if (video && video.paused) {
            video.muted = true;
            video.play().catch(err => {
              console.error('Video play on click failed:', err);
            });
          }
        });
        // Start the sequence if not already playing
        const activeVideo = localVideoElements.find(v => v.classList.contains('active'));
        if (!activeVideo) {
          playBackgroundVideo(0);
        }
      }
    }, { once: false });

    function setupLocalControls(index, videoElement) {
      const volumeSlider = document.getElementById(`volume${index}`);
      const volumeValue = document.getElementById(`volumeValue${index}`);
      
      if (volumeSlider && volumeValue) {
        volumeSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - enable unmuting
            if (!userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
              // Unmute all videos after user interaction
              localVideoElements.forEach(v => {
                if (v) v.muted = false;
              });
            }
            
            const volume = parseInt(this.value);
            videoElement.volume = volume / 100;
            if (videoElement.muted && volume > 0) {
              videoElement.muted = false;
            }
            volumeValue.textContent = volume + '%';
          }
        });
      }

      const speedSlider = document.getElementById(`speed${index}`);
      const speedValue = document.getElementById(`speedValue${index}`);
      
      if (speedSlider && speedValue) {
        speedSlider.addEventListener('input', function() {
          if (!this.disabled) {
            // User interaction - enable unmuting
            if (!userInteracted) {
              userInteracted = true;
              autoPlayActive = false;
              // Unmute all videos after user interaction
              localVideoElements.forEach(v => {
                if (v) v.muted = false;
              });
            }
            
            const speed = parseFloat(this.value);
            videoElement.playbackRate = speed;
            speedValue.textContent = speed.toFixed(2) + 'x';
          }
        });
      }
    }

    function toggleLocalPlay(index) {
      // Always stop all other videos first - only one plays at a time
      localVideoElements.forEach((video, i) => {
        if (i !== index && !video.paused) {
          video.pause();
          updateLocalPlayButton(i, false);
          const card = document.getElementById(`card${i}`);
          if (card) card.classList.remove('playing');
        }
      });
      
      // User interaction - enable unmuting
      if (!userInteracted) {
        userInteracted = true;
        autoPlayActive = false;
        // Unmute all videos after user interaction
        localVideoElements.forEach(video => {
          if (video) {
            video.muted = false;
          }
        });
      }
      
      const video = localVideoElements[index];
      if (!video) return;
      
      if (video.paused) {
        // Unmute on play if user has interacted
        if (userInteracted) {
          video.muted = false;
        }
        video.play().catch(err => {
          console.log('Play failed, trying muted:', err);
          video.muted = true;
          video.play();
        });
        updateLocalPlayButton(index, true);
        document.getElementById(`card${index}`).classList.add('playing');
        currentPlayingIndex = index;
      } else {
        video.pause();
        updateLocalPlayButton(index, false);
        document.getElementById(`card${index}`).classList.remove('playing');
        currentPlayingIndex = -1;
      }
    }

    function updateLocalPlayButton(index, playing) {
      const playButton = document.getElementById(`playBtn${index}`);
      if (playButton) {
        playButton.textContent = playing ? 'Pause' : 'Play';
        playButton.classList.toggle('playing', playing);
      }
    }

    function playLocalVideoAuto(index) {
      if (!autoPlayActive || userInteracted) return;
      
      const video = localVideoElements[index];
      if (!video) return;
      
      // ALWAYS stop all other videos first - only one plays at a time
      localVideoElements.forEach((v, i) => {
        if (i !== index) {
          v.pause();
          updateLocalPlayButton(i, false);
          const card = document.getElementById(`card${i}`);
          if (card) card.classList.remove('playing');
        }
      });
      
      // Start muted for autoplay policy compliance
      video.muted = true;
      video.volume = 0.5; // Set volume but keep muted until user interaction
      
      // Try to play (will be muted)
      video.play().catch(err => {
        console.log('Autoplay failed:', err);
      });
      
      // Fade in volume over 1 second (but video stays muted until user interaction)
      let volumeStep = 0;
      const fadeInterval = setInterval(() => {
        volumeStep += 2;
        if (volumeStep <= 50) {
          video.volume = volumeStep / 100;
        } else {
          clearInterval(fadeInterval);
          video.volume = 0.5;
        }
      }, 40);
      
      const playButton = document.getElementById(`playBtn${index}`);
      const videoCard = document.getElementById(`card${index}`);
      
      if (playButton) {
        playButton.innerHTML = getSVGIcon('pause');
        playButton.classList.add('playing');
      }
      if (videoCard) {
        videoCard.classList.add('playing');
      }
      
      currentPlayingIndex = index;
    }

    // Auto-load background videos on page load
    window.addEventListener('load', function() {
      console.log('Page loaded, initializing background videos');
      setTimeout(() => {
        displayLocalVideos();
      }, 500);
    });

    // Also try on DOMContentLoaded as fallback
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM ready, checking for background videos');
      if (localVideoElements.length === 0) {
        setTimeout(() => {
          displayLocalVideos();
        }, 300);
      }
      
      // Initialize voice button icon
      const voiceIcon = document.getElementById('voiceIcon');
      if (voiceIcon) {
        voiceIcon.innerHTML = getSVGIcon('mic');
      }
      
      // Initialize lock button icon
      const lockIcon = document.getElementById('lockIcon');
      if (lockIcon) {
        lockIcon.innerHTML = getSVGIcon('lock');
      }
      
      // Initialize TTS
      initializeTTS();
    });

    // Videos now automatically advance when each one ends (no timer needed)
  </script>
</body>
</html>
